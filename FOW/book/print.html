<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Layered Fog Of War documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="documentation.html">Documentation</a></li><li class="chapter-item expanded "><a href="book/index.html">Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/getting_started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="book/architecture/index.html">Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/architecture/Handler.html">Handler</a></li><li class="chapter-item expanded "><a href="book/architecture/Floor.html">Floor</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/index.html">Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/First_set_up.html">First set up</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/index.html">Entities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/entities/Visibility_Entity.html">Visibility entity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/Drawing_Entity.html">Drawing entity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/Collision_Entity.html">Collision entity</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/Layers.html">Layers</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Outdoor_Indoor.html">Outdoor Indoor</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Networking.html">Networking</a></li><li class="chapter-item expanded "><a href="book/Tutorials/FogChannels.html">Fog Channels</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Floor_Verticality.html">Floor and verticality</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Minimap.html">Minimap</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference.html">C++ API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes.html">Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes/AFOW_Handler.html">AFOW_Handler</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_CollisionEntity_Interface.html">IFOW_CollisionEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_DrawingEntity_Interface.html">IFOW_DrawingEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_Entity_Interface.html">IFOW_Entity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_GeometryEntity_Interface.html">IFOW_GeometryEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_VisibilityEntity_Interface.html">IFOW_VisibilityEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_CollisionHandler.html">UFOW_CollisionHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_DrawerComponent.html">UFOW_DrawerComponent</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Drawer_Shared.html">UFOW_Drawer_Shared</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityContainer.html">UFOW_EntityContainer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityVisibilityHandler.html">UFOW_EntityVisibilityHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Floor.html">UFOW_Floor</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerHandler.html">UFOW_LayerHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerSetting.html">UFOW_LayerSetting</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Rasterizer.html">UFOW_Rasterizer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_TextureSample.html">UFOW_TextureSample</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Tile_Class.html">UFOW_Tile_Class</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_VisibilityE_Component.html">UFOW_VisibilityE_Component</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Layered Fog Of War documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="/book/index.html">Book</a></li>
<li><a href="/reference.html">C++ API Reference</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><p>#Book</p>
<p>This book covers explanation of the Layered Fog Of War architecture. You will find implementation
example, code explanation and how to make the best use of the FOW. This plugin is easy to use but
might become painfull to understand when you need better performance from it</p>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="book//book/getting_started.html">Getting Started</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="book/getting_started.html#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></li>
<li><a href="book/getting_started.html#features">Features</a>
<ul>
<li><a href="book/getting_started.html#high-definition-big-map">High Definition, Big Map</a></li>
<li><a href="book/getting_started.html#tons-of-ai">Tons of AI</a></li>
<li><a href="book/getting_started.html#vertical-games">Vertical Games</a></li>
<li><a href="book/getting_started.html#networking">Networking</a></li>
<li><a href="book/getting_started.html#developer-playground">Developer Playground</a></li>
<li><a href="book/getting_started.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>
<h2 id="the-fog-of-war-is-only-a-texture"><a class="header" href="#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></h2>
<p>To understand the technology, you have to see the FOW as a texture:</p>
<blockquote>
<p><strong>By using a texture, it should be possible to create games with a "flat" map. Gameplay areas
can't be superimposed, or you will discover undesirable parts of it. However, with multiple layers
and by applying transparency, we can get through this problem.</strong></p>
</blockquote>
<p>Quick definition:
A fog of war is a common game mechanic used in strategy and real-time strategy (RTS) games to
simulate uncertainty and limited visibility. It obscures parts of the game map that are not
currently within the player's line of sight or knowledge, typically represented by a shroud or
darkness.</p>
<p>A FOW is just a set of data represented as a texture, which allows the computer to hide some part
of the rendered frame from the player during the post-process pass. It will project the position
of the rendered pixel onto a plane delimiting the FOW. The projection will then query the state
of the fog texture to know if the player has sight on this pixel. It's a simple process of flattening
all the assets onto a plane.</p>
<p>The texture generation is done by elements called "Drawers"; they will compute a texture fragment
of what they see. Drawers can draw any shape to reveal an area. There are two different usages:</p>
<ul>
<li>Drawing circles which reveal everything around the player.</li>
<li>Casting the collision geometry shadow to simulate the sight of the player.</li>
</ul>
<p>Once every fragment is generated, they will be merged under the fog texture to be rendered.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="high-definition-big-map"><a class="header" href="#high-definition-big-map">High Definition, Big Map</a></h3>
<h4 id="1-intro"><a class="header" href="#1-intro">1. Intro</a></h4>
<p>The Fog of War algorithms are simple in theory but heavy to update. To have a decent frame rate,
you have to downgrade the texture precision to reduce the rasterization time of the drawers, the
texture update on the GPU, or the GPU texture sampling time. The fog update being heavy was also
an obstacle for game development. Maps had to be small for a high fog definition, or the definition
had to be low for huge maps. I've wanted to prevent that and let everyone choose any precision
without any repercussions.</p>
<h4 id="2-handler-floor-tile-sample"><a class="header" href="#2-handler-floor-tile-sample">2. Handler, Floor, Tile, Sample</a></h4>
<p>The Fog Of War is split into floors representing parts of your level. You can have as many as you
want, and you can juxtapose or even superpose them to give verticality. Every floor shares the
same settings given from the handler and will have the same precision. They are also divided into
tiles and snapped to a grid to simplify the merge and update process time. The FOW can have up to
8 visibility channels to represent fog. Only 2 channels are used in the given version to represent
3 states of fog:</p>
<ul>
<li>Seen: The player came earlier and is aware of the layout of the area.</li>
<li>Visible: The player directly sees the area.</li>
<li>Unseen: The player has never seen this area (meaning both of the channels are equal to 0).</li>
</ul>
<p>It's up to you to find more usages of the 6 other channels. You can also use only one channel to
make MOBA-like games where the map is fully visible.</p>
<h4 id="3-optimization-for-large-scale-projects"><a class="header" href="#3-optimization-for-large-scale-projects">3. Optimization for Large-Scale Projects</a></h4>
<p>To overcome the update time, the FOW uses samples of fog to send to the GPU and uses binary
compression of everything related to a texture. They are compressed such as 1 bit = 1 pixel. Doing
so reduces the memory usage but also the pixel processing time by doing bitwise operations. Most
of the update work is related to merging two textures, which means applying an "OR" operator between
two textures. Since all the pixels are packed and our computer can use registers up to 512 bits,
the FOW can also compute up to 512 pixels in one operation.</p>
<h4 id="4-architecture-repercussion"><a class="header" href="#4-architecture-repercussion">4. Architecture Repercussion</a></h4>
<p>To allow the best usage of binary operation, channels had to be separated and can be seen as N
different textures. Simplified representation of the texture</p>
<p>Normal texture:        -&gt;   FOW texture:<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br /></p>
<h3 id="tons-of-ai"><a class="header" href="#tons-of-ai">Tons of AI</a></h3>
<h4 id="1-intro-1"><a class="header" href="#1-intro-1">1. Intro</a></h4>
<p>Projects using FOW are mostly games using lots of AI. It was one of the main objectives, being
able to simulate thousands of units drawing fog. This plugin had to be ready for games like
"Among Us" but also for RTS or MOBA like "Age Of Empires" or "League Of Legends." Once more,
performance was the issue and had to be solved without impacting the precision or the map scaling.</p>
<h4 id="2-drawer-shareddrawer-entity-rasterizer"><a class="header" href="#2-drawer-shareddrawer-entity-rasterizer">2. Drawer, SharedDrawer, Entity, Rasterizer</a></h4>
<p>Each player has a number of units represented in the game. Those units help him to navigate,
discover, and fulfill the objective of the game. To discover the layout of the game, the FOW will
use Drawers. Those drawers are components registered into the FOW, which will generate a fragment
of fog represented as a bit array. This fragment is the representation of the sight of the owning
actor. It can draw any shape and will provide its fragment during the floor update to generate the
Fog Texture. However, merging thousand fragments is really inappropriate. It uses lots of memory,
memory isn't aligned, lots of CPU cache is requested, and it doesn't respect patterns that accelerate
computation. To ameliorate the process, the FOW follows the Data-Oriented Design (DOD) and allows
developers to use Entities instead of drawers. Entities are the representation of an object in the
game and will provide data to a "SharedDrawer," which will be able to update all registered entities
during a single update.</p>
<p>To generate a fog fragment, every drawer has a reference to a rasterizer. Drawers are data containers
designed to generate geometry that can be given to them. They are simple pieces of code that can be
overridden for specific usage. In the current state, two rasterizers are provided:</p>
<ul>
<li>UFOW_R_TriangledGeometryV1, made to draw convex geometry from a set of vertices</li>
<li>UFOW_R_CircleV1, made to draw a circle from one vertex</li>
</ul>
<h4 id="3-optimization-for-large-scale-projects-1"><a class="header" href="#3-optimization-for-large-scale-projects-1">3. Optimization for Large-Scale Projects</a></h4>
<p>To fasten the fragment generation process, the FOW packs data and follows DOD architecture.It takes
profit of multithreaded processors by doing asynchronous updates and allows the FOW to make discrete
updates which don't interfere with the game thread. In case of heavy updates, the FOW can be computed
in many Engine frames to prevent game freeze.</p>
<p>The DOD and task system are an entry point to the GPU computation. Everything has been thought to make
it possible and might be developed in the near future.</p>
<h2 id="vertical-games"><a class="header" href="#vertical-games">Vertical games</a></h2>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>It has been a challenge to allow everyone to create vertical top-down games. I took part in the development
of "Alien Dark Descent," and it has been tough to implement ladders and stairs. However, the FOW couldn't
dissociate the bottom from the top. So it was impossible to let the player discover the ground level and
then discover the basement without a level transition. As explained a bit earlier, the Layered FOW is made
out of floors that can be set up anywhere in the game. They will generate fog in the provided area, and
drawers will remove it. Nothing is required from the user to make verticality!</p>
<h3 id="gpu-data-transfer"><a class="header" href="#gpu-data-transfer">GPU data transfer</a></h3>
<p>Because of the GPU being the GPU, it was tough to go the simple way and send N textures representing the fog of floors. Plus, the update would have been super heavy. It was necessary to find a workaround to send data of each floor. The problem has been solved by packing floor fog samples into one texture; sample sizes are determined by the intersection of the camera frustum and the floor fog plane. However, a bigger texture will be required to update every floor.</p>
<p>To render correctly superposed floors, the material has to project and find the closest floors to query the fog state.</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h3>
<p>Most of the top-down games we play are competitive or cooperative, which means that the game needs networking.
On that behalf, the FOW has minimal Replication implementation. It's based on the fact that every player runs
the same simulation, which means that every client actor has the same position as the server. If this is
correct, there is no need to replicate the state of the FOG through the network; the only thing to synchronize
is which drawer draws for which team.</p>
<h3 id="fogstatereplication-clientserver"><a class="header" href="#fogstatereplication-clientserver">FogStateReplication Client/Server</a></h3>
<p>FogStateReplication is responsible for the synchronization between the client and the server. It's responsible
for fog synchronization; the server is able to send the FOW state to any client for game initialization. And
will provide a team ID to every client. This ID is used in each game instance to enable/disable drawers with the
same ID. Once the state and IDs synchronize, nothing else will go through the network regarding the FOW.</p>
<h3 id="replication-and-team-limitation"><a class="header" href="#replication-and-team-limitation">Replication and Team limitation</a></h3>
<p>To allow FOW state replication, the server has to be aware of the state of each team. It means that a game using 2
channels to represent "Seen" and "Visible" state can only have up to 4 teams. I've talked about it a bit earlier; the
FOW can use at the maximum 8 channels. The replication becomes not only a limitation for games by limiting the
team number, but also a performance limitation. The server user will have to constantly compute the fog of each
team even if only 1 team is displayed. Clients don't have this performance issue since they will update only the
attributed team.</p>
<p>Nevertheless, there is a workaround to palliate this limitation. It's possible to tell the server to compute only
the user team. The network will still work, but the FOW state won't be able to be synchronized in case of late
connection. One more thing to understand is that synchronization is useful only for a certain type of fog. The
client doesn't need any synchronization if the game uses the Visible channel. Once every Drawers will be synchronized
with the correct team, they will remove fog at their location to reproduce the state on the server.</p>
<p>To summarize, you can replicate the FOG state but you will have a team limitation depending on the number of channels
used per team. If you don't enable this replication and let the server compute the fog from its player ID you can
have as much team as you want!</p>
<h2 id="developer-playground"><a class="header" href="#developer-playground">Developer playground</a></h2>
<h3 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h3>
<p>This part is a bit more personal. I've wanted my plugin to be modular, with replaceable parts. I'm always
thinking that a better version exists which brings the necessity to slice my code and make it overridable.
It even became a pattern for me, making small modules and preventing to the maximum dependencies. On that
behalf, the plugin has many settings variables representing object classes to replace the provided ones.</p>
<p>I'm calling it a playground because it can be really simple modification to test a C++ functionality.
There are lots of modules that are containers where you can try to switch an array for a map, or where
you can add an acceleration structure to help the query function. As an example, I've made a naive collision
system testing collision with every registered collider, but I've also made another one using an AABB tree
to query the colliders in bounds.</p>
<h3 id="this-is-where-the-fun-begins"><a class="header" href="#this-is-where-the-fun-begins">This is Where the Fun Begins!</a></h3>
<p>I'll try to provide everything to let you replace the module and play with the code in the source files.
Here is the list of the modules and their working field:</p>
<ul>
<li>
<p>UFOW_Rasterizer: You can challenge yourself to find the fastest way to draw a triangle. You can also work on specific rasterizers specific to draw geometry from formulas (Cone, torus, rectangle ...)</p>
</li>
<li>
<p>UFOW_CollisionHandler: Key stone of the drawers computation time when casting collision shadow. Accelerate the collider querying with structure (AABB tree, Spatial hashing, octree ...)</p>
</li>
<li>
<p>UFOW_OcclusionBuffer: Occlusion system for the CollisionHandler to ignore collider. R&amp;D around the occlusion, the default one use 1D depth buffer</p>
</li>
<li>
<p>TFOW_Tile_Base: Merge the drawer fog fragment. You can play with SIMD instruction and find a faster way to merge everything</p>
</li>
<li>
<p>UFOW_DrawerComponent: Implement your custom drawer. You can play with tasks and multithreading</p>
</li>
<li>
<p>UFOW_SaveLoad: Generate a TArray<uint8> to be written in a file. You can play with pointers and compression</p>
</li>
<li>
<p>AFOW_FogStateReplication: If you need to adapt the network to your pipeline</p>
</li>
<li>
<p>AFOW_Handler: If you need to adapt the loading or update pipeline</p>
</li>
<li>
<p>UFOW_Floor: If you need to adapt the update pipeline</p>
</li>
</ul>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<h2>Everything works correctly by default; however, you might need to tweak a few settings and have a good
understanding of how the entities work for games with lots of AI.
You can make extremely vast games without vertical limits.
A simple replication implementation is already done allowing you to make online games.
If you are curious you're more than welcome to replace everything !!!! :)</h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section will explain in-depth how the Fog Of War has been thought out. It'll give you
the keys to tweak everything and set up the plugin to fit your game the best possible way.</p>
<p>Keep in mind that the Layered FOW doesn't need any modification to be used in game; only
if performances are an issue, modifications will be necessary.</p>
<h2 id="everything-is-tile-shaped"><a class="header" href="#everything-is-tile-shaped">Everything is Tile-shaped</a></h2>
<p>To allow high precision and large scale game, everything has been cut into pieces which can
be seen as tiles. This tiling system is really efficient for optimization and multithreading.
The FOW is designed this way:</p>
<ul>
<li><strong>FOWHandler</strong>: the biggest piece holding every data. It's a singleton, and only one instance can
exist in the level.</li>
<li><strong>FOWFloors</strong>: 3D boxes held by the Handler, where the fog will be applied. There is no number or
position limitation. It will store a bits array of the fog state and everything necessary to generate
fog fragment.</li>
<li><strong>FOWTiles</strong>: Defined by a power of 2 of fog pixels, it will create a grid for every element
interacting with the fog. Used to merge fog fragment to the result texture in the Floors.</li>
<li><strong>FOWTextureSample</strong>: The bond between CPU and GPU, it will collect Floors bit array to send it
to the GPU via a texture.</li>
</ul>
<h2 id="the-logic-is-managed-by-entities"><a class="header" href="#the-logic-is-managed-by-entities">The logic is managed by Entities</a></h2>
<p>The Entities are a suite of interfaces allowing data generation or querying. They are self-dependent
and don't need any update, no API is provided unless two methods to enable/disable the entity. The
FOW will do all the updates it needs to correctly generate the fog state of the frame. Entities exist
in 3 different forms inheriting from a base interface, plus one a bit different, designed for a late
purpose:</p>
<ul>
<li><strong>CollisionEntity</strong>: Provide methods to gather collision from an object. Collisions are used by the
drawers to cast shadow. The entity will be stored in CollisionHandler.</li>
<li><strong>DrawingEntity</strong>: Provide methods to collect drawing settings from an object. The entity will be
registered to shared drawer to generate fog fragment.</li>
<li><strong>VisibilityEntity</strong>: Provide methods to collect object size and location to update its visible
state depending on the fog.</li>
<li><strong>GeometryEntity</strong>: It doesn't derive from the Entity base class; its purpose is to hold geometry
data to be used by entities (calling it GeometryEntity was a mistake).</li>
</ul>
<h1 id="pages-1"><a class="header" href="#pages-1">Pages</a></h1>
<ul>
<li><a href="book/architecture//book/architecture/Handler.html">Handler</a></li>
<li><a href="book/architecture//book/architecture/Floor.html">Floor</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="book/architecture/Handler.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Handler.html#settings">Settings</a>
<ul>
<li><a href="book/architecture/Handler.html#editor-debug-setting">Editor debug setting</a></li>
<li><a href="book/architecture/Handler.html#fog-setting">Fog setting</a></li>
<li><a href="book/architecture/Handler.html#update-settings">Update settings</a></li>
<li><a href="book/architecture/Handler.html#module-settings">Module settings</a></li>
<li><a href="book/architecture/Handler.html#rendering-settings">Rendering settings</a></li>
</ul>
</li>
<li><a href="book/architecture/Handler.html#initialisation">Initialisation</a></li>
<li><a href="book/architecture/Handler.html#updates">Updates</a></li>
</ul>
</li>
</ul>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p><a href="book/architecture//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a> is a singleton used to store <a href="book/architecture/Floor.html">Floors</a>
and used to change the Fog settings (Pixel size, Encoding, Collision system ...). It defines
the initialisation and the update loop. All initialisation happens during the begin play unless
for the floor generation that is instantiated straight into the editor.</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<h4 id="editor-debug-setting"><a class="header" href="#editor-debug-setting">Editor debug setting</a></h4>
<ul>
<li><code>ShowGrid</code>: display the grid delimited by the tile. Floors are snapped to this grid.</li>
<li><code>ShowFloors</code>: display the 3D box representing the floors. The pink square is the real position of
the floor, it will be aligned to the grid. The yellow square is the 3D Fog representation.</li>
</ul>
<h4 id="fog-setting"><a class="header" href="#fog-setting">Fog setting</a></h4>
<ul>
<li><code>PixelSize</code> let you adapte the fog precision, the value is expresse in centimeter</li>
<li><code>FOWFloors</code> let you create new game area with fog</li>
<li><code>TilePixelNumber</code> let you change the tile dimension by modifying their pixel number. Changing
tile size might become interesting for high fog precision, it will reduce the number of tile
merging and will allow the usage of bigger register for the merging.</li>
<li><code>ChannelToClearAtStart</code> let you choose the default fog status at start. Useful if you
have a map with hidden area and the rest visible. Use <code>AFOW_DrawingE_Custom</code> with <code>UFOW_FloorStartUpLayer</code>
to add fog where it's needed. Fog will be cleared and re-draw during the initialisation and the very first frame.</li>
<li><code>LayerHandler_Class</code> let the possibility to the user to organise the layer merging.</li>
<li><code>FOWFloorTiles_Class</code> let you choose the number of channel used by the game. It is also designed to select
the computation methode of tile merging. Warning register used cannot be bigger than <code>TilePixelNumber</code></li>
</ul>
<h4 id="update-settings"><a class="header" href="#update-settings">Update settings</a></h4>
<ul>
<li><code>FOWComputeSetting</code> Change the right of the FOW to use or not multithreading/Task/ComputeShader (compute shader not done yet).</li>
<li><code>FOWUpdateRate</code> Change the update rate of the FOW. However I do not recommend to use it, render will be impacted
and become less smooth. I recommand to enable task and let the FOW do discrete updates.</li>
</ul>
<h4 id="module-settings"><a class="header" href="#module-settings">Module settings</a></h4>
<p>Modules that can be changed in the handler are stored under the <code>Settings|Class</code> section. There is
a differentiation between static and dynamic because some modules can be more or less optimized
depending on those two parameters (The AABBCollisionHandler has an update time super long for dynamic objects).</p>
<h4 id="rendering-settings"><a class="header" href="#rendering-settings">Rendering settings</a></h4>
<ul>
<li><code>FOWShader_Class</code> change the render system of the FOW. 3 different materials are provided
with the plugin:
<ul>
<li><code>MPP_FOW_Floors</code>: for flat game</li>
<li><code>MPP_FOW_FloorsTransparency</code>: for games with verticality</li>
<li><code>MUI_FOW_Minimap</code>: for the minimap</li>
</ul>
</li>
</ul>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>The initialisation of the FOW happens in the begin play and can be delayed if your pipeline needs it.
Initialization is split into many sections:</p>
<ul>
<li><code>InitNetwork</code> will create a <strong>Replicated</strong> environment only if the game isn't standalone and if
the layer setting class is correctly set. Set network setting as the right to override many values
from the Handler to provide the accessibility to different clients. Thus it has to be executed first.</li>
<li><code>InitTeams</code> isn't used and will be deleted.</li>
<li>`InitFOWFloorsTiles" Allocates the memory used by the floor. The FOW cannot do anything without it.
The tiles must be initialized before the game shader.</li>
<li><code>InitGameShader</code> Generates <code>FOWTextureSample</code> that will be linked to the instantiated <code>FOWShader_Class</code>.
You can override this to generate more material if needed. However, you have the possibility to create
and register texture sample at any time; don't force yourself to do everything in this method.</li>
<li><code>InitFOWUpdate</code> is the most interesting method. If you have pipeline trouble, I recommend to let every
other initialization call and to delay only this one. Until this call is made, no update from the fog but
even from this entity or the collision system will happen. <strong>Please be very cautious to call <code>FinalizeInitialization</code>
just after the call of this method.</strong></li>
</ul>
<h4 id="visual-representation-of-the-initialisation-pipeline"><a class="header" href="#visual-representation-of-the-initialisation-pipeline">Visual representation of the initialisation pipeline</a></h4>
<p><img src="book/architecture/../../assets/FOWInitialisation.drawio.png" alt="FOWHandler initialisation pipeline" /></p>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>By default, the update happens during the actor tick. Every component of the FOW will be updated during
this sequence unless for the <code>FOWTextureSample</code>. The update will be done at once if no asynchronous
tasks are requested and will be managed by two methods:</p>
<ul>
<li><code>FOWUpdate_Begin</code> manages every update that needs to happen to let drawers generate fog fragment.
It'll update the dynamic Entities first and then the collision. It will also be responsible for multithreading
initialization.</li>
<li><code>FOWUpdate_End</code> is called after that the drawers have generated their fog fragment. Depending on the usage
of task or compute shader, it'll be called right after the begin update or later in the frame. Fog fragment
will be sorted and distributed to floors to update the fog state. Once updated transient drawer will be deleted
and all "visibleEntity" will update their state to turn on/off their render.</li>
</ul>
<p>The <code>FOWTextureSample</code> has a special place to be updated because of the engine camera update time. To generate
fog sample the sample has to be aware of the position of the camera; however, Unreal updates their position at
the end of the tick. To prevent sample from sending wrong texture information, their updates happen at the very
end of the world tick. There is a second reason of why their update is separated and independent. In case
of long update, the FOW can skip an update frame if using asynchronous update. It doesn't impact the render
to not change the fog state, however, fog data on the GPU has to be perfectly synchronized with game or
artifacts might show up.</p>
<h4 id="visual-representation-of-the-updates-pipeline"><a class="header" href="#visual-representation-of-the-updates-pipeline">Visual representation of the Updates pipeline</a></h4>
<h2 id=""><a class="header" href="#"><img src="book/architecture/../../assets/FOWUpdate.drawio.png" alt="FOWHandler update pipeline" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor"><a class="header" href="#floor">Floor</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="book/architecture/Floor.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Floor.html#settings">Settings</a></li>
<li><a href="book/architecture/Floor.html#fog-update">Fog Update</a></li>
</ul>
</li>
</ul>
<h2 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h2>
<p><strong><code>AFOW_Floor</code></strong> represents 3D boxes held by the <a href="book/architecture//book/architecture/Handler.html">Handler</a>, where the fog
is applied. The fog is stored in a "bit array" that is updated and sampled every frame. The update is
facilitated by the <strong><code>TFOW_Tile_Base</code></strong>, which shares the bit array pointer to allow
multithreading and prevent unnecessary updates if no Drawer fragment has updated the tile area. Floors
contain all the entities within them, registered in:</p>
<ul>
<li><a href="book/architecture//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a> for <a href="book/architecture//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a>, with the
base class defined in <strong><code>FOW_LayerSetting</code></strong></li>
<li><a href="book/architecture//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> (static/dynamic) for <a href="book/architecture//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a>,
with the base class defined in <a href="book/architecture//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li><a href="book/architecture//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> (static/dynamic) for <strong><code>UFOW_VisibilityEntity_Interface</code></strong>,
with the base class defined in <a href="book/architecture//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
<h3 id="settings-1"><a class="header" href="#settings-1">Settings</a></h3>
<p>You'll find a few settings to configure the floors in your environment:</p>
<ul>
<li><code>FloorLocation</code>: defines the center of the floor.</li>
<li><code>FloorExtend</code>: defines the 2D extent of the floor.</li>
<li><code>FloorZExtend</code>: Represents the height of the fog. X represents the fog under the floor center,
and Y represents the fog above the floor center.</li>
<li><code>bOverrideChannelToClearAtStart</code>: Allows you to override the <code>FOW_Handler</code> setting of the fog state
at start.</li>
<li><code>bSnapFloorExtendToGrid</code>: Snaps the floor extent to the tile grid.</li>
</ul>
<h3 id="fog-update"><a class="header" href="#fog-update">Fog Update</a></h3>
<p>Every update is called by the handler, with four main updates:</p>
<ul>
<li><code>UpdateCollision</code>: done during <code>FOWUpdate_Begin</code> by the <a href="book/architecture//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a></li>
<li><code>UpdateFogState</code>: done during <code>FOWUpdate_End</code></li>
<li><code>UpdateVisibleEntityState</code>: done during <code>FOWUpdate_End</code> by the <a href="book/architecture//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></li>
<li><code>UpdateFogTextureSample</code> or <code>GetFogTextureSampleRegions</code>: done during <code>UpdateTexture</code>. This update
is special and cannot be changed; it's bound to <code>FWorldDelegates::OnWorldTickEnd</code> to ensure the
position of every game camera.</li>
</ul>
<p>The fog state is a heavy update which merges fog fragments of every Drawer. To achieve this, both the
fragment and the floor's <strong>bit array</strong> are sliced into tiles. They are instantiated and stored in
floors, all deriving from <strong><code>TFOW_Tile_Base</code></strong>. This facilitates the transformation
of Drawer data into a readable texture from the GPU. Each tile receives arrays of pointers linked to
Drawer fog fragments; if the array is empty, the tile is skipped and reset if updated during the
previous frame. The fog state is generated depending on the <a href="book/architecture//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a>
bound to the Drawer and supervised by the <a href="book/architecture//reference/classes/UFOW_LayerHandler.html"><strong><code>UFOW_LayerHandler</code></strong></a>, which provides the
update order. The LayerSettings are non-instantiated classes that convert all their <strong>Settings</strong> into
a flag. They are read by the Tiles and interpreted as the code writer intends. Every modification
regarding channel behavior or computation will require another Tile class.</p>
<h4 id="visual-representation-of-the-updates-pipeline-1"><a class="header" href="#visual-representation-of-the-updates-pipeline-1">Visual Representation of the Updates Pipeline</a></h4>
<h2 id="-1"><a class="header" href="#-1"><img src="book/architecture/../../assets/FloorUpdate.drawio.png" alt="Floor update pipeline" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>Here we will showcase step-by-step process of basic usage of the Layered Fog Of War - both for C++ and Blueprint implementation.
If you want to be in the same condition as the picture are, you can download my <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a> and use the map in the tutorial folder. <br />
If you need help to install the plugin, you watch this <a href="https://www.youtube.com/watch?v=BVz-TQKzHNY">Video</a></p>
<h1 id="pages-2"><a class="header" href="#pages-2">Pages</a></h1>
<ul>
<li><a href="book/Tutorials//book/Tutorials/First_set_up.html">First set up</a></li>
<li><a href="book/Tutorials//book/Tutorials/Layers.html">Layers</a></li>
<li><a href="book/Tutorials//book/Tutorials/Outdoor_Indoor.html">Outdoor Indoor</a></li>
<li><a href="book/Tutorials//book/Tutorials/Networking.html">Networking</a></li>
<li><a href="book/Tutorials//book/Tutorials/FogChannels.html">Fog Channels</a></li>
<li><a href="book/Tutorials//book/Tutorials/Floor_Verticality.html">Floor and verticality</a></li>
<li><a href="book/Tutorials//book/Tutorials/Minimap.html">Minimap</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-set-up"><a class="header" href="#first-set-up">First set up</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="book/Tutorials/First_set_up.html#installation">Installation</a></li>
<li><a href="book/Tutorials/First_set_up.html#set-up-the-fog">Set up the fog</a></li>
<li><a href="book/Tutorials/First_set_up.html#going-furter">Going furter</a></li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Download the Demo project <a href="https://github.com/gandoulf/LayeredFOW_Demo">Here</a> <br />
Install the plugin in the project, helping video <a href="https://www.youtube.com/watch?v=BVz-TQKzHNY">Here</a> <br /></p>
<h2 id="set-up-the-fog"><a class="header" href="#set-up-the-fog">Set up the fog</a></h2>
<p>This part will explain how to use the Fog Of War in the easiest and fastest possible way !<br /></p>
<p>Drag and drop a <code>BP_FOWHandler</code> from the quickly add button, keyboard is enable to allow you fast search</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/1_DragAndDropFOWHandler.png" alt="FOWHandler update pipeline" /></p>
<p>Once in your scene you will see two box:</p>
<ul>
<li>Yellow one, representing the Fog in 3D</li>
<li>Pink one, representing the fog align to the tile grid</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/2_DragAndDropFOWHandler_Result.png" alt="FOWHandler update pipeline" /></p>
<p>Add a <code>FOW_Drawer_FOV</code> to the BP_TutorialCharacter</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/3_AddDrawerToTheCharacter.png" alt="FOWHandler update pipeline" /></p>
<p>Hit the play button for the first preview of the FOW !!</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/4_PlayGameWithFog.png" alt="FOWHandler update pipeline" /></p>
<p>Now that the FOW is running were gonna add collision to limite the sight of character.
Add <code>FOW_CollisionEntity_BoxComponent</code> to the four wall in the map</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/5_AddCollisionToWall.png" alt="FOWHandler update pipeline" /></p>
<p>You will have to reset the scale of the box collision to 1 to make them fit to the asset</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/6_ResetCollisionScaleTo1.png" alt="FOWHandler update pipeline" /></p>
<p>Box are cool but might be a bit limited, let's see how to do otherwise
Add <code>FOW_CollisionEntity_CustomComponent</code> to the cylinder in the map.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/7_AddCustomCollisionToWall.png" alt="FOWHandler update pipeline" /></p>
<p>In the details panel, select the component and Add 8 vertices to the <code>CustomGeometryVertices</code> array.
Position the vertices in top view such as they fit to the object, grid snapping might by annoying.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/8_AddVerticesToYourCustomCollider.png" alt="FOWHandler update pipeline" /></p>
<p>You can hit the play button again and see that the cylinder collision is projected!</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/8.1_CollistionAreCasted.png" alt="FOWHandler update pipeline" /></p>
<h2 id="going-furter"><a class="header" href="#going-furter">Going furter</a></h2>
<p>If you are setting up the FOW for custom map you can change the size and position of the floor
in BP_FOWHandler in the details panel. You can also add other floors to extend your game however
you want. check the <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/Floor_Verticality.html">Floor page</a> for more information to set up the fog in your level.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/9_AdapteTheFOWToYourGame.png" alt="FOWHandler update pipeline" /></p>
<p>The base radius of the <code>FOW_Drawer_FOV</code> component might be too small, don't hesitate to change it
in the actor holding the component. Modify the <code>DrawerRadius</code> value to provide a larger sight to your units.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/10_ChangeRadiusSize.png" alt="FOWHandler update pipeline" /></p>
<p>You can change the fog precision of the FOW in the <code>BP_FOW_Handler</code> by going in the details panel
and by changing the <code>PixelSize</code> value. By default the fog pixel is set to 25 centimeters</p>
<h2 id="-2"><a class="header" href="#-2"><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/11_Chance_the_fog_precision.png" alt="FOWHandler update pipeline" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-of-war-entities"><a class="header" href="#fog-of-war-entities">Fog of war Entities</a></h1>
<p>Entities system are used by default as a solution to memory fragmentation causing heavy update.
It has been designed with this fact in mind but also to let anything be part of the FOW. Entities
are collected and stored under containers to keep requiered data for the system update. They
inherite from <code>UFOW_Entity_Interface</code> which is a <code>UInterface</code>. I'm using the unreal interface
implementation to allow callable functions for Blueprint only users. The downside of it is that
entities has to be at least a <code>UObject</code>.<br /></p>
<p>The Entities can be implemented only in the C++ side, However many predifined <code>Actor</code> and
<code>ActorComponent</code> are providen with already implemented interface. You will find in
those derived class two function allowing you to <code>EnableEntity()</code> or <code>DisableEntity()</code> anywhere
at anytime. There is no other API, they are self suffisante and their update are managed by
the containers.</p>
<h1 id="pages-3"><a class="header" href="#pages-3">Pages</a></h1>
<ul>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Visibility_Entity.html">Visibility entity</a></li>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Drawing_Entity.html">Drawing entity</a></li>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Collision_Entity.html">Collision entity</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-entity"><a class="header" href="#visibility-entity">Visibility entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#visibility-entity-component">Visibility Entity Component</a></li>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#visibility-entity-cpp-implementation">Visibility Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Entities</code> map providen in the
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="visibility-entity-component"><a class="header" href="#visibility-entity-component">Visibility Entity Component</a></h1>
<p>This component implement <code>IFOW_VisibilityEntity_Interface</code> and allow your game to change the
visibility of your actors depending of the fog state.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Visibility/0_MergePictureVisibilityComponent2.png" alt="VisibleEntity" /></p>
<p>To use it add a <code>FOW_VisibilityEntity_Component</code> to an instanced actor or to your existing <code>Blueprint</code>.
the component will by default hide the actor if not in sight.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/1_AddVisibleEntityToActor.png" alt="VisibleEntity" /></p>
<p>To go a bit further, if you whant to apply custom code when the visibility state change, you can implement
the <code>OnVisibilityChanged</code> event from the component in your <code>Blueprint</code>.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/2_CustomVisibilityUpdate.png" alt="VisibleEntity" /></p>
<p>By default the FOW state is return as a uint8, it doesn't means a lot for you but it is a mask representing
the 8 chanels. You can transform it to a more readable enum by calling <code>GetFOWStateFromBits</code>. Now just
switch on the returned enum to apply your custom code. For the example I'm juste drawing debug sphere.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/3_DrawDebugSphereOnVisibilityChanged.png" alt="VisibleEntity" /></p>
<p>And here you go, green sphere appear when the actor is reveald, and a red one appear when the player
loose sight on it.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/4_DrawDebugSphereForVisibility.png" alt="VisibleEntity" /></p>
<p>If the popping render displease you, you can turn it off by unchecking <code>DisableRenderOutSight</code>. if you do
so nothing will happen anymore and you will have to do the magic by yourself, material translusency transition
or an explosion maybe ? :)</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/5_DisablePremadeVisibilityEffect.png" alt="VisibleEntity" /></p>
<h1 id="visibility-entity-cpp-implementation"><a class="header" href="#visibility-entity-cpp-implementation">Visibility Entity cpp implementation</a></h1>
<p>You can make your own visibility component or directly turn your <code>UObject</code> to entities and give them
the possibility to react to the Fog state. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-entity"><a class="header" href="#drawing-entity">Drawing entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#drawing-entity-components">Drawing Entity Components</a></li>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#drawing-entity-cpp-implementation">Drawing Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Entities</code> map providen in the
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="drawing-entity-components"><a class="header" href="#drawing-entity-components">Drawing Entity Components</a></h1>
<p>There is Multiple <code>DrawingEntity</code> component implementing the <code>IFOW_DrawingEntity_Interface</code>, three different
kind of them exist for now.</p>
<ul>
<li><code>Geometry drawers</code>, they will pierce fog by rasterzing a given geometry. used by <code>FOW_DrawingEntity_BoxComponent</code></li>
<li><code>Circle drawers</code>, they will pierce fog with specific rasterizer only able to trace circle. used by <code>FOW_DrawingEntity_CircleComponent</code></li>
<li><code>FOV drawers</code>, they will pierce fog by collecting the colliders to create shadow geometries. used by <code>FOW_DrawingEntity_FOVComponent</code></li>
</ul>
<p>All <code>DrawingEntity</code> work the same, they hold data and the given <code>UFOW_LayerSetting</code> will define
how this data will be used to pierce the Fog.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Drawing/0_DefaultDrawingSetupMerged.png" alt="DrawingEntity" /></p>
<p>To use them add a <code>FOW_DrawingEntity_CircleComponent</code> / <code>FOW_DrawingEntity_BoxComponent</code> / <code>FOW_DrawingEntity_FOVComponent</code>
to an instanced actor or to your existing <code>Blueprint</code>. the Default settings of those component are made to pierce the fog.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Drawing/1_AddingDrawingCircleToActor.png" alt="DrawingEntity" /></p>
<p>All drawers will have barelly the same settings.</p>
<ul>
<li><code>IsEnableAtStart</code>, define if the entity start drawing from the BeginPlay or if it will be enable later by calling <code>EnableEntity()</code></li>
<li><code>TeamIndexAtStart</code>, define for which team will the entity be drawing for. The team can be changed at runtime by calling <code>SetEntityTeam()</code></li>
<li><code>Static/DynamicLayerSettingClass</code>, define how the drawer will bring modification to the fog. Those can't be changed at runtime.</li>
<li>The advanced section is only necessary for multiple <code>FOW_Floor</code> games. There behavior will be explain later.</li>
</ul>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Drawing/2_DrawingEnitySettingsOverView.png" alt="DrawingEntity" /></p>
<h1 id="drawing-entity-cpp-implementation"><a class="header" href="#drawing-entity-cpp-implementation">Drawing Entity cpp implementation</a></h1>
<p>You can make your own drawing component or directly turn your <code>UObject</code> to entities and give them
the possibility to alter the state of the fog. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collision-entity"><a class="header" href="#collision-entity">Collision entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Collision_Entity.html#collision-yentity-component">Collision Entity Component</a></li>
<li><a href="book/Tutorials/entities/Collision_Entity.html#collision-entity-cpp-implementation">Collision Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Entities</code> map providen in the
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="collision-entity-component"><a class="header" href="#collision-entity-component">Collision Entity Component</a></h1>
<p>There is Multiple <code>CollisionEntity</code> component implementing the <code>IFOW_CollisionEntity_Interface</code>.
All collision work the same, they store a geometry that will be given to a <code>UFOW_CollisionHandler</code>.
The handler will then profide query class to collect colliders informations. <br />
The geometry can be convex and concave, it's only requiered to correctly sort the vertices.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Collision/0_SetupCollisionComponentMerged.png" alt="CollisionEntity" /></p>
<p>To use them add a <code>FOW_CollisionEntity_BoxComponent</code> or <code>FOW_CollisionEntity_CustomComponent</code>
to an instanced actor or to your existing <code>Blueprint</code>. I use for the example the box component,
if you wanna use the custom component to generate custom collision you will have to provide vertices.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Collision/2_AddBoxCollisionComponent.png" alt="CollisionEntity" /></p>
<p>Select the <code>FOW_CollisionEntity_BoxComponent</code> and reset the scale to 1.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Collision/3_ResetCollisionBoxScaleToOne.png" alt="CollisionEntity" /></p>
<p>If you take a look to the collision entity <code>settings</code> you will see that <code>Static/DynamicLayerSettingClass</code> are requiered.
It's the case because colliders are also <code>DrawingEntities</code>. If <code>ShouldBeDrawn</code> is check and if the
<code>UFOW_LayerHandler</code> is correctly set colliders will provide their geometries to a <code>UFOW_Drawer_Shared</code>.
It's present as an optimisation for maps with a lots of <code>FOVDrawers</code> or <code>FOVEntities</code>, it'll allow the
FOW to rasterize the colliders geometry into a static layer which will reduce the triangle count per geometry
for dynamic drawing.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Collision/4_CollisionEntityGeneralParameters.png" alt="CollisionEntity" /></p>
<p>Hit the play button and see the shape of the collision blocking the sight of the drawer.</p>
<h1 id="collision-entity-cpp-implementation"><a class="header" href="#collision-entity-cpp-implementation">Collision Entity cpp implementation</a></h1>
<p>You can make your own collision component or directly turn your <code>UObject</code> to entities and give them
the possibility to block the sight of drawers. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<ul>
<li><a href="book/Tutorials/Layers.html#basic">Basic</a></li>
<li><a href="book/Tutorials/Layers.html#advanced">Advanced</a></li>
</ul>
<h2 id="basic"><a class="header" href="#basic">Basic</a></h2>
<p>This part will show explain you how <code>LayerSettings</code> works and how you can create new ones for your games.
First you have to know that they are dissociated to provide different information to the FOW but also to
profide a computation order during the fog fragment merging. It can be compered to a rendering pipeline.
To register a new layer you will have to create a <code>LayerHandler</code>. <br /></p>
<p>Let's try to change the behavior of the drawer on you character. We want him to reveal only the black fog
but not to give him sight. <br /></p>
<p>Create a new BP_MyLayerHandler derived from <code>FOW_LayerHandler</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/1_CreateLayerHandler_BP.png" alt="FOWHandler update pipeline" /></p>
<p>Create a new BP_MyFOVLayer derived from <code>FOW_LayerSettings</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/2_CreateLayerSetting_BP.png" alt="FOWHandler update pipeline" /></p>
<p>Open your layer handler and add the new layer you've juste created. Add id just under the <code>FOW_FOVLayer</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/3_OpenAndAddNewLayerSetting.png" alt="FOWHandler update pipeline" /></p>
<p>Now we need to tell the <code>FOW_Handler</code> that we are using a new layer pipeline. Select the <code>BP_FOW_Handler</code>
and change in the detail panel, in the class section, the value of the <code>LayerHandlerClass</code> to the one you've
created</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/4_ChangeTheLayerHandler.png" alt="FOWHandler update pipeline" /></p>
<p>Open the blueprint holding the <code>FOVDrawer</code>, select it and go to the detail panel. scroll to the <code>LayerSettingClass</code>
and replace it with the one you've created</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/5_ReplaceTheLayerSettingClass.png" alt="FOWHandler update pipeline" /></p>
<p>Now that every thing is correctly set, we can change the behavior of the <code>LayerSetting</code>. Open the blueprint,
turn the <code>InverseBits</code> to true (I'm gonna ask you to trust me on that, every FOV Layers will need this to be true)
and set the <code>RevealSight</code> to false and <code>RevealFog</code> to true. Doing so will prevent the player to have sight on
<code>VisibilityEntity</code> however the layout will be revealed</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/6_ChangeLayerSettings.png" alt="FOWHandler update pipeline" /></p>
<p>Enjoy your new layer setting ! Check out the <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/Visibility_entity.html">Visibility Entity page</a> to really understand the difference
between <code>RevealSight</code> and <code>RevealFog</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/7_PiersingOnlySightFog.png" alt="FOWHandler update pipeline" /></p>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<p>Let's talk about other settings and let's try to implement different <code>Drawers</code> and <code>Entity</code> to your game !</p>
<h2 id="to-continue-"><a class="header" href="#to-continue-">To continue ...</a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outdoor-indoor"><a class="header" href="#outdoor-indoor">Outdoor Indoor</a></h1>
<p>Depending of the game you might need to dessociate the Indoor from the outdoor, such as
only the indoors are undiscoverred. From my experience it's easier to clear the whole FOW
and add fog to the indoor area. The next picture represent the result we will have step
by step:</p>
<ul>
<li>
<ol>
<li>FOW display without any setup</li>
</ol>
</li>
<li>
<ol start="2">
<li>FOW display when revealing the whole fog</li>
</ol>
</li>
<li>
<ol start="3">
<li>FOW display after adding the indoor fog</li>
</ol>
</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/0_Fog_Indoor_Outdoor_Example.png" alt="Outdoor Indoor" /></p>
<p>First get the <code>BP_FOW_Handler</code> and go to the detail panel. Find the <code>ChannelToClearAtStart</code>
and check the <code>chan2</code> box. It while set the default value of the second channel of every floor
to 1 to clear the black fog.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/1_ClearFogAtStart.png" alt="Outdoor Indoor" /></p>
<p>Now we're gonna draw back the fog in the 2 indoor area. There is two type of drawing entity
provided to do so:</p>
<ul>
<li><code>FOW_DrawingEntity_Box</code>, drawing fog in a box</li>
<li><code>FOW_DrawingEntity_Custom</code>, drawing fog in the providen custom geometry</li>
</ul>
<p>Drag and drop both of the drawing entity to your scene and let's set up the indoor fog.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/2_AddDrawingEntities.png" alt="Outdoor Indoor" /></p>
<p>First move the <code>FOW_DrawingEntity_Box</code> to the tiny room and scale it to be as big as the room</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/3_SetUpBoxDrawing.png" alt="Outdoor Indoor" /></p>
<p>Second move the <code>FOW_DrawingEntity_Custom</code> to the bigger room and add 8 vertices int the
<code>CustomGeometryVertices</code> in the details panel. Select the top view for the viewport and
place the vertices arround the room.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/4_SetUpCustomDrawing.png" alt="Outdoor Indoor" /></p>
<p>Finally, By default Drawers will remove fog, however this time we need to add fog and only
when the game start. A specific <code>LayerSettings</code> is providden to do so. In both drawing
entities, in the details panel, replace the static and dynamic layer setting class by
<code>FOW_FloorStartUpLayer</code>.</p>
<h2 id="-3"><a class="header" href="#-3"><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/5_ChangeDrawersLayerSettings.png" alt="Outdoor Indoor" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-1"><a class="header" href="#networking-1">Networking</a></h1>
<ul>
<li><a href="book/Tutorials/Networking.html#default-replication-setup">Default replication setup</a></li>
<li><a href="book/Tutorials/Networking.html#manage-player-team">Manage player team</a></li>
<li><a href="book/Tutorials/Networking.html#infinit-team">Infinit team</a></li>
</ul>
<blockquote>
<p><strong>/!\ This tutorial is made to show how the FOW works with networks, replication knowledge
won't be providen. Networking <code>GameMode</code>, <code>GameState</code>, <code>Controller</code> and <code>Character</code> are providen.
You have obsolutly the right to read, copy and use any code you find :) <br /></strong></p>
</blockquote>
<p>This tutorial has been realised in the Tutorial/Maps/TutorialMap_Networking map providen in the
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="default-replication-setup"><a class="header" href="#default-replication-setup">Default replication setup</a></h1>
<p>The <code>TutorialMap_Networking</code> has been set up to show you how replication and teams works. To do
so a <code>BP_TutoralNetworking_GameMode</code> has been set up with a <code>BP_TutorialNetworking_PlayerController</code>
to spawn a <code>BP_TutorialNetworking_Character</code> at a <code>PlayerStart</code>location depending of the Client team.<br />
To visualize the replication the server will clear the fog of an another spawn point for each team
before the client connection. <br /></p>
<ul>
<li>The circle represent the spawn point</li>
<li>The square is the associated revealed spawn point</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/0_NetworkingMapSetup.png" alt="Networking" /></p>
<p>There is a little trouble with Unreal and singleton instance when they are stored in a static variable.
If you hit the play button with multiple player in the editor, multiple world will be created but inside the
same application, wich means static variable are shared and overriden. To prevent this the FOW is designed to
look for an implementation of <code>FOW_GetHandlerInstance_Interface</code> in the <code>GameState</code>.<br /></p>
<p>Let's setup the game state. Create a new <code>My_FOWNetworking_GameState</code> derived from <code>GameStateBase</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/1_CreateNewGameState.png" alt="Networking" /></p>
<p>Open it and go into <code>ClassSettings</code> to add the <code>FOW_GetHandlerInstance_Interface</code> in the <code>ImplementedInterfaces</code>
array.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/2_AddGetHandlerInterface.png" alt="Networking" /></p>
<p>Now you have to provide the code to the <code>Find_Level_FOWHandler</code>.</p>
<ul>
<li>Add a <code>FOW_Handler</code> variable</li>
<li>Get the variable and convert it to a <code>Validate</code> get, if valide return the variable.</li>
<li>Else find all actor of class <code>FOW_Handler</code></li>
<li>If at least one is retruned, set your <code>FOW_Handler</code> variable to the first element of the array</li>
<li>Return the variable</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/3_AddCodeToTheInterfaceMethod.png" alt="Networking" /></p>
<p>Now open the <code>BP_TutoralNetworking_GameMode</code> and replace the <code>GameState</code> with yours</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/4_ChangeDefaultGameState.png" alt="Networking" /></p>
<p>All set up !</p>
<blockquote>
<p><strong>Note that if you don't simulate the network in the editor this whole setting
isn't needed, as long as every game instance are separated process you don't need to implemente
the interface.</strong></p>
</blockquote>
<p>Now let's see how the FOW works with replication. First create a new <code>BP_MyNetworkSettings</code>
derived from <code>UFOW_NetworkSettings</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/5_MakeNetworkSettingClass.png" alt="Networking" /></p>
<p>Open it and change the <code>NetworkGameMaxTeamNbr</code> value from the <code>Server</code> to 4. It means
that the <code>FOW_Handler</code> will be ready to handle 4 different teams drawing fog seperatly.
(for few reason 4 team with two channels enable is the maximum). Also if you pay attention
the client is set to only one team, which mean that only the client team fog will be updated.<br />
Under those settings you will find check box to allow or not replication and which channel are replicated.
The first channel isn't needed since it represent the fog of what drawers currently see.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/6_SetUpTheLayerSettings.png" alt="Networking" /></p>
<p>Select the <code>BP_FOW_Handler</code>, get into the details panel and change the <code>NetworkSettingsClass</code> to
your <code>BP_MyNetworkSettings</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/6.1_ChangeFOWHandlerNetworkSettings.png" alt="Networking" /></p>
<p>Before hitting the play button change the <code>PlaySettings</code>. Change the number of players to 4
and change <code>NetMode</code> to <code>PlayAsListenServer</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/7_ChangeTheEditorPlaySettings.png" alt="Networking" /></p>
<p>Now you can hit the play button and see the 4 windows open which your character connecting one by one.
If you do not understand what the fog replication change, go back to your <code>BP_MyNetworkSettings</code> and
uncheck <code>bIsFogStateReplicated</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/8_NetworkingResult.png" alt="Networking" /></p>
<h1 id="manage-player-team"><a class="header" href="#manage-player-team">Manage player team</a></h1>
<p>The previous part was about to setup the network over the FOW. However you couldn't do anything
regarding which client are associated to which team because of the default system distributing the
players to each team.</p>
<p>Let's see how to do that. Create a <code>BP_MyFogStateReplication_Server</code> derived from <code>AFOW_FogStateReplication_Server</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/9_CreateNewFogStateReplication.png" alt="Networking" /></p>
<p>Open it and override the <code>GetClientTeamIndex</code> function.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/10_OpenAndOverrideGetClientTeamIndex.png" alt="Networking" /></p>
<p>Open it. This is where you can manage the client team association. the <code>PlayerController</code> is providen,
You should be able to fetch necessary data from your game with it.
For the example let's just do this:</p>
<ul>
<li>Get the <code>NetworkMaxTeamNbr</code> and substract 1 from it</li>
<li>Pin the result to a <code>Radom Integer in Range</code></li>
<li>Pin the result to the return;</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/11_AddCustomCodeToGetClientTeamIndex.png" alt="Networking" /></p>
<p>Now that the server is set up, open your <code>BP_MyNetworkSettings</code> and replace the <code>FogStateReplicationClass</code>
by your <code>BP_MyFogStateReplication_Server</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/12_ChangeFogStateReplicationClassServer.png" alt="Networking" /></p>
<p>Hit the Play button and see the player beeing associated to a random team !</p>
<h1 id="infinit-team"><a class="header" href="#infinit-team">Infinit team</a></h1>
<p>In case you want more than 4 team with two channel you can just uncheck <code>bIsFogStateReplicated</code>,
Set the <code>NetworkGameMaxTeamNbr</code> for both client and server to 1 and provide any team index you
want in the <code>GetClientTeamIndex</code> override.</p>
<blockquote>
<p><strong>This replicated team number issue will be taken care of, it might not allow infinit number but more
than 4 for sure</strong></p>
</blockquote>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/13_InfinitTeamForNonReplicatedFog.png" alt="Networking" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-channels"><a class="header" href="#fog-channels">Fog Channels</a></h1>
<ul>
<li><a href="book/Tutorials/FogChannels.html#basic">Basic</a></li>
<li><a href="book/Tutorials/FogChannels.html#advanced">Advanced</a></li>
</ul>
<p>This tutorial is based on solo game, every things related to channels need to be taken with cautious
when applied to teams. However everythings works the same, teams will only limite the number of
availlable channels.</p>
<h2 id="basic-1"><a class="header" href="#basic-1">Basic</a></h2>
<p>The FOW has up to 8 configurable channels that you can use.(Be carefull with game having teams)
The channels may or may not be all used, for the default setup of the FOW only two channels are
used:</p>
<ul>
<li>First channel define what the player currently see.</li>
<li>Second channel define what the player has seen;</li>
</ul>
<p>This set up is mostly used for narative game or RTS with procedural maps but you might want to make
a game more MOBA oriented with everything reveald to the players, which means that you only need the
first channel to represent the sight of the player.</p>
<p>Let's change the FOW to have only one channel. First select the <code>BP_FOW_Handler</code> get to details panel
and click on the <code>FOWFloorTilesClass</code> input field and select <code>TFOW_T128b_1Chan_Pck_Class</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/1_ChangeTileFormat.png" alt="Fog channels" /></p>
<p>Still in the <code>BP_FOW_Handler</code> details panel, find the <code>FOWShaderClass</code> variable and open the providen
material, it should be <code>MPP_FOW_Floors</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/2_OpenTheFOWMaterial.png" alt="Fog channels" /></p>
<p>Find the material function with 8 channel output pin and unlink the <code>chan2</code> from the linked <code>lerp</code> node.
The <code>Alpha</code> value should be set to 1.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/3_UnpinBlackChannelSetAlphaTo1.png" alt="Fog channels" /></p>
<p>You should be done, press play and check that the FOW correctly display only one channel.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/4_GameWithOnlyOneChannelComputed.png" alt="Fog channels" /></p>
<p>You might have figured out that only doing the material part would have do the tricks and yes it would
have. But you would have let the FOW doing all the computation in CPU and GPU of the <code>Chan2</code>.</p>
<h2 id="advanced-1"><a class="header" href="#advanced-1">Advanced</a></h2>
<p>In the advanced part I'll show you how to implement and use more than 2 channels by creating new <code>FOW_Tile_Class</code>
and <code>FOW_LayerSetting</code>. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-and-verticality"><a class="header" href="#floor-and-verticality">Floor and verticality</a></h1>
<h2 id="hello"><a class="header" href="#hello">Hello</a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimap"><a class="header" href="#minimap">Minimap</a></h1>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//reference/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-afow_handler"><a class="header" href="#class-afow_handler"><strong>Class: <code>AFOW_Handler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API AFOW_Handler
    : public AActor;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The Fog Of War Handler is the base class of the plugin, it's a sigleton and you cannot have many instance of it even when doing networked game with replication<br />
The Fog Of War is highly parametrable and let the developers override almost everything. You might want to get ride of some functionality or maybe to write a more optimized code<br />
The handler hasn't any main logic, it's purpose is to:</p>
<ul>
<li>Have general settings</li>
<li>Initialise FOW Object</li>
<li>Run the update</li>
<li>Contain FOW element instancies</li>
</ul>
<p>You have the possibility to change the core module of the FOW by changing the default class used int the settings</p>
<blockquote>
<ul>
<li>If you want a custom FOWHandler be sure to override FindLevelFOWHandler, you can use <strong><code>AFOW_Handler_Default</code></strong> as example</li>
<li>Go to the FOWFloors settings and display the parametters to shape the floor to your needs</li>
</ul>
</blockquote>
<p>If you need to modify the initialization to fit your pipeline, override those function called by the BeginPlay</p>
<ul>
<li>void InitNetwork();</li>
<li>void InitTeams();</li>
<li>void InitFOWFloors();</li>
<li>void InitFOWFloorsTiles();</li>
<li>void InitGameShader();</li>
<li>void InitFOWUpdate();</li>
<li>void FinalizeInitialization();
Please be really carefull to not finalize the initialization if the floor or game shader init havn't be called</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_collisionentity_interface"><a class="header" href="#class-ifow_collisionentity_interface"><strong>Class: <code>IFOW_CollisionEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_CollisionEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Collision entities are the sight blocker to prevent fog discovering between rooms.<br />
By design any child implementing this class should also implement <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> to enable optimisation</p>
<blockquote>
<ul>
<li>Depending of the situation you can have issues because of collision drawing optimisation, Override ShouldDrawColliders and return false to disable it</li>
<li>You can disable the whole collision drawing optimisation by disabling DrawFOWCollider in <a href="reference/classes//reference/classes/UFOW_LayerHandler.html"><strong><code>UFOW_LayerHandler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_drawingentity_interface"><a class="header" href="#class-ifow_drawingentity_interface"><strong>Class: <code>IFOW_DrawingEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_DrawingEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Drawing entity used to modify the state of the fog depending of the given <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Override GetEntityLayerSetting to give the correct layer setting</li>
<li>Call SetEntityTeam to change the entity team in case of multiplayer game</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_entity_interface"><a class="header" href="#class-ifow_entity_interface"><strong>Class: <code>IFOW_Entity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Base class for every entity interface, <a href="reference/classes//reference/classes/IFOW_GeometryEntity_Interface.html"><strong><code>IFOW_GeometryEntity_Interface</code></strong></a> is an exception subject to a retake</p>
<blockquote>
<ul>
<li><a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_VisibilityEntity_Interface.html"><strong><code>IFOW_VisibilityEntity_Interface</code></strong></a></li>
</ul>
</blockquote>
<p>Entities are by default automatically updated by the system if (IsStatic == false &amp;&amp; FloorVolatile)</p>
<blockquote>
<ul>
<li>FloorVolatile express the posibility to move from a floor to another</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : every multiple inheritance have specifique overriding rule regarding methodes finishing by _M.<br />
You can use <strong><code>AFOW_CustomCollision</code></strong> as examble for your custom entity implementation</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_geometryentity_interface"><a class="header" href="#class-ifow_geometryentity_interface"><strong>Class: <code>IFOW_GeometryEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_GeometryEntity_Interface;
</code></pre>
<hr />
<p>Geometry entity is a data container used by entities to modify fog or create collision.</p>
<blockquote>
<ul>
<li>Geometries are by default automatically updated by the system if (static == false || modular)</li>
<li>Override UpdateEntityGeometry to make your modification</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : The geometry system should be retaken to make the geometry aligned in memory</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_visibilityentity_interface"><a class="header" href="#class-ifow_visibilityentity_interface"><strong>Class: <code>IFOW_VisibilityEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_VisibilityEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Visibility entity used to automatically update the ingame visibility of the UObject inherited from it</p>
<blockquote>
<ul>
<li>VisibilityEntity are by default automatically updated</li>
<li>Override OnVisibilityStateChanged to update the visibility state</li>
<li>You can find a default example by looking at <strong><code>UFOW_VisibilityComponent</code></strong>.</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_collisionhandler"><a class="header" href="#class-ufow_collisionhandler"><strong>Class: <code>UFOW_CollisionHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_CollisionHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Collision handler is used to accelerate the querying of collider to generate sight mask<br />
Every handler is associated to its <strong><code>UFOW_CollisionHandlerQuery</code></strong> class</p>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawercomponent"><a class="header" href="#class-ufow_drawercomponent"><strong>Class: <code>UFOW_DrawerComponent</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_DrawerComponent
    : public UActorComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The drawer component compute fog modification, however it doesn't apply it.<br />
They are small chunk of fog aligned to the world grid, they can be seen as canvas.<br />
Their update are the slowest because of the collision querying and the geometry rasterization.<br />
By default they are mean to be added to each actor modifying the fog however the memory allocation and merging can become very time consuming.<br />
If your game needs higher performance take a look at <a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a> which will request the creation of a <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a> to the system.<br /></p>
<p>It is possible to :</p>
<blockquote>
<ul>
<li>Create custom drawer by inheriting from this class and by overriding GenerateDrawerGeometry to inject your custom geometry</li>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
<li>Change the collision querying by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onlyregistervalideteam"><a class="header" href="#onlyregistervalideteam"><strong><code>OnlyRegisterValideTeam</code></strong></a></h1>
<pre><code class="language-cpp">protected:
bool OnlyRegisterValideTeam;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadWrite</strong></li>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Settings</em></li>
</ul>
<hr />
<p>To allow flexibility allow every drawer to be registered in the FOWHandler, it might slighly increase UpdateDrawerLayer parsing time
But it will remove every network synchronisation issues if the client team change</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawer_shared"><a class="header" href="#class-ufow_drawer_shared"><strong>Class: <code>UFOW_Drawer_Shared</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Drawer_Shared
    : public UFOW_DrawerComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
<li><strong>BlueprintType</strong></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Drawer designed to hold <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> and batch their update under one process</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entitycontainer"><a class="header" href="#class-ufow_entitycontainer"><strong>Class: <code>UFOW_EntityContainer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityContainer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>Dynamic entity and geometry container. Called by the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a> to update their status</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entityvisibilityhandler"><a class="header" href="#class-ufow_entityvisibilityhandler"><strong>Class: <code>UFOW_EntityVisibilityHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityVisibilityHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Update the visibility of every registered object implementing IFOW_VisibilityEntity_Interface.<br />
The class is instantied twice in every <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> for Static and dynamic entity.<br />
Each entity will query the FOW state at location or for an AABB on the owner FOW_Floor.<br /></p>
<blockquote>
<ul>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Override OnVisibilityStateChanged methode in IFOW_VisibilityEntity_Interface to apply custom modification</li>
<li>Bind your object to OnVisibilityChanged if you are using FOW_VisibilityComponent</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="visibleentities"><a class="header" href="#visibleentities"><strong><code>VisibleEntities</code></strong></a></h1>
<pre><code class="language-cpp">protected:
TArray&lt;TScriptInterface&lt;IFOW_VisibilityEntity_Interface&gt;&gt; VisibleEntities;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadOnly</strong></li>
<li><strong>Category</strong> = <em>Internal</em></li>
</ul>
<hr />
<p>Hold the visible entity</p>
</li>
</ul>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="prepareforworlddestruction"><a class="header" href="#prepareforworlddestruction"><strong><code>PrepareForWorldDestruction</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void PrepareForWorldDestruction();
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Call before the world destruction to prevent all Remove or Add operation</p>
  </details>
</li>
<li>
<h1 id="updatevisibilitystate"><a class="header" href="#updatevisibilitystate"><strong><code>UpdateVisibilityState</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void UpdateVisibilityState(
    const UFOW_Floor* Floor,
    uint8 FOWGlobalSettingFlags
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Update the visibility state of all registered entity</p>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="floor-1"><a class="header" href="#floor-1"><strong><code>Floor</code></strong></a></h2>
<pre><code class="language-cpp">const UFOW_Floor* Floor
</code></pre>
</li>
<li>
<h2 id="fowglobalsettingflags"><a class="header" href="#fowglobalsettingflags"><strong><code>FOWGlobalSettingFlags</code></strong></a></h2>
<pre><code class="language-cpp">uint8 FOWGlobalSettingFlags
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_floor"><a class="header" href="#class-ufow_floor"><strong>Class: <code>UFOW_Floor</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Floor
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>The floor is an area where a bit mask texture is generated to create fog.<br />
Each floor bit mask will be sliced and attributed to a <strong><code>TFOW_Tile_Base</code></strong>.<br />
It's responsible of the fog state update by querying the fog chunk of every drawer.<br />
Every levels can have many instances of floor to allow verticallity for your game.<br />
Each floor has a collision handler static and dynamic and is responsible for the collision update.<br /></p>
<blockquote>
<ul>
<li>Change the collision system by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<p>Warning : supperposed floor will work correctly only if you change the PP material in <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layerhandler"><a class="header" href="#class-ufow_layerhandler"><strong>Class: <code>UFOW_LayerHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The layer handler allow you to change the computation order of the different <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Layer will modify the fog state in the given order, which means that a modification can be overriden by an other layer</li>
<li>Enable or disable the collision drawing optimisation by changing DrawFOWCollider</li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layersetting"><a class="header" href="#class-ufow_layersetting"><strong>Class: <code>UFOW_LayerSetting</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerSetting
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Layer setting is made to configure how an entity or a drawing component will modify the fog</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_rasterizer"><a class="header" href="#class-ufow_rasterizer"><strong>Class: <code>UFOW_Rasterizer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Rasterizer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The rasterizer convert the geometries to a bit mask texture representing the state of the FOW.<br />
The reasterizer is never instantied, the default object is always used witch means that you cannot use variable in the class</p>
<blockquote>
<ul>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_texturesample"><a class="header" href="#class-ufow_texturesample"><strong>Class: <code>UFOW_TextureSample</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_TextureSample
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The texture sample collect sample of FOW from the <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> to write it inside a texture that will be bind to materials</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_tile_class"><a class="header" href="#class-ufow_tile_class"><strong>Class: <code>UFOW_Tile_Class</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Tile_Class
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
</ul>
<hr />
<p><strong><code>TFOW_Tile_Base</code></strong> aren't a UCLASS to prevent saturation of GC, thus they are all wrapped by a FOW_Tile_Class and allocated the old way.<br />
Tiles are used to compute fog result of the <a href="reference/classes//reference/classes/UFOW_DrawerComponent.html"><strong><code>UFOW_DrawerComponent</code></strong></a> and merge it depending of the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a> under a bit array that will feed the <a href="reference/classes//reference/classes/UFOW_TextureSample.html"><strong><code>UFOW_TextureSample</code></strong></a> sent to the GPU.<br />
You can simply create your own tile update by overriding this class and by using the templated class <strong><code>TFOW_Tile</code></strong>.
you will have to create 3 templated classes to finish your fully custom tiles :</p>
<ul>
<li>Update</li>
<li>Compute</li>
<li>Merge</li>
</ul>
<blockquote>
<ul>
<li>Override GetTileBitsFormat to correctly set the tile pixel number for the FOW</li>
<li>Override GetTileChannelNbr to correctly set the channels number per tiles</li>
<li>Override GetTilePackagingFormat to correctly set the packaging format use by the FOW</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<p>Warning : I highly advise to use the EnumFOWTilePackagingFormat::PACKED format for optimisation reason</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_visibilitye_component"><a class="header" href="#class-ufow_visibilitye_component"><strong>Class: <code>UFOW_VisibilityE_Component</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_VisibilityE_Component
    : public UActorComponent
    , public IFOW_VisibilityEntity_Interface;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>ClassGroup</strong> = <em>Entity</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
<li><strong>DisplayName</strong> = <em>FOW_VisibilityEntityComponent</em></li>
</ul>
<hr />
<p>Can be added to any actor which need to be hidden when the player hasn't sight on it</p>
<blockquote>
<ul>
<li>Enable IsEntityFloorVolatile to use the default visibility update</li>
<li>Bind yourself to OnVisibilityChanged to customise the visibility update</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<hr />
<h1 id="properties-2"><a class="header" href="#properties-2"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onvisibilitychanged"><a class="header" href="#onvisibilitychanged"><strong><code>OnVisibilityChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
FOnVisibilityChangedd OnVisibilityChanged;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-15"><a class="header" href="#specifiers-15">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintAssignable</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>FOW</em></li>
</ul>
<hr />
<p>Called every time the Visibility state has changed</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
