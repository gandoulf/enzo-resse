<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Layered Fog Of War documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="documentation.html">Documentation</a></li><li class="chapter-item expanded "><a href="book/index.html">Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/getting_started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="book/architecture/index.html">Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/architecture/Handler.html">Handler</a></li><li class="chapter-item expanded "><a href="book/architecture/Floor.html">Floor</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference.html">C++ API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes.html">Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes/AFOW_Handler.html">AFOW_Handler</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_CollisionEntity_Interface.html">IFOW_CollisionEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_DrawingEntity_Interface.html">IFOW_DrawingEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_Entity_Interface.html">IFOW_Entity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_GeometryEntity_Interface.html">IFOW_GeometryEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_VisibilityEntity_Interface.html">IFOW_VisibilityEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_CollisionHandler.html">UFOW_CollisionHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_DrawerComponent.html">UFOW_DrawerComponent</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Drawer_Shared.html">UFOW_Drawer_Shared</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityContainer.html">UFOW_EntityContainer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityVisibilityHandler.html">UFOW_EntityVisibilityHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Floor.html">UFOW_Floor</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerHandler.html">UFOW_LayerHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerSetting.html">UFOW_LayerSetting</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Rasterizer.html">UFOW_Rasterizer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_TextureSample.html">UFOW_TextureSample</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Tile_Class.html">UFOW_Tile_Class</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_VisibilityE_Component.html">UFOW_VisibilityE_Component</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Layered Fog Of War documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="/book/index.html">Book</a></li>
<li><a href="/reference.html">C++ API Reference</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><p>#Book</p>
<p>This book covers explanation of the Layered Fog Of War architecture. You will find implementation
example, code explanation and how to make the best use of the FOW. This plugin is easy to use but
might become painfull to understand when you need better performance from it</p>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="book//book/getting_started.html">Getting Started</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="book/getting_started.html#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></li>
<li><a href="book/getting_started.html#features">Features</a>
<ul>
<li><a href="book/getting_started.html#high-definition-big-map">High Definition, Big Map</a></li>
<li><a href="book/getting_started.html#tons-of-ai">Tons of AI</a></li>
<li><a href="book/getting_started.html#vertical-games">Vertical Games</a></li>
<li><a href="book/getting_started.html#networking">Networking</a></li>
<li><a href="book/getting_started.html#developer-playground">Developer Playground</a></li>
<li><a href="book/getting_started.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>
<h2 id="the-fog-of-war-is-only-a-texture"><a class="header" href="#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></h2>
<p>To understand the technology, you have to see the FOW as a texture:</p>
<blockquote>
<p><strong>By using a texture, it should be possible to create games with a "flat" map. Gameplay areas
can't be superimposed, or you will discover undesirable parts of it. However, with multiple layers
and by applying transparency, we can get through this problem.</strong></p>
</blockquote>
<p>Quick definition:
A fog of war is a common game mechanic used in strategy and real-time strategy (RTS) games to
simulate uncertainty and limited visibility. It obscures parts of the game map that are not
currently within the player's line of sight or knowledge, typically represented by a shroud or
darkness.</p>
<p>A FOW is just a set of data represented as a texture, which allows the computer to hide some part
of the rendered frame from the player during the post-process pass. It will project the position
of the rendered pixel onto a plane delimiting the FOW. The projection will then query the state
of the fog texture to know if the player has sight on this pixel. It's a simple process of flattening
all the assets onto a plane.</p>
<p>The texture generation is done by elements called "Drawers"; they will compute a texture fragment
of what they see. Drawers can draw any shape to reveal an area. There are two different usages:</p>
<ul>
<li>Drawing circles which reveal everything around the player.</li>
<li>Casting the collision geometry shadow to simulate the sight of the player.</li>
</ul>
<p>Once every fragment is generated, they will be merged under the fog texture to be rendered.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="high-definition-big-map"><a class="header" href="#high-definition-big-map">High Definition, Big Map</a></h3>
<h4 id="1-intro"><a class="header" href="#1-intro">1. Intro</a></h4>
<p>The Fog of War algorithms are simple in theory but heavy to update. To have a decent frame rate,
you have to downgrade the texture precision to reduce the rasterization time of the drawers, the
texture update on the GPU, or the GPU texture sampling time. The fog update being heavy was also
an obstacle for game development. Maps had to be small for a high fog definition, or the definition
had to be low for huge maps. I've wanted to prevent that and let everyone choose any precision
without any repercussions.</p>
<h4 id="2-handler-floor-tile-sample"><a class="header" href="#2-handler-floor-tile-sample">2. Handler, Floor, Tile, Sample</a></h4>
<p>The Fog Of War is split into floors representing parts of your level. You can have as many as you
want, and you can juxtapose or even superpose them to give verticality. Every floor shares the
same settings given from the handler and will have the same precision. They are also divided into
tiles and snapped to a grid to simplify the merge and update process time. The FOW can have up to
8 visibility channels to represent fog. Only 2 channels are used in the given version to represent
3 states of fog:</p>
<ul>
<li>Seen: The player came earlier and is aware of the layout of the area.</li>
<li>Visible: The player directly sees the area.</li>
<li>Unseen: The player has never seen this area (meaning both of the channels are equal to 0).</li>
</ul>
<p>It's up to you to find more usages of the 6 other channels. You can also use only one channel to
make MOBA-like games where the map is fully visible.</p>
<h4 id="3-optimization-for-large-scale-projects"><a class="header" href="#3-optimization-for-large-scale-projects">3. Optimization for Large-Scale Projects</a></h4>
<p>To overcome the update time, the FOW uses samples of fog to send to the GPU and uses binary
compression of everything related to a texture. They are compressed such as 1 bit = 1 pixel. Doing
so reduces the memory usage but also the pixel processing time by doing bitwise operations. Most
of the update work is related to merging two textures, which means applying an "OR" operator between
two textures. Since all the pixels are packed and our computer can use registers up to 512 bits,
the FOW can also compute up to 512 pixels in one operation.</p>
<h4 id="4-architecture-repercussion"><a class="header" href="#4-architecture-repercussion">4. Architecture Repercussion</a></h4>
<p>To allow the best usage of binary operation, channels had to be separated and can be seen as N
different textures. Simplified representation of the texture</p>
<p>Normal texture:        -&gt;   FOW texture:<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br /></p>
<h3 id="tons-of-ai"><a class="header" href="#tons-of-ai">Tons of AI</a></h3>
<h4 id="1-intro-1"><a class="header" href="#1-intro-1">1. Intro</a></h4>
<p>Projects using FOW are mostly games using lots of AI. It was one of the main objectives, being
able to simulate thousands of units drawing fog. This plugin had to be ready for games like
"Among Us" but also for RTS or MOBA like "Age Of Empires" or "League Of Legends." Once more,
performance was the issue and had to be solved without impacting the precision or the map scaling.</p>
<h4 id="2-drawer-shareddrawer-entity-rasterizer"><a class="header" href="#2-drawer-shareddrawer-entity-rasterizer">2. Drawer, SharedDrawer, Entity, Rasterizer</a></h4>
<p>Each player has a number of units represented in the game. Those units help him to navigate,
discover, and fulfill the objective of the game. To discover the layout of the game, the FOW will
use Drawers. Those drawers are components registered into the FOW, which will generate a fragment
of fog represented as a bit array. This fragment is the representation of the sight of the owning
actor. It can draw any shape and will provide its fragment during the floor update to generate the
Fog Texture. However, merging thousand fragments is really inappropriate. It uses lots of memory,
memory isn't aligned, lots of CPU cache is requested, and it doesn't respect patterns that accelerate
computation. To ameliorate the process, the FOW follows the Data-Oriented Design (DOD) and allows
developers to use Entities instead of drawers. Entities are the representation of an object in the
game and will provide data to a "SharedDrawer," which will be able to update all registered entities
during a single update.</p>
<p>To generate a fog fragment, every drawer has a reference to a rasterizer. Drawers are data containers
designed to generate geometry that can be given to them. They are simple pieces of code that can be
overridden for specific usage. In the current state, two rasterizers are provided:</p>
<ul>
<li>UFOW_R_TriangledGeometryV1, made to draw convex geometry from a set of vertices</li>
<li>UFOW_R_CircleV1, made to draw a circle from one vertex</li>
</ul>
<h4 id="3-optimization-for-large-scale-projects-1"><a class="header" href="#3-optimization-for-large-scale-projects-1">3. Optimization for Large-Scale Projects</a></h4>
<p>To fasten the fragment generation process, the FOW packs data and follows DOD architecture.It takes
profit of multithreaded processors by doing asynchronous updates and allows the FOW to make discrete
updates which don't interfere with the game thread. In case of heavy updates, the FOW can be computed
in many Engine frames to prevent game freeze.</p>
<p>The DOD and task system are an entry point to the GPU computation. Everything has been thought to make
it possible and might be developed in the near future.</p>
<h2 id="vertical-games"><a class="header" href="#vertical-games">Vertical games</a></h2>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>It has been a challenge to allow everyone to create vertical top-down games. I took part in the development
of "Alien Dark Descent," and it has been tough to implement ladders and stairs. However, the FOW couldn't
dissociate the bottom from the top. So it was impossible to let the player discover the ground level and
then discover the basement without a level transition. As explained a bit earlier, the Layered FOW is made
out of floors that can be set up anywhere in the game. They will generate fog in the provided area, and
drawers will remove it. Nothing is required from the user to make verticality!</p>
<h3 id="gpu-data-transfer"><a class="header" href="#gpu-data-transfer">GPU data transfer</a></h3>
<p>Because of the GPU being the GPU, it was tough to go the simple way and send N textures representing the fog of floors. Plus, the update would have been super heavy. It was necessary to find a workaround to send data of each floor. The problem has been solved by packing floor fog samples into one texture; sample sizes are determined by the intersection of the camera frustum and the floor fog plane. However, a bigger texture will be required to update every floor.</p>
<p>To render correctly superposed floors, the material has to project and find the closest floors to query the fog state.</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h3>
<p>Most of the top-down games we play are competitive or cooperative, which means that the game needs networking.
On that behalf, the FOW has minimal Replication implementation. It's based on the fact that every player runs
the same simulation, which means that every client actor has the same position as the server. If this is
correct, there is no need to replicate the state of the FOG through the network; the only thing to synchronize
is which drawer draws for which team.</p>
<h3 id="fogstatereplication-clientserver"><a class="header" href="#fogstatereplication-clientserver">FogStateReplication Client/Server</a></h3>
<p>FogStateReplication is responsible for the synchronization between the client and the server. It's responsible
for fog synchronization; the server is able to send the FOW state to any client for game initialization. And
will provide a team ID to every client. This ID is used in each game instance to enable/disable drawers with the
same ID. Once the state and IDs synchronize, nothing else will go through the network regarding the FOW.</p>
<h3 id="replication-and-team-limitation"><a class="header" href="#replication-and-team-limitation">Replication and Team limitation</a></h3>
<p>To allow FOW state replication, the server has to be aware of the state of each team. It means that a game using 2
channels to represent "Seen" and "Visible" state can only have up to 4 teams. I've talked about it a bit earlier; the
FOW can use at the maximum 8 channels. The replication becomes not only a limitation for games by limiting the
team number, but also a performance limitation. The server user will have to constantly compute the fog of each
team even if only 1 team is displayed. Clients don't have this performance issue since they will update only the
attributed team.</p>
<p>Nevertheless, there is a workaround to palliate this limitation. It's possible to tell the server to compute only
the user team. The network will still work, but the FOW state won't be able to be synchronized in case of late
connection. One more thing to understand is that synchronization is useful only for a certain type of fog. The
client doesn't need any synchronization if the game uses the Visible channel. Once every Drawers will be synchronized
with the correct team, they will remove fog at their location to reproduce the state on the server.</p>
<p>To summarize, you can replicate the FOG state but you will have a team limitation depending on the number of channels
used per team. If you don't enable this replication and let the server compute the fog from its player ID you can
have as much team as you want!</p>
<h2 id="developer-playground"><a class="header" href="#developer-playground">Developer playground</a></h2>
<h3 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h3>
<p>This part is a bit more personal. I've wanted my plugin to be modular, with replaceable parts. I'm always
thinking that a better version exists which brings the necessity to slice my code and make it overridable.
It even became a pattern for me, making small modules and preventing to the maximum dependencies. On that
behalf, the plugin has many settings variables representing object classes to replace the provided ones.</p>
<p>I'm calling it a playground because it can be really simple modification to test a C++ functionality.
There are lots of modules that are containers where you can try to switch an array for a map, or where
you can add an acceleration structure to help the query function. As an example, I've made a naive collision
system testing collision with every registered collider, but I've also made another one using an AABB tree
to query the colliders in bounds.</p>
<h3 id="this-is-where-the-fun-begins"><a class="header" href="#this-is-where-the-fun-begins">This is Where the Fun Begins!</a></h3>
<p>I'll try to provide everything to let you replace the module and play with the code in the source files.
Here is the list of the modules and their working field:</p>
<ul>
<li>
<p>UFOW_Rasterizer: You can challenge yourself to find the fastest way to draw a triangle. You can also work on specific rasterizers specific to draw geometry from formulas (Cone, torus, rectangle ...)</p>
</li>
<li>
<p>UFOW_CollisionHandler: Key stone of the drawers computation time when casting collision shadow. Accelerate the collider querying with structure (AABB tree, Spatial hashing, octree ...)</p>
</li>
<li>
<p>UFOW_OcclusionBuffer: Occlusion system for the CollisionHandler to ignore collider. R&amp;D around the occlusion, the default one use 1D depth buffer</p>
</li>
<li>
<p>TFOW_Tile_Base: Merge the drawer fog fragment. You can play with SIMD instruction and find a faster way to merge everything</p>
</li>
<li>
<p>UFOW_DrawerComponent: Implement your custom drawer. You can play with tasks and multithreading</p>
</li>
<li>
<p>UFOW_SaveLoad: Generate a TArray<uint8> to be written in a file. You can play with pointers and compression</p>
</li>
<li>
<p>AFOW_FogStateReplication: If you need to adapt the network to your pipeline</p>
</li>
<li>
<p>AFOW_Handler: If you need to adapt the loading or update pipeline</p>
</li>
<li>
<p>UFOW_Floor: If you need to adapt the update pipeline</p>
</li>
</ul>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<h2>Everything works correctly by default; however, you might need to tweak a few settings and have a good
understanding of how the entities work for games with lots of AI.
You can make extremely vast games without vertical limits.
A simple replication implementation is already done allowing you to make online games.
If you are curious you're more than welcome to replace everything !!!! :)</h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section will explain in-depth how the Fog Of War has been thought out. It'll give you
the keys to tweak everything and set up the plugin to fit your game the best possible way.</p>
<p>Keep in mind that the Layered FOW doesn't need any modification to be used in game; only
if performances are an issue, modifications will be necessary.</p>
<h2 id="everything-is-tile-shaped"><a class="header" href="#everything-is-tile-shaped">Everything is Tile-shaped</a></h2>
<p>To allow high precision and large scale game, everything has been cut into pieces which can
be seen as tiles. This tiling system is really efficient for optimization and multithreading.
The FOW is designed this way:</p>
<ul>
<li><strong>FOWHandler</strong>: the biggest piece holding every data. It's a singleton, and only one instance can
exist in the level.</li>
<li><strong>FOWFloors</strong>: 3D boxes held by the Handler, where the fog will be applied. There is no number or
position limitation. It will store a bits array of the fog state and everything necessary to generate
fog fragment.</li>
<li><strong>FOWTiles</strong>: Defined by a power of 2 of fog pixels, it will create a grid for every element
interacting with the fog. Used to merge fog fragment to the result texture in the Floors.</li>
<li><strong>FOWTextureSample</strong>: The bond between CPU and GPU, it will collect Floors bit array to send it
to the GPU via a texture.</li>
</ul>
<h2 id="the-logic-is-managed-by-entities"><a class="header" href="#the-logic-is-managed-by-entities">The logic is managed by Entities</a></h2>
<p>The Entities are a suite of interfaces allowing data generation or querying. They are self-dependent
and don't need any update, no API is provided unless two methods to enable/disable the entity. The
FOW will do all the updates it needs to correctly generate the fog state of the frame. Entities exist
in 3 different forms inheriting from a base interface, plus one a bit different, designed for a late
purpose:</p>
<ul>
<li><strong>CollisionEntity</strong>: Provide methods to gather collision from an object. Collisions are used by the
drawers to cast shadow. The entity will be stored in CollisionHandler.</li>
<li><strong>DrawingEntity</strong>: Provide methods to collect drawing settings from an object. The entity will be
registered to shared drawer to generate fog fragment.</li>
<li><strong>VisibilityEntity</strong>: Provide methods to collect object size and location to update its visible
state depending on the fog.</li>
<li><strong>GeometryEntity</strong>: It doesn't derive from the Entity base class; its purpose is to hold geometry
data to be used by entities (calling it GeometryEntity was a mistake).</li>
</ul>
<h1 id="pages-1"><a class="header" href="#pages-1">Pages</a></h1>
<ul>
<li><a href="book/architecture//book/architecture/Handler.html">Handler</a></li>
<li><a href="book/architecture//book/architecture/Floor.html">Floor</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="book/architecture/Handler.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Handler.html#settings">Settings</a>
<ul>
<li><a href="book/architecture/Handler.html#editor-debug-setting">Editor debug setting</a></li>
<li><a href="book/architecture/Handler.html#fog-setting">Fog setting</a></li>
<li><a href="book/architecture/Handler.html#update-settings">Update settings</a></li>
<li><a href="book/architecture/Handler.html#module-settings">Module settings</a></li>
<li><a href="book/architecture/Handler.html#rendering-settings">Rendering settings</a></li>
</ul>
</li>
<li><a href="book/architecture/Handler.html#initialisation">Initialisation</a></li>
<li><a href="book/architecture/Handler.html#updates">Updates</a></li>
</ul>
</li>
</ul>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p><a href="book/architecture//book/architecture/FOWHandler.html"><code>class: AFOWHandler</code></a> is a singleton used to store <a href="book/architecture//book/architecture/Floor.html">Floors</a>
and used to change the Fog settings (Pixel size, Encoding, Collision system ...). It defines
the initialisation and the update loop. All initialisation happens during the begin play unless
for the floor generation that is instantiated straight into the editor.</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<h4 id="editor-debug-setting"><a class="header" href="#editor-debug-setting">Editor debug setting</a></h4>
<ul>
<li>"ShowGrid": display the grid delimited by the tile. Floors are snapped to this grid.</li>
<li>"ShowFloors": display the 3D box representing the floors. The pink square is the real position of
the floor, it will be aligned to the grid. The yellow square is the 3D Fog representation.</li>
</ul>
<h4 id="fog-setting"><a class="header" href="#fog-setting">Fog setting</a></h4>
<ul>
<li>Change the fog dimension and precision by changing "PixelSize" and adding
floors in the "FOWFloors" array.</li>
<li>Change the tile dimension by modifying their pixel number from "TilePixelNumber" Enum. Changing
tile size might become interesting for high fog precision, it will reduce the number of tile
merging and will allow the usage of bigger register for the tile merging.</li>
<li>Change the default fog status at start with "ChannelToClearAtStart". Useful if you
have a map with hidden area and the rest visible. Use "AFOW_DrawingE_Custom" with "UFOW_FloorStartUpLayer"
to add fog where it's needed. Fog will be cleared and re-draw during the initialisation and the very first frame.</li>
<li>Change "LayerHandler_Class" to organise the layer merging as you pleased.</li>
<li>Change "FOWFloorTiles_Class" to make the best fit with "TilePixelNumber", but also to set the number
of channels used by each team for your game.</li>
</ul>
<h4 id="update-settings"><a class="header" href="#update-settings">Update settings</a></h4>
<ul>
<li>Change the right of the FOW to use or not multithreading/Task/ComputeShader (compute shader not done yet).</li>
<li>Change the update rate of the FOW but I do not recommend using it, the render will be impacted by it.
It's better to enable the task and let the FOW do discrete updates if necessary.</li>
</ul>
<h4 id="module-settings"><a class="header" href="#module-settings">Module settings</a></h4>
<p>Modules that can be changed in the handler are stored under the "Settings|Class" section. There is
a differentiation between static and dynamic because some modules can be more or less optimized
depending on those two parameters (The AABBCollisionHandler has an update time super long for dynamic objects).</p>
<h4 id="rendering-settings"><a class="header" href="#rendering-settings">Rendering settings</a></h4>
<ul>
<li>Change "FOWShader_Class" to change the render system of the FOW. 3 different materials are provided
with the plugin:
<ul>
<li>"MPP_FOW_Floors": for flat game</li>
<li>"MPP_FOW_FloorsTransparency": for games with verticality</li>
<li>"MUI_FOW_Minimap": for the minimap</li>
</ul>
</li>
</ul>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>The initialisation of the FOW happens in the begin play and can be delayed if your pipeline needs it.
Initialization is split into many sections:</p>
<ul>
<li>"InitNetwork" will create a "Replicated" environment only if the game isn't standalone and if
the layer setting class is correctly set. Set network setting as the right to override many values
from the Handler to provide the accessibility to different clients. Thus it has to be executed first.</li>
<li>"InitTeams" isn't used and will be deleted.</li>
<li>"InitFOWFloorsTiles" Allocates the memory used by the floor. The FOW cannot do anything without it.
The tiles must be initialized before the game shader.</li>
<li>"InitGameShader" Generates "FOWTextureSample" that will be linked to the instantiated "FOWShader_Class".
You can override this to generate more material if needed. However, you have the possibility to create
and register texture sample at any time; don't force yourself to do everything in this method.</li>
<li>"InitFOWUpdate" is the most interesting method. If you have pipeline trouble, I recommend to let every
other initialization call and to delay only this one. Until this call is made, no update from the fog but
even from this entity or the collision system will happen. <strong>Please be very cautious to call "FinalizeInitialization"
just after the call of this method.</strong></li>
</ul>
<h4 id="visual-representation-of-the-initialisation-pipeline"><a class="header" href="#visual-representation-of-the-initialisation-pipeline">Visual representation of the initialisation pipeline</a></h4>
<p><img src="book/architecture/../../assets/FOWInitialisation.drawio.png" alt="FOWHandler initialisation pipeline" /></p>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>By default, the update happens during the actor tick. Every component of the FOW will be updated during
this sequence unless for the "FOWTextureSample". The update will be done at once if no asynchronous
tasks are requested and will be managed by two methods:</p>
<ul>
<li>"FOWUpdate_Begin" manages every update that needs to happen to let drawers generate fog fragment.
It'll update the dynamic Entities first and then the collision. It will also be responsible for multithreading
initialization.</li>
<li>"FOWUpdate_End" is called after that the drawers have generated their fog fragment. Depending on the usage
of task or compute shader, it'll be called right after the begin update or later in the frame. Fog fragment
will be sorted and distributed to floors to update the fog state. Once updated transient drawer will be deleted
and all "visibleEntity" will update their state to turn on/off their render.</li>
</ul>
<p>The "FOWTextureSample" has a special place to be updated because of the engine camera update time. To generate
fog sample the sample has to be aware of the position of the camera; however, Unreal updates their position at
the end of the tick. To prevent sample from sending wrong texture information, their updates happen at the very
end of the world tick. There is a second reason of why their update is separated and independent. In case
of long update, the FOW can skip an update frame if using asynchronous update. It doesn't impact the render
to not change the fog state, however, fog data on the GPU has to be perfectly synchronized with game or
artifacts might show up.</p>
<h4 id="visual-representation-of-the-updates-pipeline"><a class="header" href="#visual-representation-of-the-updates-pipeline">Visual representation of the Updates pipeline</a></h4>
<h2 id=""><a class="header" href="#"><img src="book/architecture/../../assets/FOWUpdate.drawio.png" alt="FOWHandler update pipeline" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor"><a class="header" href="#floor">Floor</a></h1>
<h1 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h1>
<ul>
<li><a href="book/architecture/Floor.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Floor.html#queries">Queries</a></li>
<li><a href="book/architecture/Floor.html#archetypes">Archetypes</a></li>
</ul>
</li>
<li><a href="book/architecture/Floor.html#problems-that-it-solves">Problems that it solves</a></li>
</ul>
<h1 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h1>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//reference/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-afow_handler"><a class="header" href="#class-afow_handler"><strong>Class: <code>AFOW_Handler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API AFOW_Handler
    : public AActor;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The Fog Of War Handler is the base class of the plugin, it's a sigleton and you cannot have many instance of it even when doing networked game with replication<br />
The Fog Of War is highly parametrable and let the developers override almost everything. You might want to get ride of some functionality or maybe to write a more optimized code<br />
The handler hasn't any main logic, it's purpose is to:</p>
<ul>
<li>Have general settings</li>
<li>Initialise FOW Object</li>
<li>Run the update</li>
<li>Contain FOW element instancies</li>
</ul>
<p>You have the possibility to change the core module of the FOW by changing the default class used int the settings</p>
<blockquote>
<ul>
<li>If you want a custom FOWHandler be sure to override FindLevelFOWHandler, you can use <strong><code>AFOW_Handler_Default</code></strong> as example</li>
<li>Go to the FOWFloors settings and display the parametters to shape the floor to your needs</li>
</ul>
</blockquote>
<p>If you need to modify the initialization to fit your pipeline, override those function called by the BeginPlay</p>
<ul>
<li>void InitNetwork();</li>
<li>void InitTeams();</li>
<li>void InitFOWFloors();</li>
<li>void InitFOWFloorsTiles();</li>
<li>void InitGameShader();</li>
<li>void InitFOWUpdate();</li>
<li>void FinalizeInitialization();
Please be really carefull to not finalize the initialization if the floor or game shader init havn't be called</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_collisionentity_interface"><a class="header" href="#class-ifow_collisionentity_interface"><strong>Class: <code>IFOW_CollisionEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_CollisionEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Collision entities are the sight blocker to prevent fog discovering between rooms.<br />
By design any child implementing this class should also implement <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> to enable optimisation</p>
<blockquote>
<ul>
<li>Depending of the situation you can have issues because of collision drawing optimisation, Override ShouldDrawColliders and return false to disable it</li>
<li>You can disable the whole collision drawing optimisation by disabling DrawFOWCollider in <a href="reference/classes//reference/classes/UFOW_LayerHandler.html"><strong><code>UFOW_LayerHandler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_drawingentity_interface"><a class="header" href="#class-ifow_drawingentity_interface"><strong>Class: <code>IFOW_DrawingEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_DrawingEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Drawing entity used to modify the state of the fog depending of the given <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Override GetEntityLayerSetting to give the correct layer setting</li>
<li>Call SetEntityTeam to change the entity team in case of multiplayer game</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_entity_interface"><a class="header" href="#class-ifow_entity_interface"><strong>Class: <code>IFOW_Entity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Base class for every entity interface, <a href="reference/classes//reference/classes/IFOW_GeometryEntity_Interface.html"><strong><code>IFOW_GeometryEntity_Interface</code></strong></a> is an exception subject to a retake</p>
<blockquote>
<ul>
<li><a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_VisibilityEntity_Interface.html"><strong><code>IFOW_VisibilityEntity_Interface</code></strong></a></li>
</ul>
</blockquote>
<p>Entities are by default automatically updated by the system if (IsStatic == false &amp;&amp; FloorVolatile)</p>
<blockquote>
<ul>
<li>FloorVolatile express the posibility to move from a floor to another</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : every multiple inheritance have specifique overriding rule regarding methodes finishing by _M.<br />
You can use <strong><code>AFOW_CustomCollision</code></strong> as examble for your custom entity implementation</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_geometryentity_interface"><a class="header" href="#class-ifow_geometryentity_interface"><strong>Class: <code>IFOW_GeometryEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_GeometryEntity_Interface;
</code></pre>
<hr />
<p>Geometry entity is a data container used by entities to modify fog or create collision.</p>
<blockquote>
<ul>
<li>Geometries are by default automatically updated by the system if (static == false || modular)</li>
<li>Override UpdateEntityGeometry to make your modification</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : The geometry system should be retaken to make the geometry aligned in memory</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_visibilityentity_interface"><a class="header" href="#class-ifow_visibilityentity_interface"><strong>Class: <code>IFOW_VisibilityEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_VisibilityEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Visibility entity used to automatically update the ingame visibility of the UObject inherited from it</p>
<blockquote>
<ul>
<li>VisibilityEntity are by default automatically updated</li>
<li>Override OnVisibilityStateChanged to update the visibility state</li>
<li>You can find a default example by looking at <strong><code>UFOW_VisibilityComponent</code></strong>.</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_collisionhandler"><a class="header" href="#class-ufow_collisionhandler"><strong>Class: <code>UFOW_CollisionHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_CollisionHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Collision handler is used to accelerate the querying of collider to generate sight mask<br />
Every handler is associated to its <strong><code>UFOW_CollisionHandlerQuery</code></strong> class</p>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawercomponent"><a class="header" href="#class-ufow_drawercomponent"><strong>Class: <code>UFOW_DrawerComponent</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_DrawerComponent
    : public UActorComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The drawer component compute fog modification, however it doesn't apply it.<br />
They are small chunk of fog aligned to the world grid, they can be seen as canvas.<br />
Their update are the slowest because of the collision querying and the geometry rasterization.<br />
By default they are mean to be added to each actor modifying the fog however the memory allocation and merging can become very time consuming.<br />
If your game needs higher performance take a look at <a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a> which will request the creation of a <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a> to the system.<br /></p>
<p>It is possible to :</p>
<blockquote>
<ul>
<li>Create custom drawer by inheriting from this class and by overriding GenerateDrawerGeometry to inject your custom geometry</li>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
<li>Change the collision querying by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawer_shared"><a class="header" href="#class-ufow_drawer_shared"><strong>Class: <code>UFOW_Drawer_Shared</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Drawer_Shared
    : public UFOW_DrawerComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
<li><strong>BlueprintType</strong></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Drawer designed to hold <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> and batch their update under one process</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entitycontainer"><a class="header" href="#class-ufow_entitycontainer"><strong>Class: <code>UFOW_EntityContainer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityContainer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>Dynamic entity and geometry container. Called by the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a> to update their status</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entityvisibilityhandler"><a class="header" href="#class-ufow_entityvisibilityhandler"><strong>Class: <code>UFOW_EntityVisibilityHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityVisibilityHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Update the visibility of every registered object implementing IFOW_VisibilityEntity_Interface.<br />
The class is instantied twice in every <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> for Static and dynamic entity.<br />
Each entity will query the FOW state at location or for an AABB on the owner FOW_Floor.<br /></p>
<blockquote>
<ul>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Override OnVisibilityStateChanged methode in IFOW_VisibilityEntity_Interface to apply custom modification</li>
<li>Bind your object to OnVisibilityChanged if you are using FOW_VisibilityComponent</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="visibleentities"><a class="header" href="#visibleentities"><strong><code>VisibleEntities</code></strong></a></h1>
<pre><code class="language-cpp">protected:
TArray&lt;TScriptInterface&lt;IFOW_VisibilityEntity_Interface&gt;&gt; VisibleEntities;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadOnly</strong></li>
<li><strong>Category</strong> = <em>Internal</em></li>
</ul>
<hr />
<p>Hold the visible entity</p>
</li>
</ul>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="prepareforworlddestruction"><a class="header" href="#prepareforworlddestruction"><strong><code>PrepareForWorldDestruction</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void PrepareForWorldDestruction();
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Call before the world destruction to prevent all Remove or Add operation</p>
  </details>
</li>
<li>
<h1 id="updatevisibilitystate"><a class="header" href="#updatevisibilitystate"><strong><code>UpdateVisibilityState</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void UpdateVisibilityState(
    const UFOW_Floor* Floor,
    uint8 FOWGlobalSettingFlags
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Update the visibility state of all registered entity</p>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="floor-1"><a class="header" href="#floor-1"><strong><code>Floor</code></strong></a></h2>
<pre><code class="language-cpp">const UFOW_Floor* Floor
</code></pre>
</li>
<li>
<h2 id="fowglobalsettingflags"><a class="header" href="#fowglobalsettingflags"><strong><code>FOWGlobalSettingFlags</code></strong></a></h2>
<pre><code class="language-cpp">uint8 FOWGlobalSettingFlags
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_floor"><a class="header" href="#class-ufow_floor"><strong>Class: <code>UFOW_Floor</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Floor
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>The floor is an area where a bit mask texture is generated to create fog.<br />
Each floor bit mask will be sliced and attributed to a <strong><code>TFOW_Tile_Base</code></strong>.<br />
It's responsible of the fog state update by querying the fog chunk of every drawer.<br />
Every levels can have many instances of floor to allow verticallity for your game.<br />
Each floor has a collision handler static and dynamic and is responsible for the collision update.<br /></p>
<blockquote>
<ul>
<li>Change the collision system by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<p>Warning : supperposed floor will work correctly only if you change the PP material in <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layerhandler"><a class="header" href="#class-ufow_layerhandler"><strong>Class: <code>UFOW_LayerHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The layer handler allow you to change the computation order of the different <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Layer will modify the fog state in the given order, which means that a modification can be overriden by an other layer</li>
<li>Enable or disable the collision drawing optimisation by changing DrawFOWCollider</li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layersetting"><a class="header" href="#class-ufow_layersetting"><strong>Class: <code>UFOW_LayerSetting</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerSetting
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Layer setting is made to configure how an entity or a drawing component will modify the fog</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_rasterizer"><a class="header" href="#class-ufow_rasterizer"><strong>Class: <code>UFOW_Rasterizer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Rasterizer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The rasterizer convert the geometries to a bit mask texture representing the state of the FOW.<br />
The reasterizer is never instantied, the default object is always used witch means that you cannot use variable in the class</p>
<blockquote>
<ul>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_texturesample"><a class="header" href="#class-ufow_texturesample"><strong>Class: <code>UFOW_TextureSample</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_TextureSample
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The texture sample collect sample of FOW from the <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> to write it inside a texture that will be bind to materials</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_tile_class"><a class="header" href="#class-ufow_tile_class"><strong>Class: <code>UFOW_Tile_Class</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Tile_Class
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
</ul>
<hr />
<p><strong><code>TFOW_Tile_Base</code></strong> aren't a UCLASS to prevent saturation of GC, thus they are all wrapped by a FOW_Tile_Class and allocated the old way.<br />
Tiles are used to compute fog result of the <a href="reference/classes//reference/classes/UFOW_DrawerComponent.html"><strong><code>UFOW_DrawerComponent</code></strong></a> and merge it depending of the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a> under a bit array that will feed the <a href="reference/classes//reference/classes/UFOW_TextureSample.html"><strong><code>UFOW_TextureSample</code></strong></a> sent to the GPU.<br />
You can simply create your own tile update by overriding this class and by using the templated class <strong><code>TFOW_Tile</code></strong>.
you will have to create 3 templated classes to finish your fully custom tiles :</p>
<ul>
<li>Update</li>
<li>Compute</li>
<li>Merge</li>
</ul>
<blockquote>
<ul>
<li>Override GetTileBitsFormat to correctly set the tile pixel number for the FOW</li>
<li>Override GetTileChannelNbr to correctly set the channels number per tiles</li>
<li>Override GetTilePackagingFormat to correctly set the packaging format use by the FOW</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<p>Warning : I highly advise to use the EnumFOWTilePackagingFormat::PACKED format for optimisation reason</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_visibilitye_component"><a class="header" href="#class-ufow_visibilitye_component"><strong>Class: <code>UFOW_VisibilityE_Component</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_VisibilityE_Component
    : public UActorComponent
    , public IFOW_VisibilityEntity_Interface;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>ClassGroup</strong> = <em>Custom</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Can be added to any actor which need to be hidden when the player hasn't sight on it</p>
<blockquote>
<ul>
<li>Enable IsEntityFloorVolatile to use the default visibility update</li>
<li>Bind yourself to OnVisibilityChanged to customise the visibility update</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onvisibilitychanged"><a class="header" href="#onvisibilitychanged"><strong><code>OnVisibilityChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
FOnVisibilityChangedd OnVisibilityChanged;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintAssignable</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>FOW</em></li>
</ul>
<hr />
<p>Called every time the Visibility state has changed</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
