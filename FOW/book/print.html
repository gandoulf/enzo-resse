<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Layered Fog Of War documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="documentation.html">Documentation</a></li><li class="chapter-item expanded "><a href="book/index.html">Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/getting_started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="book/architecture/index.html">Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/architecture/Handler.html">Handler</a></li><li class="chapter-item expanded "><a href="book/architecture/Floor.html">Floor</a></li><li class="chapter-item expanded "><a href="book/architecture/Layers.html">Layers</a></li><li class="chapter-item expanded "><a href="book/architecture/Network.html">Network</a></li></ol></li><li class="chapter-item expanded "><a href="book/Template/index.html">Template</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Template/MOBA.html">MOBA Template</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/index.html">Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/First_set_up.html">First set up</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/index.html">Entities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/entities/Collision_Entity.html">Collision entity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/Drawing_Entity.html">Drawing entity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/Visibility_Entity.html">Visibility Entity</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/index.html">Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/HeatTexture.html">Heat Texture</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/Material.html">Post Process</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/MaterialOpacity.html">Material Opacity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/Stencil.html">Stencil</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/Teams.html">Teams</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Rendering/ToggleRender.html">Toggle Render</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/FogChannels.html">Fog Channels</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Floor_Verticality.html">Floor and Verticality</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Layers.html">Layers</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Minimap.html">Minimap</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Networking.html">Networking</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Outdoor_Indoor.html">Outdoor Indoor</a></li><li class="chapter-item expanded "><a href="book/Tutorials/PluginAPI.html">PluginAPI</a></li><li class="chapter-item expanded "><a href="book/Tutorials/StealthArea.html">Stealth Area</a></li></ol></li><li class="chapter-item expanded "><a href="book/Versions/index.html">Versions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Versions/LFOW_V1.1.1.html">LFOW V1.1.1</a></li><li class="chapter-item expanded "><a href="book/Versions/LFOW_V1.2.0.html">LFOW V1.2.0</a></li><li class="chapter-item expanded "><a href="book/Versions/LFOW_V1.2.1.html">LFOW V1.2.1</a></li><li class="chapter-item expanded "><a href="book/Versions/LFOW_V1.3.0.html">LFOW V1.3.0</a></li><li class="chapter-item expanded "><a href="book/Versions/LFOW_V1.3.1.html">LFOW V1.3.1</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference.html">C++ API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes.html">Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes/AFOW_Handler.html">AFOW_Handler</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_CollisionEntity_Interface.html">IFOW_CollisionEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_DrawingEntity_Interface.html">IFOW_DrawingEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_Entity_Interface.html">IFOW_Entity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_GeometryEntity_Interface.html">IFOW_GeometryEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_VisibilityEntity_Interface.html">IFOW_VisibilityEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_CollisionHandler.html">UFOW_CollisionHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_DrawerComponent.html">UFOW_DrawerComponent</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Drawer_Shared.html">UFOW_Drawer_Shared</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityContainer.html">UFOW_EntityContainer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityVisibilityHandler.html">UFOW_EntityVisibilityHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Floor.html">UFOW_Floor</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerHandler.html">UFOW_LayerHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerSetting.html">UFOW_LayerSetting</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Rasterizer.html">UFOW_Rasterizer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_TextureSample.html">UFOW_TextureSample</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Tile_Class.html">UFOW_Tile_Class</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_VisibilityE_Component.html">UFOW_VisibilityE_Component</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Layered Fog Of War documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="/book/index.html">Book</a></li>
<li><a href="/reference.html">C++ API Reference</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="book"><a class="header" href="#book">Book</a></h1>
<p>This book provides an in-depth explanation of the Layered Fog Of War architecture. It includes implementation
examples, code explanations, and guidance on maximizing the utility of the FOW. While this plugin is
straightforward to use, understanding it thoroughly may become challenging when striving for improved performance.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="book//book/getting_started.html">Getting Started</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="book/getting_started.html#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></li>
<li><a href="book/getting_started.html#features">Features</a>
<ul>
<li><a href="book/getting_started.html#high-definition-big-map">High Definition, Big Map</a></li>
<li><a href="book/getting_started.html#tons-of-ai">Tons of AI</a></li>
<li><a href="book/getting_started.html#vertical-games">Vertical Games</a></li>
<li><a href="book/getting_started.html#networking">Networking</a></li>
<li><a href="book/getting_started.html#developer-playground">Developer Playground</a></li>
<li><a href="book/getting_started.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>
<h2 id="the-fog-of-war-is-only-a-texture"><a class="header" href="#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></h2>
<p>Understanding the technology requires seeing the Fog of War (FOW) as a texture:</p>
<blockquote>
<p><strong>By utilizing a texture, it should be possible to create games with a "flat" map. Gameplay areas cannot be superimposed,
or undesirable parts of it will be revealed. However, by employing multiple layers and applying transparency, this issue
can be addressed.</strong></p>
</blockquote>
<p>Quick definition:
The fog of war is a common game mechanic used in strategy and real-time strategy (RTS) games to simulate uncertainty and
limited visibility. It obscures parts of the game map that are not currently within the player's line of sight or knowledge,
typically represented by a shroud or darkness.</p>
<p>FOW is merely a set of data represented as a texture, allowing the computer to conceal some parts of the rendered frame from
the player during the post-process pass. It will project the position of the rendered pixel onto a plane delimiting the FOW.
The projection will then query the state of the fog texture to determine if the player has sight on this pixel. It's a simple
process of flattening all the assets onto a plane.</p>
<p>The texture generation is carried out by elements called "Drawers"; they compute a texture fragment of what they see. Drawers
can draw any shape to reveal an area, with two primary usages: drawing circles to reveal everything around the player and casting
the collision geometry shadow to simulate the player's sight.</p>
<p>Once every fragment is generated, they are merged under the fog texture to be rendered.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="high-definition-big-map"><a class="header" href="#high-definition-big-map">High Definition, Big Map</a></h3>
<h4 id="1-introduction"><a class="header" href="#1-introduction">1. Introduction</a></h4>
<p>The Fog of War algorithms are simple in theory but resource-intensive to update. To maintain a decent frame rate, texture
precision needs to be downgraded to reduce rasterization time of the drawers, texture update time on the GPU, or GPU texture
sampling time. The heavy fog update also posed obstacles for game development. Maps had to be small for high fog definition,
or the definition had to be low for huge maps. I've aimed to prevent this and allow everyone to choose any precision without
repercussions.</p>
<h4 id="2-handler-floor-tile-sample"><a class="header" href="#2-handler-floor-tile-sample">2. Handler, Floor, Tile, Sample</a></h4>
<p>The Fog Of War is divided into floors representing parts of your level. You can have as many as you want, and they can be
juxtaposed or even superposed to add verticality. Every floor shares the same settings provided by the handler and will have
the same precision. They are also divided into tiles and snapped to a grid to simplify the merge and update process. The FOW
can have up to 8 visibility channels to represent fog, but only 2 channels are used in the given version to represent 3 states
of fog:</p>
<ul>
<li>Seen: The player has visited the area and is aware of its layout.</li>
<li>Visible: The player directly sees the area.</li>
<li>Unseen: The player has never seen this area (meaning both channels are equal to 0).</li>
</ul>
<p>It's up to you to find more uses for the other 6 channels. You can also use only one channel to create MOBA-like games where
the map is fully visible.</p>
<h4 id="3-optimization-for-large-scale-projects"><a class="header" href="#3-optimization-for-large-scale-projects">3. Optimization for Large-Scale Projects</a></h4>
<p>To overcome update time, the FOW uses fog samples sent to the GPU and binary compression of everything related to a texture.
They are compressed such that 1 bit equals 1 pixel. This reduces memory usage and pixel processing time through bitwise operations.
Most of the update work involves merging two textures, applying an "OR" operator between them. Since all pixels are packed and
computers can use registers up to 512 bits, the FOW can compute up to 512 pixels in one operation.</p>
<h4 id="4-architecture-repercussions"><a class="header" href="#4-architecture-repercussions">4. Architecture Repercussions</a></h4>
<p>To allow the best usage of binary operations, channels had to be separated and can be seen as N different textures. Simplified
representation of the texture:</p>
<p>Normal texture:        -&gt;   FOW texture:<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br /></p>
<h3 id="tons-of-ai"><a class="header" href="#tons-of-ai">Tons of AI</a></h3>
<h4 id="1-introduction-1"><a class="header" href="#1-introduction-1">1. Introduction</a></h4>
<p>Projects utilizing FOW primarily involve games with extensive AI usage. One of the primary objectives was to simulate thousands
of units drawing fog. This plugin needed to be adaptable for games like "Among Us" as well as for RTS or MOBA games like "Age Of Empires"
or "League Of Legends." Once again, performance was a concern and needed to be addressed without compromising precision or map scaling.</p>
<h4 id="2-drawer-shareddrawer-entity-rasterizer"><a class="header" href="#2-drawer-shareddrawer-entity-rasterizer">2. Drawer, SharedDrawer, Entity, Rasterizer</a></h4>
<p>Each player controls a number of units within the game, aiding in navigation, exploration, and achieving game objectives. To explore
the game's layout, the FOW employs Drawers. These drawers are components registered within the FOW, generating fog fragments represented
as bit arrays. These fragments depict the sight of the owning actor, capable of drawing any shape and providing its fragment during
floor updates to generate the Fog Texture. However, merging thousands of fragments is inefficient, consuming excessive memory, lacking
alignment, demanding significant CPU cache, and failing to adhere to patterns that accelerate computation. To improve this process,
the FOW follows Data-Oriented Design (DOD) principles and enables developers to utilize Entities instead of drawers. Entities represent
objects in the game and supply data to a "SharedDrawer," which updates all registered entities during a single update.</p>
<p>To generate a fog fragment, each drawer has a reference to a rasterizer. Drawers serve as data containers designed to generate geometry
provided to them. They are simple code components that can be overridden for specific purposes. Currently, two rasterizers are available:</p>
<ul>
<li>UFOW_R_TriangledGeometryV1: Draws convex geometry from a set of vertices</li>
<li>UFOW_R_CircleV1: Draws a circle from a single vertex</li>
</ul>
<h4 id="3-optimization-for-large-scale-projects-1"><a class="header" href="#3-optimization-for-large-scale-projects-1">3. Optimization for Large-Scale Projects</a></h4>
<p>To expedite fragment generation, the FOW packs data and adheres to DOD architecture. It utilizes multithreaded processors through
asynchronous updates, allowing discrete updates that do not interfere with the game thread. In cases of heavy updates, the FOW can be
computed across multiple engine frames to prevent game freezing.</p>
<p>The DOD and task system serve as entry points to GPU computation. Every effort has been made to facilitate this and may be further
developed in the future.</p>
<h3 id="vertical-games"><a class="header" href="#vertical-games">Vertical Games</a></h3>
<h4 id="introduction"><a class="header" href="#introduction">Introduction</a></h4>
<p>Enabling the creation of vertical top-down games for everyone has been a challenge. I participated in the development of "Alien Dark Descent,"
where implementing ladders and stairs proved difficult. However, the Fog of War (FOW) couldn't distinguish between the bottom and the top,
making it impossible to allow players to explore the ground level and then the basement without a level transition. As mentioned earlier,
the Layered FOW comprises floors that can be placed anywhere in the game. They generate fog in the designated area, which drawers subsequently
remove. No additional user input is necessary to introduce verticality!</p>
<h4 id="gpu-data-transfer"><a class="header" href="#gpu-data-transfer">GPU Data Transfer</a></h4>
<p>Due to the GPU's limitations, it was challenging to send N textures representing the fog of floors. Additionally, the update process would
have been overly burdensome. It was necessary to devise a method to transmit data for each floor. This issue was addressed by packing floor
fog samples into one texture, with sample sizes determined by the intersection of the camera frustum and the floor fog plane. However, updating
every floor will require a larger texture.</p>
<p>To correctly render superposed floors, the material must project and identify the closest floors to query the fog state.</p>
<h3 id="networking"><a class="header" href="#networking">Networking</a></h3>
<h4 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h4>
<p>Most top-down games we play are competitive or cooperative, necessitating networking. In this regard, the FOW features minimal Replication
implementation. It operates on the premise that every player runs the same simulation, meaning every client actor shares the same position as
the server. If this condition holds true, there is no need to replicate the FOG state over the network; the only synchronization required is
determining which drawer represents which team.</p>
<h4 id="fogstatereplication-clientserver"><a class="header" href="#fogstatereplication-clientserver">FogStateReplication Client/Server</a></h4>
<p>FogStateReplication facilitates synchronization between the client and the server. It manages fog synchronization; the server can send the
FOW state to any client for game initialization and assigns a team ID to each client. This ID is utilized in each game instance to enable/disable
drawers associated with the same ID. Once the state and IDs are synchronized, no further FOW-related data is transmitted over the network.</p>
<h4 id="replication-and-team-limitation"><a class="header" href="#replication-and-team-limitation">Replication and Team Limitation</a></h4>
<p>To enable FOW state replication, the server must be aware of the state of each team. This means that a game using 2 channels to represent
"Seen" and "Visible" states can only accommodate up to 4 teams. As discussed earlier, the FOW can utilize a maximum of 8 channels. Replication
not only limits the number of teams a game can have but also imposes performance constraints. The server user must continuously compute
the fog for each team, even if only 1 team is displayed. Clients do not encounter this performance issue as they only update the attributed
team.</p>
<p>However, there is a workaround to mitigate this limitation. The server can be instructed to compute only for the user's team. While the
network will still function, FOW state synchronization will not be possible in case of a late connection. It's important to note that
synchronization is only necessary for a specific type of fog. Clients do not require synchronization if the game employs the Visible channel.
Once all drawers are synchronized with the correct team, they will remove fog at their location to replicate the server's state.</p>
<p>In summary, FOG state replication is possible but limited by the number of channels used per team. Alternatively, allowing the server to
compute the fog based on the player's ID removes this limitation, enabling as many teams as desired!</p>
<h3 id="developer-playground"><a class="header" href="#developer-playground">Developer Playground</a></h3>
<h4 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h4>
<p>This section is somewhat personal. I aimed for my plugin to be modular, with interchangeable parts. I've always believed that a better
version exists, leading me to segment my code and make it replaceable. This approach has become a pattern for me, creating small modules
and minimizing dependencies. Accordingly, the plugin includes numerous settings variables representing object classes to replace the
provided ones.</p>
<p>I call it a playground because it allows for simple modifications to test C++ functionality. There are numerous modules that serve as
containers for experimentation, enabling users to swap arrays for maps or add acceleration structures to aid in query functions. For
example, I've created a naive collision system that tests collisions with every registered collider, as well as another using an AABB
tree for querying colliders within bounds.</p>
<h4 id="this-is-where-the-fun-begins"><a class="header" href="#this-is-where-the-fun-begins">This is Where the Fun Begins!</a></h4>
<p>I aim to provide everything necessary for users to replace modules and experiment with the code in the source files. Here is a list
of the modules and their intended use:</p>
<ul>
<li>UFOW_Rasterizer: Experiment with the fastest way to draw a triangle or develop rasterizers specific to drawing geometry from formulas (e.g., Cone, torus, rectangle...)</li>
<li>UFOW_CollisionHandler: Crucial for drawer computation time when casting collision shadows. Accelerate collider querying with structures (e.g., AABB tree, Spatial hashing, octree...)</li>
<li>UFOW_OcclusionBuffer: Implements an occlusion system for the CollisionHandler to ignore colliders. Research and development around occlusion, with the default using a 1D depth buffer.</li>
<li>TFOW_Tile_Base: Merges drawer fog fragments. Experiment with SIMD instructions and find a faster way to merge everything.</li>
<li>UFOW_DrawerComponent: Implement custom drawers. Experiment with tasks and multithreading.</li>
<li>UFOW_SaveLoad: Generates a TArray<uint8> to be written in a file. Experiment with pointers and compression.</li>
<li>AFOW_FogStateReplication: Adapt the network to your pipeline.</li>
<li>AFOW_Handler: Adapt the loading or update pipeline.</li>
<li>UFOW_Floor: Adapt the update pipeline.</li>
</ul>
<h3 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h3>
<p>Everything functions correctly by default, but users may need to adjust some settings and have a good understanding of how entities
work for games with extensive AI usage. Vast games without vertical limits can be created, and a simple replication implementation
allows for the creation of online games. Curious users are encouraged to replace everything and experiment!</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section will explain in-depth how the Fog Of War has been thought out. It'll give you the keys to tweak
everything and set up the plugin to fit your game the best possible way.</p>
<p>Keep in mind that the Layered FOW doesn't need any modification to be used in game; only if performances are
an issue, modifications will be necessary.</p>
<h2 id="everything-is-tile-shaped"><a class="header" href="#everything-is-tile-shaped">Everything is Tile-shaped</a></h2>
<p>To allow high precision and large scale game, everything has been cut into pieces which can be seen as tiles.
This tiling system is really efficient for optimization and multithreading. The FOW is designed this way:</p>
<ul>
<li><code>FOWHandler</code>: the biggest piece holding every data. It's a singleton, and only one instance can exist in the level.</li>
<li><code>FOWFloors</code>: 3D boxes held by the Handler, where the fog will be applied. There is no number or position limitation. It will store a bits array of the fog state and everything necessary to generate fog fragment.</li>
<li><code>FOWTiles</code>: Defined by a power of 2 of fog pixels, it will create a grid for every element interacting with the fog. Used to merge fog fragment to the result texture in the Floors.</li>
<li><code>FOWTextureSample</code>: The bond between CPU and GPU, it will collect Floors bit array to send it to the GPU via a texture.</li>
</ul>
<h2 id="the-logic-is-managed-by-entities"><a class="header" href="#the-logic-is-managed-by-entities">The logic is managed by Entities</a></h2>
<p>The Entities are a suite of interfaces allowing data generation or querying. They are self-dependent and don't
need any update, no API is provided unless two methods to enable/disable the entity. The FOW will do all the
updates it needs to correctly generate the fog state of the frame. Entities exist in 3 different forms inheriting
from a base interface, plus one a bit different, designed for a late purpose:</p>
<ul>
<li><code>CollisionEntity</code>: Provide methods to gather collision from an object. Collisions are used by the drawers to cast shadow. The entity will be stored in CollisionHandler.</li>
<li><code>DrawingEntity</code>: Provide methods to collect drawing settings from an object. The entity will be registered to shared drawer to generate fog fragment.</li>
<li><code>VisibilityEntity</code>: Provide methods to collect object size and location to update its visible state depending on the fog.</li>
<li><code>GeometryEntity</code>: It doesn't derive from the Entity base class; its purpose is to hold geometry data to be used by entities (calling it GeometryEntity was a mistake).</li>
</ul>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-1"><a class="header" href="#pages-1">Pages</a></h1>
<ul>
<li><a href="book/architecture//book/architecture/Handler.html">Handler</a></li>
<li><a href="book/architecture//book/architecture/Floor.html">Floor</a></li>
<li><a href="book/architecture//book/architecture/Layers.html">Layers</a></li>
<li><a href="book/architecture//book/architecture/Network.html">Network</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="book/architecture/Handler.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Handler.html#settings">Settings</a>
<ul>
<li><a href="book/architecture/Handler.html#editor-debug-setting">Editor debug setting</a></li>
<li><a href="book/architecture/Handler.html#fog-setting">Fog setting</a></li>
<li><a href="book/architecture/Handler.html#update-settings">Update settings</a></li>
<li><a href="book/architecture/Handler.html#module-settings">Module settings</a></li>
<li><a href="book/architecture/Handler.html#rendering-settings">Rendering settings</a></li>
</ul>
</li>
<li><a href="book/architecture/Handler.html#initialisation">Initialisation</a></li>
<li><a href="book/architecture/Handler.html#updates">Updates</a></li>
</ul>
</li>
</ul>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>The <code>AFOW_Handler</code> class is a singleton used to store <a href="book/architecture//book/architecture/Floor.html">Floors</a> and manage Fog settings such as Pixel size, Encoding,
and Collision system. It defines the initialization and update loop. All initialization happens during the begin play unless
for the floor generation that is instantiated straight into the editor.</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<h4 id="editor-debug-setting"><a class="header" href="#editor-debug-setting">Editor debug setting</a></h4>
<ul>
<li><code>ShowGrid</code>: display the grid delimited by the tile. Floors are snapped to this grid.</li>
<li><code>ShowFloors</code>: display the 3D box representing the floors. The pink square is the real position of the floor, it will
be aligned to the grid. The yellow square is the 3D Fog representation.</li>
</ul>
<h4 id="fog-setting"><a class="header" href="#fog-setting">Fog setting</a></h4>
<ul>
<li><code>PixelSize</code>: lets you adapt the fog precision, the value is expressed in centimeters.</li>
<li><code>FOWFloors</code>: lets you create new game areas with fog.</li>
<li><code>TilePixelNumber</code>: lets you change the tile dimension by modifying their pixel number. Changing tile size might become
interesting for high fog precision, it will reduce the number of tile merging and will allow the usage of bigger registers for the merging.</li>
<li><code>ChannelToClearAtStart</code>: lets you choose the default fog status at start. Useful if you have a map with hidden area
and the rest visible. Use <code>AFOW_DrawingE_Custom</code> with <code>UFOW_FloorStartUpLayer</code> to add fog where it's needed. Fog will
be cleared and redrawn during the initialization and the very first frame.</li>
<li><code>LayerHandler_Class</code>: lets the possibility to the user to organize the layer merging.</li>
<li><code>FOWFloorTiles_Class</code>: lets you choose the number of channels used by the game. It is also designed to select the computation method
of tile merging. Warning register used cannot be bigger than <code>TilePixelNumber</code>.</li>
</ul>
<h4 id="update-settings"><a class="header" href="#update-settings">Update settings</a></h4>
<ul>
<li><code>FOWComputeSetting</code>: Change the right of the FOW to use or not multithreading/Task/ComputeShader (compute shader not done yet).</li>
<li><code>FOWUpdateRate</code>: Change the update rate of the FOW. However I do not recommend to use it, render will be impacted and become less
smooth. I recommend to enable task and let the FOW do discrete updates.</li>
</ul>
<h4 id="module-settings"><a class="header" href="#module-settings">Module settings</a></h4>
<p>Modules that can be changed in the handler are stored under the <code>Settings|Class</code> section. There is a differentiation between static
and dynamic because some modules can be more or less optimized depending on those two parameters (The AABBCollisionHandler has an
update time super long for dynamic objects).</p>
<h4 id="rendering-settings"><a class="header" href="#rendering-settings">Rendering settings</a></h4>
<ul>
<li><code>FOWShader_Class</code>: change the render system of the FOW. 3 different materials are provided with the plugin:
<ul>
<li><code>MPP_FOW_Floors</code>: for flat game</li>
<li><code>MPP_FOW_FloorsTransparency</code>: for games with verticality</li>
<li><code>MUI_FOW_Minimap</code>: for the minimap</li>
</ul>
</li>
</ul>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>The initialization of the FOW happens in the begin play and can be delayed if your pipeline needs it. Initialization is split into
many sections:</p>
<ul>
<li><code>InitNetwork</code> will create a <strong>Replicated</strong> environment only if the game isn't standalone and if the Network setting class is
correctly set. Set network setting has the right to override many values from the Handler to provide the accessibility to different
clients. Thus it has to be executed first.</li>
<li><code>InitTeams</code> isn't used and will be deleted.</li>
<li><code>InitFOWFloorsTiles</code>: Allocates the memory used by the floor. The FOW cannot do anything without it. The tiles must be
initialized before the game shader.</li>
<li><code>InitGameShader</code>: Generates <code>FOWTextureSample</code> that will be linked to the instantiated <code>FOWShader_Class</code>. You can override this to
generate more material if needed. However, you have the possibility to create and register texture sample at any time; don't force
yourself to do everything in this method.</li>
<li><code>InitFOWUpdate</code> is the most interesting method. If you have pipeline trouble, I recommend to let every other initialization call
and to delay only this one. Until this call is made, no update from the fog but even from this entity or the collision system will
happen. <strong>Please be very cautious to call <code>FinalizeInitialization</code> just after the call of this method.</strong></li>
</ul>
<h4 id="visual-representation-of-the-initialisation-pipeline"><a class="header" href="#visual-representation-of-the-initialisation-pipeline">Visual representation of the initialisation pipeline</a></h4>
<p><img src="book/architecture/../../assets/Architecture/Handler/FOWInitialisation.drawio.png" alt="FOWHandler initialisation pipeline" /></p>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>By default, the update happens during the actor tick. Every component of the FOW will be updated during this sequence unless for
the <code>FOWTextureSample</code>. The update will be done at once if no asynchronous tasks are requested and will be managed by two methods:</p>
<ul>
<li><code>FOWUpdate_Begin</code> manages every update that needs to happen to let drawers generate fog fragment. It'll update the dynamic Entities
first and then the collision. It will also be responsible for multithreading initialization.</li>
<li><code>FOWUpdate_End</code> is called after that the drawers have generated their fog fragment. Depending on the usage of task or compute shader,
it'll be called right after the begin update or later in the frame. Fog fragment will be sorted and distributed to floors to update the
fog state. Once updated transient drawer will be deleted and all "visibleEntity" will update their state to turn on/off their render.</li>
</ul>
<p>The <code>FOWTextureSample</code> has a special place to be updated because of the engine camera update time. To generate fog sample the sample
has to be aware of the position of the camera; however, Unreal updates their position at the end of the tick. To prevent sample from
sending wrong texture information, their updates happen at the very end of the world tick. There is a second reason of why their update
is separated and independent. In case of long update, the FOW can skip an update frame if using asynchronous update. It doesn't impact
the render to not change the fog state, however, fog data on the GPU has to be perfectly synchronized with game or artifacts might show up.</p>
<h4 id="visual-representation-of-the-updates-pipeline"><a class="header" href="#visual-representation-of-the-updates-pipeline">Visual representation of the Updates pipeline</a></h4>
<p><img src="book/architecture/../../assets/Architecture/Handler/FOWUpdate.drawio.png" alt="FOWHandler update pipeline" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor"><a class="header" href="#floor">Floor</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="book/architecture/Floor.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Floor.html#settings">Settings</a></li>
<li><a href="book/architecture/Floor.html#fog-update">Fog Update</a></li>
</ul>
</li>
</ul>
<h2 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h2>
<p>The <code>AFOW_Floor</code> class represents 3D boxes held by the <a href="book/architecture//book/architecture/Handler.html">Handler</a>, where the fog is applied. The fog is stored in a "bit array"
that is updated and sampled every frame. The update is facilitated by the <code>TFOW_Tile_Base</code> class, which shares the bit array pointer to
allow multithreading and prevent unnecessary updates if no Drawer fragment has updated the tile area. Floors contain all the entities
within them, registered in:</p>
<ul>
<li><code>UFOW_Drawer_Shared</code> for <code>UFOW_DrawingEntity_Interface</code>, with the base class defined in <code>FOW_LayerSetting</code></li>
<li><code>UFOW_CollisionHandler</code> (static/dynamic) for <code>UFOW_CollisionEntity_Interface</code>, with the base class defined in <code>AFOW_Handler</code></li>
<li><code>UFOW_EntityVisibilityHandler</code> (static/dynamic) for <code>UFOW_VisibilityEntity_Interface</code>, with the base class defined in <code>AFOW_Handler</code></li>
</ul>
<h3 id="settings-1"><a class="header" href="#settings-1">Settings</a></h3>
<p>You'll find a few settings to configure the floors in your environment:</p>
<ul>
<li><code>FloorLocation</code>: defines the center of the floor.</li>
<li><code>FloorExtend</code>: defines the 2D extent of the floor.</li>
<li><code>FloorZExtend</code>: Represents the height of the fog. X represents the fog under the floor center, and Y represents the fog above the floor center.</li>
<li><code>bOverrideChannelToClearAtStart</code>: Allows you to override the <code>FOW_Handler</code> setting of the fog state at start.</li>
<li><code>bSnapFloorExtendToGrid</code>: Snaps the floor extent to the tile grid.</li>
</ul>
<h3 id="fog-update"><a class="header" href="#fog-update">Fog Update</a></h3>
<p>Every update is called by the handler, with four main updates:</p>
<ul>
<li><code>UpdateCollision</code>: done during <code>FOWUpdate_Begin</code> by the <code>UFOW_CollisionHandler</code></li>
<li><code>UpdateFogState</code>: done during <code>FOWUpdate_End</code></li>
<li><code>UpdateVisibleEntityState</code>: done during <code>FOWUpdate_End</code> by the <code>UFOW_EntityVisibilityHandler</code></li>
<li><code>UpdateFogTextureSample</code> or <code>GetFogTextureSampleRegions</code>: done during <code>UpdateTexture</code>. This update is special and cannot be changed; it's
bound to <code>FWorldDelegates::OnWorldTickEnd</code> to ensure the position of every game camera.</li>
</ul>
<p>The fog state is a heavy update which merges fog fragments of every Drawer. To achieve this, both the fragment and the floor's bits
arrays are sliced into tiles. Tiles are instantiated and stored in floors, they all derive from <code>TFOW_Tile_Base</code>. It facilitates the
transformation of Drawer data into a readable texture from the GPU. Each tile receives arrays of pointers linked to Drawer fog fragments;
if the array is empty, the tile is skipped and reset if updated during the previous frame. The fog state generated depends on the
<code>UFOW_LayerSetting</code> bound to the Drawer and by the <code>UFOW_LayerHandler</code>, which provides the update order. The LayerSettings are non-instantiated
classes that convert all their Settings into a flag. They are read by the Tiles and interpreted as the code writer intends. Every modification
regarding channel behavior or computation will require another Tile class.</p>
<h4 id="visual-representation-of-the-updates-pipeline-1"><a class="header" href="#visual-representation-of-the-updates-pipeline-1">Visual Representation of the Updates Pipeline</a></h4>
<p><img src="book/architecture/../../assets/Architecture/Floor/FloorUpdate.drawio.png" alt="Floor update pipeline" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="book/architecture/Layers.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Layers.html#layer-settings">Layer Settings</a>
<ul>
<li><a href="book/architecture/Layers.html#rasterizer">Rasterizer</a></li>
<li><a href="book/architecture/Layers.html#shared-drawer">Shared drawer</a></li>
<li><a href="book/architecture/Layers.html#shared-drawer-max-entities">Shared drawer max entities</a></li>
<li><a href="book/architecture/Layers.html#inverse-bits">Inverse bits</a></li>
<li><a href="book/architecture/Layers.html#static-drawer">Static drawer</a></li>
<li><a href="book/architecture/Layers.html#transient">Transient</a></li>
</ul>
</li>
<li><a href="book/architecture/Layers.html#layer-handler">Layer Handler</a>
<ul>
<li><a href="book/architecture/Layers.html#collision-drawing">Collision drawing</a></li>
<li><a href="book/architecture/Layers.html#computation-order-layer-class">Computation order layer class</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h2>
<p>Layers are the representation of a rendering pipeline. they define how a fog fragment impact the fog state
and are applied in a given order. The <code>UFOW_LayerSetting</code> will be the class used by every drawer tp define
their behavior. The <code>UFOW_LayerHandler</code> is held by the <code>FOW_Handler</code> and will be the pipeline reference for
every fog state update.</p>
<h3 id="layer-settings"><a class="header" href="#layer-settings">Layer Settings</a></h3>
<p>There isn't any logic, except converting settings to a flag mask, in the <code>LayerSettings</code>. They have been
made to simplify the pipeline understanding, to help when custom configurations are needed and to enable
or disable optimization.</p>
<p>About the generated settings flags, you have to understand that they mean nothing without a <code>TFOW_Tile_Base</code>
able to read it. The flag mask is an <code>int32</code> with only 4 bits used. This means that you have the possibility
to create other settings to provide to the <code>Tiles</code> if you want to create new channels or if other conditions
are needed for your fog to be computed.</p>
<h4 id="rasterizer"><a class="header" href="#rasterizer">Rasterizer</a></h4>
<p>The <code>Rasterizer Class</code> lets you choose which rasterizer will be used by the <code>Drawer</code> for the fog fragment
generation. Depending on the situation, a specialized rasterizer can be a real gain and improve the performance.
As an example, two rasterizers are provided in the plugin:</p>
<ul>
<li><code>UFOW_R_TriangledGeometryV1</code>: used to rasterize convex geometry with the vertices correctly sorted.</li>
<li><code>UFOW_R_CircleV1</code>: used to rasterize circles only. It will read geometries one vertex by one and use them as a <code>2D position</code> and a <code>Radius</code>.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/12_RasterizerUsage.png" alt="Layers" /></p>
<p>Rasterizers define how geometry will need to be provided. You can create others to fit specific cases or to
optimize the rasterization process.</p>
<h4 id="shared-drawer"><a class="header" href="#shared-drawer">Shared drawer</a></h4>
<p>The <code>Shared Drawer Class</code> allows you to choose which drawer class will be used for the update of Entities.
The Drawer will then be instantiated and contained by a <code>Floor</code>. Every Entity contained in the floor will be
provided to this drawer, which will ensure the generation of the fog fragment. There are 3 kinds of shared drawers:</p>
<ul>
<li><code>UFOW_Drawer_Shared</code>: will query geometry from entities and rasterize it on the fog fragment. Use <code>UFOW_R_TriangledGeometryV1</code> as Rasterizer.</li>
<li><code>UFOW_SDrawer_Circle</code>: will query geometry from entities, however, it's designed to receive a single vertex per entity to draw a circle. Use <code>UFOW_R_CircleV1</code> as Rasterizer.</li>
<li><code>UFOW_SDrawer_FOV</code>: will query position from the entities to compute shadow geometries from the <code>CollisionHandler</code>. Then, every shadow is rasterized. Use <code>UFOW_R_TriangledGeometryV1</code> as Rasterizer.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/8_SharedDrawerPresentation.png" alt="Layers" /></p>
<p><code>Shared drawer</code> is responsible for querying data from geometries and to provide it to the rasterizer. They will
also be responsible for choosing how the fog fragment will be computed:</p>
<ul>
<li>Game thread</li>
<li>Game thread with parallel for</li>
<li>Task</li>
<li>Compute shader (Not provided yet)</li>
</ul>
<p>You are free to create others to improve or make them fit to your game pipeline.</p>
<h4 id="shared-drawer-max-entities"><a class="header" href="#shared-drawer-max-entities">Shared drawer max entities</a></h4>
<blockquote>
<p><strong>This setting only makes sense if multithreading or compute shader are enabled.</strong></p>
</blockquote>
<p>The <code>Shared drawer max entities</code> value is an optimization variable. It is used to limit the numbers of entity
per <code>Shared Drawers</code>. The meaning behind this isn't that your game will have a limited number of entities but
that another drawer will be instantiated if one is full. This will allow the system to create many tasks instead
of only one if you have lots of entities sharing the same <code>LayerSettings</code>.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/15_SharredDrawerMaxEntity.png" alt="Layers" /></p>
<p>If you let the variable be 0 or less, <code>Shared Drawers</code> won't have entities limit and will be updated like so:</p>
<ul>
<li>The red square represents 2400 drawers computed in 1 thread.</li>
<li>The green square represents the start of the fog fragments generation.</li>
<li>The blue square represents the end of the fog fragments generation.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/15_1_SharredDrawerMaxEntity_0.png" alt="Layers" /></p>
<p>If you increase the limits (500 was used for the example), multiple <code>Shared Drawers</code> will be instantiated
and your computer will take benefit of the other cores in the processor:</p>
<ul>
<li>The red square represents 2400 drawers computed in 5 threads.</li>
<li>The green square represents the start of the fog fragments generation.</li>
<li>The blue square represents the end of the fog fragments generation.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/15_2_SharredDrawerMaxEntity_500.png" alt="Layers" /></p>
<blockquote>
<p><strong>Caution, update task might become too present to let the Engine start its own. It might be more interesting
to accept lots of entity per drawer which might reduce the fog state refresh rate instead of the whole game frame
rate.</strong></p>
</blockquote>
<h4 id="inverse-bits"><a class="header" href="#inverse-bits">Inverse bits</a></h4>
<p>The <code>Inverse bits</code> is a parameter for the rasterizer. This will tell the rasterizer to draw the geometry with 0
instead of 1. It is only used when geometry shadows need to be represented. Those drawers will entirely reveal
their fog fragment and hide parts with collision geometry. There's no need to understand what it really does,
just turn it on if the drawer will cast shadows.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/16_InverseBitsUsage.png" alt="Layers" /></p>
<h4 id="static-drawer"><a class="header" href="#static-drawer">Static drawer</a></h4>
<p>The <code>Static drawer</code> value is an optimization variable. By setting it to true, you tell the system that all entities
provided won't move. This means that the entities will generate their fog fragment only once until one of them moves
or if an Entity is added or removed. This parameter is mostly used by the collider to reduce the number of triangles
rasterized to represent their shadows.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/9_StaticDrawersUsage.png" alt="Layers" /></p>
<h4 id="transient"><a class="header" href="#transient">Transient</a></h4>
<p>It simplifies the implementation of one or a few frame drawing drawers. It's often heavy to write delegate and bind
to the system to ensure at least one update. With this enabled, the system will try to destroy the associated drawer
every frame.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/10_TransientDrawersUsage.png" alt="Layers" /></p>
<p>You might not want to draw for only one frame, in that case, you can override <code>RequestDestruction</code> in CPP and BP to
add a timer or verify a condition before calling <code>DestroyAndUnregister</code>.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/11_TransientDrawersDestructionOverride.png" alt="Layers" /></p>
<h3 id="layer-handler"><a class="header" href="#layer-handler">Layer Handler</a></h3>
<p>Layer Handler is a class made for global settings regarding the update pipeline of the fog state.</p>
<h4 id="collision-drawing"><a class="header" href="#collision-drawing">Collision drawing</a></h4>
<p>The <code>Collision drawing</code> is an optimization variable. It's disabled by default because of the issues it can bring to
the render. If enabled, all colliders will have the possibility to draw their collision geometry to a <code>Shared Drawer</code>,
only if <code>ShouldBeDrawn</code> is set to true in your <code>CollisionEntity</code>.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/13_LayerHandlerDrawCollider.png" alt="Layers" /></p>
<p>The problem behind this optimization is that the collider will always display their shadow even if you are over them.
It'll be mostly annoying for games with verticality.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/14_LayerHandlerDrawColliderIssue.png" alt="Layers" /></p>
<p>To resume, if your game doesn't use fog verticality, you're advised to enable it.</p>
<h4 id="computation-order-layer-class"><a class="header" href="#computation-order-layer-class">Computation order layer class</a></h4>
<p>The <code>Computation order layer class</code> array will define the update order of the fog fragment. All of them are bound to
a <code>LayerSettings</code> and need to be merged to update the fog state. This array lets you modify the merging order. All of
the <code>LayerSettings</code> used in your game have to appear in this list or you will trigger an ensure. Be careful when re-ordering
it, you might create unwanted results if you don't pay attention between layers removing fog and layers adding fog.</p>
<h2 id=""><a class="header" href="#"><img src="book/architecture/../../assets/Architecture/Layers/17_LayerHandlerComputationOderClass.png" alt="Layers" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">Network</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of contents</a></h2>
<ul>
<li><a href="book/architecture/Network.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Network.html#network-settings">Network Settings</a></li>
<li><a href="book/architecture/Network.html#fog-state-replication">Fog State Replication</a>
<ul>
<li><a href="book/architecture/Network.html#server">Server</a></li>
<li><a href="book/architecture/Network.html#client">Client</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="book/architecture/Network.html#what-is-replicated">What is Replicated</a></li>
<li><a href="book/architecture/Network.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h2>
<p>The <code>Layered Fog of War</code> is ready for online games but requires a good understanding of the <code>replication</code> provided by Unreal,
and how the <code>LFOW</code> uses it. To begin with, the <code>Fog State</code> isn't replicated; it can be synchronized to the client, but the
<code>LFOW</code> will never continually send fog data over the network.</p>
<p>The <code>LFOW</code> relies on the <code>simulation</code>, ensuring the state of the <code>server</code> and the <code>client</code> remains the same as long as the
position of the drawer is replicated and correctly updated. In case of latency or client disconnection, the <code>LFOW</code> server can,
as mentioned earlier, synchronize and send the fog state through <code>RPC</code> to the <code>clients</code>.</p>
<p>The plugin includes the concept of <code>teams</code>, which can be seen as data duplication. If the <code>LFOW</code> is set up with 2 channels and
3 teams, it will use 6 channels internally. Currently, it can only manage up to 8 channels, which means a maximum of 4 teams
with 2 channels each.</p>
<p>However, many games don't need to synchronize the <code>Fog State</code> and rely only on the <code>simulation</code>. MOBA games like <code>League of  Legends</code> or <code>Dota</code> will only use a single channel to represent what is currently visible. For games using such a setup, the
team limit disappears.<br /></p>
<p>See the <a href="book/architecture//book/architecture/"></a><a href="book/architecture/../Tutorials/Networking.html">Networking turorial</a> for implementation.</p>
<h3 id="network-settings"><a class="header" href="#network-settings">Network Settings</a></h3>
<p>The <code>UFOW_NetworkSettings</code> class is designed to override the <code>FOWHandler</code> variables for online games and set up different
behaviors depending on the <code>Net Status</code>. <code>Server</code>, <code>Client</code>, and <code>Spectators</code> require more or less data to be computed by the
<code>LFOW</code>. For example, a <code>Client</code> only needs to compute the state of its team since it should never see what the opponent sees.
However, the <code>Server</code> needs to store the state of each team in case of client re-synchronization.</p>
<h3 id="fog-state-replication"><a class="header" href="#fog-state-replication">Fog State Replication</a></h3>
<p><code>AFOW_FogStateReplication</code> is the base class for every <code>Online</code> game instance implementing the <code>LFOW</code>. The server will have
its own class and will spawn a new one for every client. It will manage the network used by the plugin, handle connection and
disconnection, and provide useful <code>RPC</code> to synchronize every game instance. For now, it will only attribute a <code>Team ID</code> to
every client which is <code>replicated</code> and provide methods to synchronize the Fog through <code>RPC</code> if needed.</p>
<h4 id="server"><a class="header" href="#server">Server</a></h4>
<p><code>AFOW_FogStateReplication_Server</code> handles all client connections and provides a <code>Team ID</code> to every <code>AFOW_FogStateReplication_Client</code>.
To gain full control of the IDs distributed, you can override <code>GetClientTeamIndex</code>, allowing you to return any value. See the
<code>Networking</code> tutorial for more information. If the fog is replicated, be aware that any team ID higher than the maximum team limit won't work.<br />
You will find two multicast methods that I've written as examples. I'm not sure of their efficiency, so please don't use them:</p>
<ul>
<li><code>MulticastRPC_AddDrawer</code>, deprecated</li>
<li><code>MulticastRPC_RemoveDrawer</code>, deprecated</li>
</ul>
<h4 id="client"><a class="header" href="#client">Client</a></h4>
<p><code>AFOW_FogStateReplication_Client</code> lets you override a few methods to insert or call whatever you want between the connection steps.
The <code>ServerRPC_RequestFogStateSynch</code> RPC lets you request the server to synchronize the fog state if replication has been enabled
in the network settings. You will find a few parameters to manage automatic synchronization or the cooldown time between requests:</p>
<ul>
<li><code>MinimumTimePerFrameBeforeSynch</code>: The refresh rate threshold in ms before the automatic request of the FOW sync to the server.
Set a large timer if you don't want automatic sync.</li>
<li><code>SynchRequestCooldown</code>: Cooldown to prevent the client from DDOSing the server.</li>
</ul>
<h2 id="what-is-replicated"><a class="header" href="#what-is-replicated">What is Replicated</a></h2>
<p>Since the fog state is not continuously replicated but merely synchronized and then simulated, you might wonder what is actually
replicated. Only two concepts use replication to allow a fast implementation of the plugin:</p>
<ul>
<li><code>Client Team ID</code>: This important value is used to request the correct fog channels from the <code>Server</code> when synchronization is required.
It is also necessary to attribute a <code>team ID</code> to anything modifying the fog.</li>
<li><code>Drawing Components Team ID</code>: Every drawing component's team ID will be replicated and can be changed by the server without worrying about the network stack.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The <code>LFOW</code> plugin replication implementation is very lightweight and doesn't provide much assistance for the development of
online games. The main reason for this light implementation is to avoid overloading the bandwidth and to prevent forcing its
use, as many games like <code>RTS</code> use <code>simulation</code> to avoid the <code>replication</code> of thousands of units. This means that <code>developers</code> will
need to implement events themselves to control the status of the <code>Components</code> and <code>Entities</code>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-template"><a class="header" href="#game-template">Game Template</a></h1>
<p>Here you will find all the templates provided to make games with the LFOW.</p>
<blockquote>
<p><strong>/!\ The links below apparently don't work. I'm trying to figure it out. Please use the links on the left. <br /></strong></p>
</blockquote>
<h1 id="pages-2"><a class="header" href="#pages-2">Pages</a></h1>
<ul>
<li><a href="book/Template//book/Template/MOBA.html">MOBA Template</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moba-template"><a class="header" href="#moba-template">MOBA Template</a></h1>
<ul>
<li><a href="book/Template/MOBA.html#migration">Migration</a></li>
<li><a href="book/Template/MOBA.html#explanation">Explanation</a></li>
</ul>
<p>This tutorial is about making an online MOBA game with the <code>LFOW</code> enabled. I've created a lightweight template for you to migrate to your current project under UE5.4.
You will find the template folder in the content folder provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a> <br />
The template includes:</p>
<ul>
<li>Create/Join game lobby.</li>
<li>Team selection lobby.</li>
<li>ARAM-like map with the fog enabled for 2 teams.</li>
</ul>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<p>Use this template in your project by following these steps.<br/>
First, ensure that the Layered Fog of War plugin is correctly installed and enabled.</p>
<p><img src="book/Template/../../assets/Tutorial/Network/14_PluginEnabled.png" alt="MOBATemplatePictures" /></p>
<p>Go to the <code>MOBATemplate</code> folder in the <code>Demo Project</code>, right-click on it, and select <code>Migrate</code>.</p>
<p><img src="book/Template/../../assets/GameTemplate/MOBA/0_MigrateMobaTemplate.png" alt="MOBATemplatePictures" /></p>
<p>A window will open and allow you to select what you want to migrate. Be very careful to select only what's under the <code>TemplateProject</code>.<br/>
If you've created an empty project, you can also export the <code>Character</code> and the <code>Cursor</code>. Unreal will then ask you for the content folder of your <code>New Project</code>.</p>
<p><img src="book/Template/../../assets/GameTemplate/MOBA/1_SelectFIlesToMigrate.png" alt="MOBATemplatePictures" /></p>
<p>In your <code>New Project</code>, open the <code>Project Settings</code> and change the <code>GameInstance</code> to <code>BP_MT_GameInstance</code>.</p>
<p><img src="book/Template/../../assets/GameTemplate/MOBA/2_ChangeTheGameInstance.png" alt="MOBATemplatePictures" /></p>
<p>Still in the <code>Project Settings</code>, add the 3 maps provided to the list of maps to include for packaging:</p>
<ul>
<li><code>MT_GameCreation_Map</code></li>
<li><code>MT_TeamSelection_Map</code></li>
<li><code>MobaAram_Map</code></li>
</ul>
<p><img src="book/Template/../../assets/GameTemplate/MOBA/3_AddLobbyAndGameMapToBuild.png" alt="MOBATemplatePictures" /></p>
<p>Finally, set the <code>NetMode</code> to <code>PlayStandalone</code> and add some players. Hit the play button to <code>Create</code> and <code>Join</code> a game.</p>
<p><img src="book/Template/../../assets/GameTemplate/MOBA/4_OpenGameCreation_Standalone.png" alt="MOBATemplatePictures" /></p>
<h2 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h2>
<p>The template has been made to allow fast implementation of the <code>LFOW</code> with network support enabled. The initialization pipeline in Unreal can be troublesome,
especially when adding additional layers like a plugin. The <code>LFOW network</code> setup assigns players during their connection, which is helpful for the plugin
pipeline but might seem too fast and, without the correct knowledge, could become an issue.<br /></p>
<p>To make this pipeline work correctly, three external elements are needed:</p>
<ul>
<li><code>GameMode</code>: Used to detect when a pawn is controlled and to set up the <code>FogTeam</code> and <code>Location</code>.</li>
<li><code>GameState</code>: Used to get the <code>FOWHandler</code>.</li>
<li><code>GameInstance</code>: Used to associate the client's <code>UniqueNetID</code> with a <code>Team</code>.</li>
</ul>
<p>A <code>PlayerState</code> element will also be necessary, but only during the <code>Lobby</code> phase. It will be responsible for communication between the server and the client
using RPC functions.</p>
<p>Regarding the <code>LFOW</code>, only two elements will need to be created:</p>
<ul>
<li><code>FOW_NetworkSettings</code>: To provide a server class, set the team number, and determine if the fog needs to be replicated.</li>
<li><code>FOW_FogStateReplication_Server</code>: To override <code>GetClientTeamIdx</code> and correctly get the client's <code>Team</code> based on the <code>UniqueNetID</code>.</li>
</ul>
<p>Don't forget to copy and use the files from the template for the development of your project!</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>Here we will showcase the step-by-step process of basic usage of the Layered Fog Of War - both for C++ and Blueprint
implementation. If you want to be in the same condition as the pictures are, you can download my
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a> and use the map in the tutorial folder. <br />
If you need help installing the plugin, you can watch this <a href="https://www.youtube.com/watch?v=B9pieujL91c">Video</a>.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-3"><a class="header" href="#pages-3">Pages</a></h1>
<ul>
<li><a href="book/Tutorials//book/Tutorials/First_set_up.html">First set up</a></li>
<li><a href="book/Tutorials//book/Tutorials/FogChannels.html">Fog Channels</a></li>
<li><a href="book/Tutorials//book/Tutorials/Floor_Verticality.html">Floor and Verticality</a></li>
<li><a href="book/Tutorials//book/Tutorials/Layers.html">Layers</a></li>
<li><a href="book/Tutorials//book/Tutorials/Minimap.html">Minimap</a></li>
<li><a href="book/Tutorials//book/Tutorials/Networking.html">Networking</a></li>
<li><a href="book/Tutorials//book/Tutorials/Outdoor_Indoor.html">Outdoor Indoor</a></li>
<li><a href="book/Tutorials//book/Tutorials/PluginAPI.html">PluginAPI</a></li>
<li><a href="book/Tutorials//book/Tutorials/StealthArea.html">Stealth Area</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-set-up"><a class="header" href="#first-set-up">First set up</a></h1>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="book/Tutorials/First_set_up.html#installation">Installation</a></li>
<li><a href="book/Tutorials/First_set_up.html#set-up-the-fog">Set up the fog</a></li>
<li><a href="book/Tutorials/First_set_up.html#going-further">Going further</a></li>
<li><a href="book/Tutorials/First_set_up.html#set-up-issues">Setup issues</a></li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Minimaps</code> map providen in the demo project.
If not done yet, download the Demo project <a href="https://github.com/gandoulf/LayeredFOW_Demo">Here</a> <br />
Install the plugin in the project, helping video <a href="https://www.youtube.com/watch?v=B9pieujL91c">Here</a> <br /></p>
<h2 id="set-up-the-fog"><a class="header" href="#set-up-the-fog">Set up the fog</a></h2>
<blockquote>
<p><strong>/!\ The <code>FOWHandler</code> will use the camera on the <code>Controlled Pawn</code> for the Post Process. If your game has a
different setup for the camera, open the <code>BP_FOW_Handler</code> and tweak the code to correctly find the game camera.<br /></strong></p>
</blockquote>
<p>This part will explain how to use the Fog Of War in the easiest and fastest possible way!</p>
<p>Drag and drop a <code>BP_FOWHandler</code> from the quickly add button, keyboard is enabled to allow you fast search</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/1_DragAndDropFOWHandler.png" alt="FOWHandler update pipeline" /></p>
<p>Once in your scene you will see two boxes:</p>
<ul>
<li>Yellow one, representing the Fog in 3D</li>
<li>Pink one, representing the fog aligned to the tile grid</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/2_DragAndDropFOWHandler_Result.png" alt="FOWHandler update pipeline" /></p>
<p>Add a <code>FOW_Drawer_FOV</code> to the BP_TutorialCharacter</p>
<blockquote>
<p><strong>Note that the <code>FOW_Drawer_FOV</code> is an effective solution if you have a few instances of it. If you plan to have more
than 20 drawing objects, consider using <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/entities/Drawing_Entity.html">FOW_DrawingEntity_FOVComponent</a>, which perform significantly faster. <br /></strong></p>
</blockquote>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/3_AddDrawerToTheCharacter.png" alt="FOWHandler update pipeline" /></p>
<p>Hit the play button for the first preview of the FOW !!</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/4_PlayGameWithFog.png" alt="FOWHandler update pipeline" /></p>
<p>Now that the FOW is running we're gonna add collision to limit the sight of character.
Add <code>FOW_CollisionEntity_BoxComponent</code> to the four walls in the map</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/5_AddCollisionToWall.png" alt="FOWHandler update pipeline" /></p>
<p>You will have to reset the scale of the box collision to 1 to make them fit to the asset</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/6_ResetCollisionScaleTo1.png" alt="FOWHandler update pipeline" /></p>
<p>Boxes are cool but might be a bit limited, let's see how to do otherwise
Add <code>FOW_CollisionEntity_CustomComponent</code> to the cylinder in the map.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/7_AddCustomCollisionToWall.png" alt="FOWHandler update pipeline" /></p>
<p>In the details panel, select the component and Add 8 vertices to the <code>CustomGeometryVertices</code> array.
Position the vertices in top view such as they fit to the object, grid snapping might be annoying.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/8_AddVerticesToYourCustomCollider.png" alt="FOWHandler update pipeline" /></p>
<p>You can hit the play button again and see that the cylinder collision is projected!</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/8.1_CollistionAreCasted.png" alt="FOWHandler update pipeline" /></p>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>If you are setting up the FOW for a custom map you can change the size and position of the floor
in BP_FOWHandler in the details panel. You can also add other floors to extend your game however
you want. check the <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/Floor_Verticality.html">Floor page</a> for more information to set up the fog in your level.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/9_AdapteTheFOWToYourGame.png" alt="FOWHandler update pipeline" /></p>
<p>The base radius of the <code>FOW_Drawer_FOV</code> component might be too small, don't hesitate to change it
in the actor holding the component. Modify the <code>DrawerRadius</code> value to provide a larger sight to your units.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/10_ChangeRadiusSize.png" alt="FOWHandler update pipeline" /></p>
<p>You can change the fog precision of the FOW in the <code>BP_FOW_Handler</code> by going in the details panel
and by changing the <code>PixelSize</code> value. By default, the fog pixel is set to 25 centimeters</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/11_Chance_the_fog_precision.png" alt="FOWHandler update pipeline" /></p>
<h1 id="setup-issues"><a class="header" href="#setup-issues">Setup issues</a></h1>
<p>If you import the plugin to an existing project, you might encounter rendering issues, and the fog won't appear.
The problem arises from the <code>BP_FOW_Handler</code> PostProcess initialization. By default, it attaches the PostProcess
to a camera present on the <code>Controlled Pawn</code> or to the first <code>PostProcessVolume</code> found.</p>
<p>To solve this issue, you can change the Blueprint code or simply create a new Blueprint inheriting from <code>FOW_Handler_Default</code>.
Once created, you will just need to override the <code>Begin Play</code>, write your logic, and replace the <code>BP_FOW_Handler</code> present in
your scene with the new one.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/12_FOW_Handler_PostProcess.png" alt="FOWHandler update pipeline" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-of-war-entities"><a class="header" href="#fog-of-war-entities">Fog of War Entities</a></h1>
<p>The entities system is used by default as a solution to memory fragmentation causing heavy updates. It has
been designed with this fact in mind but also to allow anything to be part of the FOW. Entities are collected
and stored under containers to keep required data for the system update. They inherit from <code>UFOW_Entity_Interface</code>,
which is a <code>UInterface</code>. I'm using the Unreal interface implementation to allow callable functions for Blueprint-only
users. The downside of it is that entities have to be at least a <code>UObject</code>.</p>
<p>The Entities can be implemented only on the C++ side. However, many predefined <code>Actor</code> and <code>ActorComponent</code>
are provided with already implemented interfaces. You will find in those derived classes two functions allowing
you to <code>EnableEntity()</code> or <code>DisableEntity()</code> anywhere at any time. There is no other API; they are self-sufficient,
and their updates are managed by the containers.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-4"><a class="header" href="#pages-4">Pages</a></h1>
<ul>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Collision_Entity.html">Collision entity</a></li>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Drawing_Entity.html">Drawing entity</a></li>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Visibility_Entity.html">Visibility Entity</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collision-entity"><a class="header" href="#collision-entity">Collision entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Collision_Entity.html#collision-entity-component">Collision Entity Component</a></li>
<li><a href="book/Tutorials/entities/Collision_Entity.html#collision-entity-cpp-implementation">Collision Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Entities</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<h2 id="collision-entity-component"><a class="header" href="#collision-entity-component">Collision Entity Component</a></h2>
<p>There are multiple <code>CollisionEntity</code> components implementing the <code>IFOW_CollisionEntity_Interface</code>. All collisions
work the same; they store geometry that will be given to a <code>UFOW_CollisionHandler</code>. The handler will then provide
query class to collect collider information. The geometry can be convex and concave; it's only required to correctly
sort the vertices.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/0_SetupCollisionComponentMerged.png" alt="CollisionEntityPicture" /></p>
<p>To use them, add a <code>FOW_CollisionEntity_BoxComponent</code> or <code>FOW_CollisionEntity_CustomComponent</code> to an instanced actor
or to your existing blueprint. I use for the example the box component; if you want to use the custom component to
generate custom collision, you will have to provide vertices.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/2_AddBoxCollisionComponent.png" alt="CollisionEntityPicture" /></p>
<p>Select the <code>FOW_CollisionEntity_BoxComponent</code> and reset the scale to 1.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/3_ResetCollisionBoxScaleToOne.png" alt="CollisionEntityPicture" /></p>
<p>If you take a look at the collision entity settings, you will see that <code>Static/DynamicLayerSettingClass</code> are required.
It's the case because colliders are also <code>DrawingEntities</code>; their geometry can be drawn on a fog fragment by a drawer
as an optimization if <code>ShouldBeDrawn</code> is checked. See the <a href="book/Tutorials/entities//book/Tutorials/entities/../Layers.html">Layer tutorial</a> for more information.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/4_CollisionEntityGeneralParameters.png" alt="CollisionEntityPicture" /></p>
<p>Collisions are subject to heavy update time in every game. It is the same for the FOW; collision takes time to query.
To optimize those queries, we're using acceleration structures that are super fast; however, their update or construction
time might be heavy. To overcome this issue, we split static colliders from dynamic. It's really important for your game
to have actors set correctly to <code>static</code> or <code>movable</code> depending on your needs. Static collision is significantly faster
than dynamic.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/5_SetCollidersMobilityToStatic.png" alt="CollisionEntityPicture" /></p>
<h2 id="collision-entity-cpp-implementation"><a class="header" href="#collision-entity-cpp-implementation">Collision Entity cpp implementation</a></h2>
<p>You can make your own collision component or directly turn your <code>UObject</code> to entities and give them the possibility to
block the sight of drawers. To be done...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-entity"><a class="header" href="#drawing-entity">Drawing entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#drawing-entity-components">Drawing Entity Components</a>
<ul>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#add-entity">Add Entity</a></li>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#setup-fov-entity">Setup Fov Entity</a></li>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#team-mask">Team Mask</a></li>
</ul>
</li>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#drawing-entity-cpp-implementation">Drawing Entity Cpp implementation</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Entities</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<blockquote>
<p><strong>/!\ Entities are designed for optimization. The system behind them will batch updates and improve game performance. It is highly advised to replace drawers with entities. <br /></strong></p>
</blockquote>
<h2 id="drawing-entity-components"><a class="header" href="#drawing-entity-components">Drawing Entity Components</a></h2>
<p>There are multiple <code>DrawingEntity</code> components implementing the <code>IFOW_DrawingEntity_Interface</code>. Three different kinds of them exist for now:</p>
<ul>
<li><code>Geometry drawers</code>: They will pierce fog by rasterizing a given geometry. Used by <code>FOW_DrawingEntity_BoxComponent</code>.</li>
<li><code>Circle drawers</code>: They will pierce fog with a specific rasterizer only able to trace circles. Used by <code>FOW_DrawingEntity_CircleComponent</code>.</li>
<li><code>FOV drawers</code>: They will pierce fog by collecting the colliders to create shadow geometries. Used by <code>FOW_DrawingEntity_FOVComponent</code>.</li>
</ul>
<p>All <code>DrawingEntity</code> work the same; they hold data and the given <code>UFOW_LayerSetting</code> will define how this data will be used to pierce the Fog.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/0_DefaultDrawingSetupMerged.png" alt="DrawingEntityPicture" /></p>
<h3 id="add-entity"><a class="header" href="#add-entity">Add Entity</a></h3>
<p>To use them, add a <code>FOW_DrawingEntity_CircleComponent</code> / <code>FOW_DrawingEntity_BoxComponent</code> / <code>FOW_DrawingEntity_FOVComponent</code> to an instanced
actor or to your existing <code>Blueprint</code>. The default settings of those components are made to pierce the fog.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/1_AddingDrawingCircleToActor.png" alt="DrawingEntityPicture" /></p>
<p>All drawers will have barely the same settings:</p>
<ul>
<li><code>IsEnableAtStart</code>: Define if the entity starts drawing from the BeginPlay or if it will be enabled later by calling <code>EnableEntity()</code>.</li>
<li><code>EntityTeam</code>: Define for which team the entity will be drawing. The team can be changed at runtime by calling <code>SetEntityTeam()</code>.</li>
<li><code>Static/DynamicLayerSettingClass</code>: Define how the drawer will bring modification to the fog. Those can't be changed at runtime.</li>
<li>The advanced section is only necessary for multiple <code>FOW_Floor</code> games. Their behavior will be explained later.</li>
</ul>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/2_DrawingEnitySettingsOverView.png" alt="DrawingEntityPicture" /></p>
<h3 id="setup-fov-entity"><a class="header" href="#setup-fov-entity">Setup Fov Entity</a></h3>
<p>FOV entities are used to simulate the sight of a unit in a top-down game. The <code>FirstSetUp</code> tutorial shows how to add an <code>FOV Drawer</code> and warns about
the performance issues they can cause when too many are used. The <code>FOVEntities</code> provide a solution with the same features as the drawers but run way faster.</p>
<p>In addition to casting shadows, <code>FOVEntities</code> can also have a vision cone. The cone is composed of a circle and a cone, with each entity having customizable settings.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/1_0_FOVDrawer_cone.png" alt="DrawingEntityPicture" /></p>
<p>To enable the vision cone, navigate to the <code>FOW_DrawingEntity_FOVComponent</code> properties and turn on <code>UseDrawerMask</code>. New settings will appear, allowing
you to tweak the shape of the cone:</p>
<ul>
<li><code>MaskCircleRadius</code>: Changes the size of the circle at the origin of the cone.</li>
<li><code>MaskConeRadiusFactor</code>: Offsets the cone from the center of the circle. Clamped between -1 and 1.</li>
<li><code>ConeAngle</code>: Adjusts the field of view (FOV) of the entity.</li>
</ul>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/6_EnableFOVConeMask.png" alt="DrawingEntityPicture" /></p>
<h3 id="team-mask"><a class="header" href="#team-mask">Team Mask</a></h3>
<p>You will find a hidden property if you set the <code>EntityTeam</code> to -1. The <code>TeamMask</code> is a struct composed of an editable string to provide a
mask in binary, and by an int showing the conversion value. Setting the <code>EntityTeam</code> to -1 will update the fog for every team. The binary mask
is here to provide some flexibility if you don't need to update every team.<br/>
For example, if you need to update the fog only for team 3 and 4, the <code>TeamMask</code> will be <code>1100</code>.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/3_DrawingEnitySettingsOverView_TeamMask.png" alt="DrawingEntityPicture" /></p>
<h2 id="drawing-entity-cpp-implementation"><a class="header" href="#drawing-entity-cpp-implementation">Drawing Entity cpp implementation</a></h2>
<p>You can make your own drawing component or directly turn your <code>UObject</code> to entities and give them the possibility to alter the state of the fog. To be done...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-entity"><a class="header" href="#visibility-entity">Visibility Entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#drawing-entity-components">Visibility Entity Components</a>
<ul>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#default-entity">Default entity</a></li>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#fading-entity">Fading entity</a></li>
</ul>
</li>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#visibility-entity-cpp-implementation">Visibility Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Entities</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<h2 id="visibility-entity-components"><a class="header" href="#visibility-entity-components">Visibility Entity Components</a></h2>
<p>This components implement <code>IFOW_VisibilityEntity_Interface</code> and allows your game to change the visibility
of your actors depending on the fog state.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Visibility/0_MergePictureVisibilityComponent2.png" alt="VisibilityEntityComponent" /></p>
<h3 id="default-entity"><a class="header" href="#default-entity">Default entity</a></h3>
<p>To use it, add a <code>FOW_VisibilityEntity_Component</code> to an instanced actor or to your existing Blueprint.
The component will by default hide the actor if it is not in sight.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/1_AddVisibleEntityToActor.png" alt="VisibilityEntityComponent" /></p>
<p>To go a bit further, if you want to apply custom code when the visibility state changes, you can implement
the <code>OnVisibilityChanged</code> event from the component in your Blueprint.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/2_CustomVisibilityUpdate.png" alt="VisibilityEntityComponent" /></p>
<p>By default, the FOW state is returned as a uint8, which doesn't mean much for you, but it is a mask
representing the 8 channels. You can transform it to a more readable enum by calling <code>GetFOWStateFromBits</code>.
Now just switch on the returned enum to apply your custom code. For example, I'm just drawing a debug sphere.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/3_DrawDebugSphereOnVisibilityChanged.png" alt="VisibilityEntityComponent" /></p>
<p>And here you go, a green sphere appears when the actor is revealed, and a red one appears when the player
loses sight of it.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/4_DrawDebugSphereForVisibility.png" alt="VisibilityEntityComponent" /></p>
<p>If the popping render displeases you, you can turn it off by unchecking <code>DisableRenderOutSight</code>. If you
do so, nothing will happen anymore, and you will have to do the magic by yourself, perhaps a material
translucency transition or an explosion?</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/5_DisablePremadeVisibilityEffect.png" alt="VisibilityEntityComponent" /></p>
<h3 id="fading-entity"><a class="header" href="#fading-entity">Fading Entity</a></h3>
<p>The default visibility component might not be sufficient for high-quality rendering. There is an alternative component
that allows a dynamic material to fade in and out. The drawback of this system is that it uses dynamic materials, which
can be slightly heavier on the render pipeline. Let's set up the component in the <code>Tutorial/Maps/TutorialMap_Entities</code> to
create a fade render effect like the one in the feature showcase.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/6_VisibilityEntity_Fading.png" alt="VisibilityEntityComponent" /></p>
<p>Open the <code>BP_VisibleInGameElement_Fade</code> and add a <code>FOW_VisibilityEntity_FadeComponent</code>; it will be responsible for updating
the material parameters throughout the tick (only active when fading).</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/7_AddFadingComponent.png" alt="VisibilityEntityComponent" /></p>
<p>Now, in the <code>Construction Script</code>, add a few nodes to set up the component:</p>
<ul>
<li>Use <code>CreateDynamicMaterialInstance</code> for the StaticMesh and set the <code>Source Material</code> to <code>M_FOW_Visibility_Dithering</code>, which is included in the plugin.</li>
<li>Use the return value to create an array of materials.</li>
<li>Get the <code>Visibility Component</code>, call <code>AddMaterialToFade</code>, and provide the array of materials that need to fade.</li>
</ul>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/8_AddConstructorCode.png" alt="VisibilityEntityComponent" /></p>
<p>If you check the <code>Visibility Component</code> details, you will find the default variables of a <code>Visibility Entity</code> plus two new variables:</p>
<ul>
<li><code>FadeAmount</code>: Allows you to change the fading level in your scene to preview how it will render. This will reset when the game starts.</li>
<li><code>FadeTime</code>: The duration of the fade in/out effect.</li>
</ul>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/9_ComponentSettings.png" alt="VisibilityEntityComponent" /></p>
<p>If you open <code>M_FOW_Visibility_Dithering</code>, you will find all the necessary nodes to replicate this fading effect on any material.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/10_MaterialNodeForFading.png" alt="VisibilityEntityComponent" /></p>
<h2 id="visibility-entity-cpp-implementation"><a class="header" href="#visibility-entity-cpp-implementation">Visibility Entity cpp implementation</a></h2>
<p>You can make your own visibility component or directly turn your <code>UObject</code> into entities and give them
the possibility to react to the Fog state. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-of-war-rendering"><a class="header" href="#fog-of-war-rendering">Fog of War Rendering</a></h1>
<p>The FOW rendering is managed by a <code>Material</code> and its <code>Collection</code>. Many materials can be instantiated and must be associated with a
<code>TextureSample</code> to be correctly updated. The <code>Material</code> is responsible for all computations, and the <code>Collection</code> allows users to
tweak the render. It is provided with many <code>Console Variables</code> that can change the collection settings' values at runtime.</p>
<blockquote>
<p><strong>/!\ The links below apparently don't work. I'm trying to figure it out. Please use the links on the left. <br /></strong></p>
</blockquote>
<h1 id="pages-5"><a class="header" href="#pages-5">Pages</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering//book/Tutorials/Rendering/HeatTexture.html">Heat Texture</a></li>
<li><a href="book/Tutorials/Rendering//book/Tutorials/Rendering/Material.html">Post Process</a></li>
<li><a href="book/Tutorials/Rendering//book/Tutorials/Rendering/MaterialOpacity.html">Material Opacity</a></li>
<li><a href="book/Tutorials/Rendering//book/Tutorials/Rendering/Stencil.html">Stencil</a></li>
<li><a href="book/Tutorials/Rendering//book/Tutorials/Rendering/Teams.html">Teams</a></li>
<li><a href="book/Tutorials/Rendering//book/Tutorials/Rendering/ToggleRender.html">Toggle Render</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heat-texture"><a class="header" href="#heat-texture">Heat Texture</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering/HeatTexture.html#enable-heat-texture">Enable Heat Texture</a></li>
</ul>
<p>This tutorial is about enabling heat texture. No prerequisites are needed; you can use any map that you want.</p>
<h2 id="enable-heat-texture"><a class="header" href="#enable-heat-texture">Enable Heat Texture</a></h2>
<p>The FOW uses binary textures to store the <code>Fog State</code>. It's super fast to generate and update; however, there is a loss
of granularity. it's either visible or notvisible, but there is no in between of those two states. To overcome this issue, a <code>Heat Texture</code>
can be computed during the <code>Tile Merging</code>. To generate this texture, each bit will be converted to a float and multiplied by
an increasing or decreasing value to create a lerp between two states. The fog render will be smoother when the units are moving.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/HeatTexture/0_0_MovementPlusHeatTexture.png" alt="HeatTexturePictures" /></p>
<p>The <code>Heat Texture</code> is really simple to enable. You just have to toggle on <code>EnableFogHeatTexture</code> in the FOW Handler. Once enabled,
you will find a few parameters for the texture update:</p>
<ul>
<li><code>FogRevealHeatPropagationSpeed</code>: the transition speed when the fog is being revealed.</li>
<li><code>FogUnrevealHeatPropagationSpeed</code>: the transition speed when the fog is being unrevealed.</li>
<li><code>FogHeatTextureChannels</code>: choose which channel will use the <code>HeatTexture</code>.</li>
</ul>
<blockquote>
<p><strong>/!\ The <code>Heat Texture</code> provides a smoother render but is heavier to update. It's recommended to enable this only for the channels
that change their state often. <br /></strong></p>
</blockquote>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/HeatTexture/1_HeatTextureParameter.png" alt="HeatTexturePictures" /></p>
<p>Once the <code>Heat Texture</code> is enabled, you have the option to toggle it on and off by using the console command <code>FOW.r.EnableHeatTexture</code>.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/HeatTexture/2_HeatTextureCommands.png" alt="HeatTexturePictures" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="post-process"><a class="header" href="#post-process">Post Process</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering/Material.html#change-fog-render">Change fog render</a></li>
</ul>
<p>This tutorial is about changing the fog render, you can use any map that you want.</p>
<h2 id="change-fog-render"><a class="header" href="#change-fog-render">Change fog render</a></h2>
<p>A FOW is a heavy piece of code, but the rendering is managed by a single material. All the information is sent
via textures, with three currently in use:</p>
<ul>
<li><code>Floor data</code>, holding position, extend, texture offsets</li>
<li><code>Floor fog state</code>, holding the visibility state of the fog</li>
<li><code>Floor fog heat state</code>, allow fog lerp between two frame state (only used if enabled)</li>
</ul>
<p>The material is designed to hide the more difficult parts within material functions to make it less overwhelming,
but you are welcome to read and modify anything you want (though it might be a challenging task).<br/>
The rest of the material should be straightforward and will let you tweak the fog rendering for your projects!</p>
<blockquote>
<p><strong>/!\ The <code>MPP_FOW_Floors</code> is used as default for the tutorial, but you might be using the
<code>MPP_FOW_FloorsTransparency</code> if you are implementing a game with verticallity <br /></strong></p>
</blockquote>
<p>Let's try to change the render of the black fog at first, Open the <code>MPP_FOW_Floors</code>, it should look like this</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Material/1_OpenMPP_FOW_Floors.png" alt="FogRenderPictures" /></p>
<p>Add a <code>Constant4Vector</code> and plug it into the <code>Lerp</code>with a value of 0. Change the constant value of the R channel to 1.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Material/2_ReplacePinA.png" alt="FogRenderPictures" /></p>
<p>Press the play button and see the undiscovered area beeing rendered in red.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Material/3_RedFogRender.png" alt="FogRenderPictures" /></p>
<p>Now let's see how to bring texture to the grey fog:</p>
<ul>
<li>Create a <code>Noise</code> and a <code>Multiply</code> nodes.</li>
<li>Bind the noise and the result, and pin the output from the <code>Lerp</code> to the new <code>Multiply</code>.</li>
<li>Finally pin the result of the <code>Multiply</code> to the entry A of the <code>Lerp</code>.
You may need to increase the 0.1 value from the previous Multiply to 0.5 to correctly see the noisy render.</li>
</ul>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Material/4_MultiplyGreyByNoise.png" alt="FogRenderPictures" /></p>
<p>Press the play button, and see areas in sight being rendered in a noisy grey.</p>
<h2 id="-1"><a class="header" href="#-1"><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Material/5_NoiseFogRender.png" alt="FogRenderPictures" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="material-opacity"><a class="header" href="#material-opacity">Material Opacity</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering/MaterialOpacity.html#vfx-materials">VFX Materials</a></li>
<li><a href="book/Tutorials/Rendering/MaterialOpacity.html#vfx-materials-settings">VFX Materials settings</a></li>
</ul>
<p>This tutorial has been created in the <code>Tutorial/Maps/TutorialMap_VFX</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.
It covers how to change the materials opacity depending on the fog.</p>
<blockquote>
<p><strong>/!\ This setup will work only in <code>Standalone</code> or for the <code>Server</code> in the <code>Editor</code>. Once the game is packed, the client will correctly apply the <code>Opacity Mask</code>. <br /></strong></p>
</blockquote>
<h2 id="vfx-materials"><a class="header" href="#vfx-materials">VFX Materials</a></h2>
<blockquote>
<p><strong>If you don't have the <code>Demo Project</code> you can find the material nodes in the plugin content folder <code>Material/SurfaceMaterial/M_FOW_OpacityMask.uasset</code> <br /></strong></p>
</blockquote>
<p>The fog post-process and visibility component might not be enough to simulate the unit's vision accurately within your game. You might want a pixel-perfect
<code>Opacity Mask</code> based on the fog state for VFX or other materials. By using <code>Texture Assets</code>, it's possible to share the FOW globally across all materials
without creating dynamic instances. This setup makes implementing the opacity mask straightforward.</p>
<p>The tutorial demonstrates spawning particles that are hidden by the fog when they are out of sight. The firework VFX, however, does not include the opacity
mask modification.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/VFX/0_ParticuleSpawning.png" alt="MaterialOpacityPictures" /></p>
<p>In the <code>FOWHandler</code>, go to <code>Settings</code> and look for <code>UseTextureAssets</code>. Enable it, and three texture variables should appear, each pre-set with values. These
<code>Texture Assets</code> are shared across the materials. You'll notice they are 4k textures with specific settings, like grayscale. They are this large because
texture assets cannot be resized in C++, and a worst-case scenario must be used to ensure the <code>FOW</code> performs well in most games.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/VFX/1_UseTextureAssets.png" alt="MaterialOpacityPictures" /></p>
<p>You can now examine the premade <code>FVX_Tutorial_FOW</code> provided and verify that the <code>SpriteRenderer</code> is correctly set with an <code>M_FOW_Default...</code> material. There's
no need for additional setup; only a custom material needs to be specified (the provided materials are copies of the one in the engine).</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/VFX/2_OpenVFX_SetupMaterial.png" alt="MaterialOpacityPictures" /></p>
<p>Next, open the <code>Tutorial/VFX/Material</code> folder and access <code>M_FOW_DefaultRibbon</code> and <code>M_FOW_DefaultSprite</code>. While the materials are slightly different, they follow
the same FOW logic to alter the opacity mask.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/VFX/3_OpenAndUpdateMaterial.png" alt="MaterialOpacityPictures" /></p>
<p>The material code is already present and just needs to be connected to the multiply node. Understanding it fully isn't necessary; the node setup grants access to
the FOW channel output, with the first channel representing <code>Sight</code> and the second representing what has been <code>Seen</code>, ranging from 0 to 1. With these values, it's
easy to create a mask or other effects as desired. You can simply copy and paste the nodes inside the comment for your custom material :)</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/VFX/4_ConnectFogToMultiply.png" alt="MaterialOpacityPictures" /></p>
<p>After reconnecting the nodes, test the tutorial to confirm that VFX inside the bush remains hidden.</p>
<h2 id="vfx-materials-settings"><a class="header" href="#vfx-materials-settings">VFX Materials settings</a></h2>
<p>By default, the provided nodes for the <code>Opacity Mask</code> are configured to soften the fog data using a <code>Blur</code> algorithm and to apply the <code>HeatTexture</code> if it's enabled
in the <code>FOWHandler</code>. These two settings may increase rendering costs. To adjust this, disable them in the <code>MPC_FOWRenderSettings</code> by changing the values of
<code>VFX_bEnableHeatTexture</code> and <code>VFX_bEnableBlur</code>.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/VFX/5_ChangeSettingsMPC.png" alt="MaterialOpacityPictures" /></p>
<p>You can also modify these values at runtime with console commands:</p>
<ul>
<li><code>fow.r.vfx.EnableHeatTexture</code> lets you toggle the Heat Texture on or off.</li>
<li><code>fow.r.vfx.EnableBlur</code> lets you toggle the Blur on or off.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stencil"><a class="header" href="#stencil">Stencil</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering/Stencil.html#custom-depth-render">Custom depth render</a></li>
<li><a href="book/Tutorials/Rendering/Stencil.html#custom-depth-settings">Custom depth Settings</a></li>
</ul>
<p>This tutorial has been created in the <code>Tutorial/Maps/TutorialMap_VFX</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.
It covers how to ignore the fog post-process effect on objects rendered with a custom stencil.</p>
<h2 id="custom-depth-render"><a class="header" href="#custom-depth-render">Custom depth render</a></h2>
<p>While developing your game, you might want certain objects to retain their appearance and ignore the FOW pass. By default, varying this effect by object
is challenging, but custom depth allows it! By modifying a few settings, the GPU will access a new data set, enabling logic per <code>Stencil ID</code>.</p>
<p>The material logic is already configured, so only asset settings need adjustment.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Stencil/0_StencilEnabled.png" alt="StencilPictures" /></p>
<p>First, ensure that the stencil is correctly enabled in your <code>Project Settings</code>. Change the <code>Custom Depth-Stencil Pass</code> to <code>Enable with Stencil</code>.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Stencil/1_EnableStencilForProject.png" alt="StencilPictures" /></p>
<p>Now select your assets and search for depth. You'll find 3 variables to change:</p>
<ul>
<li><code>Render CustomDepth Pass</code>: Enable this to let the stencil render update with the asset's primitive.</li>
<li><code>CustomDepth Stencil Value</code>: Set this to the stencil value the asset will use.</li>
<li><code>Custom Depth Stencil Write Mask</code>: Set to All bits (255).</li>
</ul>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Stencil/2_EnableCustomDepthPass.png" alt="StencilPictures" /></p>
<p>Hit play, and you'll see that the cylinder is unaffected by the grey fog!</p>
<h2 id="custom-depth-settings"><a class="header" href="#custom-depth-settings">Custom depth settings</a></h2>
<p>By default, the FOW is set to ignore fog for assets with a <code>Stencil ID</code> of <code>1</code>. To change this, open <code>MPC_FOWRenderSettings</code> and adjust <code>CustomDepthStencil</code>.
Note: you can disable the stencil logic entirely by setting <code>bEnableCustomDepth</code> to <code>0</code>.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Stencil/3_CustomDepthSettingMPC.png" alt="StencilPictures" /></p>
<p>You can also modify these values at runtime with console commands:</p>
<ul>
<li><code>fow.r.EnableCustomDepth</code> lets you turn the stencil logic On/Off.</li>
<li><code>fow.r.CustomDepthStencil</code> lets you change the stencil ID used by the post-process.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teams"><a class="header" href="#teams">Teams</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering/Teams.html#change-material">Change Material</a></li>
<li><a href="book/Tutorials/Rendering/Teams.html#toggle-teams-render">Toggle Teams Render</a></li>
</ul>
<p>This tutorial explains how to enable teams. No prerequisites are needed; you can use any map that you want.</p>
<p>When creating competitive games, the <code>LFOW</code> duplicates the number of channels by the number of teams. Each client will only compute its team's fog, but
the server will have to compute everything in case a client needs to be re-synchronized. It might be useful for debugging to see what the server has computed
for the other team. For that purpose, you can merge the team fog using a <code>Material</code> and by calling a <code>Console Command</code>.<br />
Another benefit of the team rendering system is that you could create games where players form alliances. It's also possible to imagine a spectator's client
that will be able to select which fog is displayed and analyze the game.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Teams/0_0_TeamMerging.png" alt="TeamsPictures" /></p>
<h1 id="change-material"><a class="header" href="#change-material">Change Material</a></h1>
<p>To enable <code>Teams</code>, you will need to change the material used by your <code>FOW_Handler</code>, Minimap, or anything drawing fog. In the Plugin content, you will find
three material instances:</p>
<ul>
<li><code>MI_FOW_Floors_Teams_Inst</code>: In-game default fog material.</li>
<li><code>MI_FOW_FloorsTransparency_Teams_Inst</code>: In-game fog material for vertical games.</li>
<li><code>MI_FOW_Minimap_Teams_Inst</code>: Minimap default fog material.</li>
</ul>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Teams/1_FOWMaterialsTeam.png" alt="TeamsPictures" /></p>
<p>You can quickly change the material in the <code>FOW_Handler</code> settings by changing the <code>FOWShaderClass</code>. If you are not using verticality, use the <code>MI_FOW_Floors_Teams_Inst</code>.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Teams/2_ChangeHandlerMaterial.png" alt="TeamsPictures" /></p>
<p>Another way to change the material used in-game when making an online game is by changing the <code>FOWShaderClass</code> in the <code>FOW_NetworkSetting</code>. If the material is
set, it will replace what was set by default. Games can have different rendering rights; maybe only the <code>Server</code> can debug teams, or maybe the game will be watchable
by <code>Spectators</code>, and they will be able to choose at runtime which team they want to follow.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Teams/3_OverrideNetworkMaterial.png" alt="TeamsPictures" /></p>
<h1 id="toggle-teams-render"><a class="header" href="#toggle-teams-render">Toggle Teams Render</a></h1>
<p>Once the team materials are set, you can change the displayed team at runtime by calling <code>fow.r.MergeTeamMask</code>. The command uses a binary mask composed of 0s and 1s
to display or not display fog from a team:</p>
<ul>
<li><code>fow.r.MergeTeamMask 00000010</code>: Will display the fog of the second team.</li>
<li><code>fow.r.MergeTeamMask 00000011</code>: Will display the fog of the first two teams.</li>
</ul>
<blockquote>
<p>Note that you can shorten the mask by omitting the <code>0</code>s on the left; those will be automatically filled. <code>fow.r.MergeTeamMask 10</code> works perfectly.</p>
</blockquote>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/Teams/4_MergeTeamMaskCommand.png" alt="TeamsPictures" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toggle-render"><a class="header" href="#toggle-render">Toggle Render</a></h1>
<ul>
<li><a href="book/Tutorials/Rendering/ToggleRender.html#toggle-fog-render">Toggle Fog Render</a></li>
<li><a href="book/Tutorials/Rendering/ToggleRender.html#toggle-fog-channels">Toggle Fog Channels</a></li>
</ul>
<p>This tutorial explains how to use console commands. No prerequisites are needed; you can use any map that you want.</p>
<p>The plugin is provided with <code>Console Commands</code> to tweak the render of the fog at runtime. This tutorial will explain how to enable and disable the render of the FOW.</p>
<h1 id="toggle-fog-render"><a class="header" href="#toggle-fog-render">Toggle Fog Render</a></h1>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/ToggleRender/0_0_EnabledDisableFog.png" alt="ToggleFogPictures" /></p>
<p>You can toggle the render of the FOW on or off by using:</p>
<ul>
<li><code>fow.r.EnableFOWRender 1</code> to enable the render</li>
<li><code>fow.r.EnableFOWRender 0</code> to disable the render</li>
</ul>
<p>The toggle also affects the visible entity, allowing you to debug the objects moving in the fog at runtime.</p>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/ToggleRender/0_EnableFOWRender.png" alt="ToggleFogPictures" /></p>
<h1 id="toggle-fog-channels"><a class="header" href="#toggle-fog-channels">Toggle Fog Channels</a></h1>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/ToggleRender/1_0_FogChannelMerged.png" alt="ToggleFogPictures" /></p>
<p>The FOW works with different channels, and for some debugging, it might be more useful to disable only one channel rather than the entire fog. Since the plugin can have
up to 8 channels, the command uses a binary mask composed of 0s and 1s to enable or disable the channels:</p>
<ul>
<li><code>fow.r.ChannelMask 00000011</code> enables the <code>Seen</code> and <code>Sight</code> channels</li>
<li><code>fow.r.ChannelMask 00000001</code> disables <code>Seen</code> and enables <code>Sight</code> channels</li>
<li><code>fow.r.ChannelMask 00000010</code> enables <code>Seen</code> and disables <code>Sight</code> channels</li>
<li><code>fow.r.ChannelMask 00000000</code> disables the <code>Seen</code> and <code>Sight</code> channels</li>
</ul>
<blockquote>
<p>Note that you can shorten the mask by omitting the <code>0</code>s on the left; those will be automatically filled. <code>fow.r.ChannelMask 10</code> works perfectly.</p>
</blockquote>
<p><img src="book/Tutorials/Rendering/../../../assets/Tutorial/Rendering/ToggleRender/1_ChangeChannelMask.png" alt="ToggleFogPictures" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-channels"><a class="header" href="#fog-channels">Fog Channels</a></h1>
<ul>
<li><a href="book/Tutorials/FogChannels.html#basic">Basic</a></li>
<li><a href="book/Tutorials/FogChannels.html#advanced">Advanced</a></li>
</ul>
<p>This tutorial is based on solo games; everything related to channels needs to be taken with caution when applied to
teams. However, everything works the same; teams will only limit the number of available channels.</p>
<p>For this tutorial use the <code>Tutorial/Maps/TutorialMap_Collider</code> map provided in
the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h2 id="basic"><a class="header" href="#basic">Basic</a></h2>
<p>The FOW has up to 8 configurable channels that you can use. (Be careful with games having teams) The channels may
or may not all be used. For the default setup of the FOW, only two channels are used:</p>
<ul>
<li>The first channel defines what the player currently sees.</li>
<li>The second channel defines what the player has seen.</li>
</ul>
<p>This setup is mostly used for narrative games or RTS with procedural maps, but you might want to make a game more
MOBA-oriented with everything revealed to the players, which means that you only need the first channel to represent
the sight of the player.</p>
<p>Let's change the FOW to have only one channel. First, select the <code>BP_FOW_Handler</code>, go to the details panel and click
on the <code>FOWFloorTilesClass</code> input field, and select <code>TFOW_T128b_1Chan_Pck_Class</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/1_ChangeTileFormat.png" alt="Change Tile Format" /></p>
<p>Still in the <code>BP_FOW_Handler</code> details panel, find the <code>FOWShaderClass</code> variable and open the provided material; it
should be <code>MPP_FOW_Floors</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/2_OpenTheFOWMaterial.png" alt="Open The FOW Material" /></p>
<p>Find the material function with 8 channel output pin and unlink the <code>chan2</code> from the linked <code>lerp</code> node. The <code>Alpha</code>
value should be set to 1.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/3_UnpinBlackChannelSetAlphaTo1.png" alt="Unpin Black Channel Set Alpha To 1" /></p>
<p>You should be done; press play and check that the FOW correctly displays only one channel.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/4_GameWithOnlyOneChannelComputed.png" alt="Game With Only One Channel Computed" /></p>
<p>You might have figured out that only doing the material part would have done the trick, and yes it would have. But you
would have let the FOW do all the computation in CPU and GPU of the <code>Chan2</code>.</p>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<p>In the advanced part, I'll show you how to implement and use more than 2 channels by creating new <code>FOW_Tile_Class</code> and
<code>FOW_LayerSetting</code>. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-and-verticality"><a class="header" href="#floor-and-verticality">Floor and Verticality</a></h1>
<ul>
<li><a href="book/Tutorials/Floor_Verticality.html#add-floors">Add Floors</a></li>
<li><a href="book/Tutorials/Floor_Verticality.html#enable-verticality">Enable Verticality</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Floors</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<blockquote>
<p><strong>The multi-floor feature is in progress and can create undesirable rendering artifacts. Most of them are known and
will be dealt with in the next version. However, you can still prototype your game with it; the system will remain the
same.</strong></p>
</blockquote>
<h1 id="add-floors"><a class="header" href="#add-floors">Add Floors</a></h1>
<p>Floors are the area representation of the fog in the editor. You can add as many as you want, and they are represented
by a yellow rectangle and a pink plane.</p>
<ul>
<li>The rectangle represents the fog area; everything inside will be impacted by fog.</li>
<li>The plane represents the fog extent clamped to tiles. Fog is not constrained to the rectangle for now, but it might
become the case soon. It also dissociates the top from the bottom of the fog when modifying the ZExtend.</li>
</ul>
<p>To add a new floor, select the <code>FOW Handler</code>. In the details panel, find the <code>FOWFloors</code> array and add an element.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/1_AddFloorToMap.png" alt="FloorVerticallityPicture" /></p>
<p>Find the new element, which should be set to <code>None</code>, and change its value to <code>FOW_Floor</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/2_SelectFloorClass.png" alt="FloorVerticallityPicture" /></p>
<p>In the added element, you will find a <code>FloorLocation</code> variable in the settings section, allowing you to change the
position of the floor. Move it so that the other part of the plane is included in the new floor.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/3_MoveTheFloorInY.png" alt="FloorVerticallityPicture" /></p>
<p>As I mentioned, there are currently a few artifacts between floors around the junctions. You can see sharp fog lines
not affected by blur.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/4_UndersirableArtifactsAtIntersection.png" alt="FloorVerticallityPicture" /></p>
<h1 id="enable-verticality"><a class="header" href="#enable-verticality">Enable Verticality</a></h1>
<p>The fog of war is an algorithm used for 2D gameplay and mostly competitive games like MOBA/RTS. It has been a challenge
to open the door to a new kind of game which could take benefits from verticality.</p>
<p>To use verticality in your game, you have to first change the <code>PostProcess</code> used to render the fog. Select the <code>FOW_Handler</code>,
in the details panel find the <code>FOWShaderClass</code> and change the <code>MPP_FOW_Floors</code> to <code>MPP_FOW_FloorsTransparency</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/5_ChangePostProcess.png" alt="FloorVerticallityPicture" /></p>
<p>Still in the <code>FOW_Handler</code>, add 2 new floors and I advise you to change the editor view to <code>Front</code>; it'll simplify the
positioning of the floors. As with the previous floor, you will have to change the <code>FloorLocation</code>. Try to center the
fog plane to the gameplay area in Y and Z.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/6_AddThreeFloorAndMoveYZ.png" alt="FloorVerticallityPicture" /></p>
<p>With the default settings, you should have a gap between your floors, and it's better to not have them. Reach the settings
of each floor and change the <code>Y</code> value of the <code>ZExtend</code>. It'll enlarge the bottom part of the yellow square.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/7_RemoveTheBetweenFloor.png" alt="FloorVerticallityPicture" /></p>
<p>One last thing, many settings are provided to the material and one can generate conflict with verticality. To disable it,
select the <code>FOW_Handler</code>, in the details panel find the <code>MPC_FOWRenderSettings</code> and open it.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/8_OpenMPC_FOWRenderSettings.png" alt="FloorVerticallityPicture" /></p>
<p>Find the <code>bEnableHeightGrading</code> scalar value and set it to 0.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Floors_Verticality/9_RemoveHeightGrading.png" alt="FloorVerticallityPicture" /></p>
<p>As explained at the beginning of this tutorial, the multi-floor rendering is still in progress and the vertical transition
hasn't been properly cleaned.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers-1"><a class="header" href="#layers-1">Layers</a></h1>
<ul>
<li><a href="book/Tutorials/Layers.html#create-and-add-layers">Create and Add Layers</a></li>
<li><a href="book/Tutorials/Layers.html#static-layers-and-optimization">Static Layers and Optimization</a></li>
</ul>
<p>For this tutorial use <code>Tutorial/Maps/TutorialMap</code> or <code>Tutorial/Maps/TutorialMap_Collider</code> map provided in
the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h2 id="create-and-add-layers"><a class="header" href="#create-and-add-layers">Create and Add Layers</a></h2>
<p>This part will explain how <code>LayerSettings</code> work and how you can create new ones for your games. First, you have
to know that they are dissociated to provide different information to the FOW but also to provide a computation
order during the fog fragment merging. It can be compared to a rendering pipeline. To register a new layer, you
will have to create a <code>LayerHandler</code>.</p>
<p>Let's try to change the behavior of the drawer on your character. We want him to reveal only the black fog but
not to give him sight.</p>
<p>Create a new BP_MyLayerHandler derived from <code>FOW_LayerHandler</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/1_CreateLayerHandler_BP.png" alt="Create Layer Handler BP" /></p>
<p>Create a new BP_MyFOVLayer derived from <code>FOW_LayerSettings</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/2_CreateLayerSetting_BP.png" alt="Create Layer Setting BP" /></p>
<p>Open your layer handler and add the new layer you've just created. Add it just under the <code>FOW_FOVLayer</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/3_OpenAndAddNewLayerSetting.png" alt="Open And Add New Layer Setting" /></p>
<p>Now we need to tell the <code>FOW_Handler</code> that we are using a new layer pipeline. Select the <code>BP_FOW_Handler</code> and
change in the details panel, in the class section, the value of the <code>LayerHandlerClass</code> to the one you've created</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/4_ChangeTheLayerHandler.png" alt="Change The Layer Handler" /></p>
<p>Open the blueprint holding the <code>FOVDrawer</code>, select it and go to the detail panel. Scroll to the <code>LayerSettingClass</code>
and replace it with the one you've created</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/5_ReplaceTheLayerSettingClass.png" alt="Replace The Layer Setting Class" /></p>
<p>Now that everything is correctly set, we can change the behavior of the <code>LayerSetting</code>. Open the blueprint, turn
the <code>InverseBits</code> to true (I'm going to ask you to trust me on that, every FOV Layers will need this to be true)
and set the <code>RevealSight</code> to false and <code>RevealFog</code> to true. Doing so will prevent the player from having sight
on <code>VisibilityEntity</code> however the layout will be revealed</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/6_ChangeLayerSettings.png" alt="Change Layer Settings" /></p>
<p>Enjoy your new layer setting! Check out the <a href="book/Tutorials//book/Tutorials/Visibility_entity.html">Visibility Entity page</a> to really understand
the difference between <code>RevealSight</code> and <code>RevealFog</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/7_PiercingOnlySightFog.png" alt="Piercing Only Sight Fog" /></p>
<h2 id="static-layers-and-optimization"><a class="header" href="#static-layers-and-optimization">Static Layers and Optimization</a></h2>
<p>The FOW is a heavy piece of code to update and optimization is present almost everywhere. Sadly optimization can
have counterparts. Static layers can be really interesting to reduce the computation time; it will prevent the
re-generation of a fog fragment (heaviest update) if the drawer and the entities bound to it haven't moved.</p>
<p>The plugin uses static layers only for collision; geometry will be collected and drawn into a fog fragment and be
merged with other fragments during every update. Doing so prevents the sight drawing from using the whole collider
vertices to cast shadow.</p>
<p>To enable this optimization first open your <code>LayerHandler</code> and check the <code>DrawFOWCollider</code> box.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/8_LayerHandlerDrawCollider.png" alt="Layer Handler Draw Collider" /></p>
<blockquote>
<p><strong>Caution, this optimization is really effective for colliders if the owning actor is static.</strong></p>
</blockquote>
<p>This setting provides the possibility for every collider to send its geometry to a <code>SharedDrawer</code>. By default,
every collider is set to do so. You can disable this feature by unchecking <code>ShouldBeDrawn</code> from the <code>CollisionEntity</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/9_DisableColliderEntityDrawing.png" alt="Disable Collider Entity Drawing" /></p>
<p>If the colliders are drawn, the collision shadow will remain even if the collider isn't in sight. <code>ShouldBeDrawn</code>
is enabled on the left and disabled on the right.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/10_CollisionDrawing.png" alt="Collision Drawing" /></p>
<p>It might sound weak as an optimization since there are only 4 vertices in a rectangle. But if you multiply the few
triangles by the number of colliders and by the number of AI, we're talking about milliseconds saved by the update.
It's even more effective for custom collision with a lot of vertices.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimap"><a class="header" href="#minimap">Minimap</a></h1>
<ul>
<li><a href="book/Tutorials/Minimap.html#minimap-setup">Minimap setup</a></li>
</ul>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Minimaps</code> map providen in the
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="minimap-setups"><a class="header" href="#minimap-setups">Minimap setups</a></h1>
<p>The plugin has a minimaliste integration of a minimap. the tutorial will show you how to set it up and the
providen blueprint will give all the necessary knowledge to generate fog sample and link it to a custom material
if you wanna make your own system. <br />
Go into the <code>Plugins/LayeredFogOfWarContent/Minimap</code> folder in the content browser. You will find 4 files:</p>
<ul>
<li><code>BP_FOW_Floor_Minimap</code>, In-game blueprint catching input, instancing and updating Fog sample, Material, Widget.</li>
<li><code>BP_FOW_MapTextureGenerator</code>, An actor with a 2D scene camera to generate map texture of your level.</li>
<li><code>RT_FOW_MapTexture_Output</code>, Render target used by the camera of Map texture generator.</li>
<li><code>WBP_FOW_Minimap</code>, Widget added to the viewport displaying the minimap.</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/1_OpenMinimapFolderFromPlugin.png" alt="MinimapPictures" /></p>
<p>Add the <code>BP_FOW_Floor_Minimap</code> to your scene inside a <code>FOW_Floor</code>. The position of the actor is important because
it will collect the data of the floor it overlappe to send it to the material.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/2_AddFloorMinimap.png" alt="MinimapPictures" /></p>
<p>Add the <code>BP_FOW_MapTextureGenerator</code> to your scene.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/3_AddMapTextureGenerator.png" alt="MinimapPictures" /></p>
<p>Open the <code>RT_FOW_MapTexture_Output</code> which is already linked to the camera of the Map texture generator, it will
display the result of the map.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/4_OpenRenderTargetAndDisableAlpha.png" alt="MinimapPictures" /></p>
<p>Now change the <code>Location</code> and the <code>Camera Width</code> of the <code>BP_FOW_MapTextureGenerator</code> to generate an acccurate picture
of the level.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/5_SetUpPositionAndCameraWith.png" alt="MinimapPictures" /></p>
<p>When the setting are done, find the <code>RT_FOW_MapTexture_Output</code> in your content browser, right click on it and generate
a <code>StaticTexture</code>. Move it to another folder out of the plugin.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/6_CreateStaticTexture.png" alt="MinimapPictures" /></p>
<p>Now you have to copy the settings used to generate the texture to the <code>BP_FOW_Floor_Minimap</code>. They are requiered to
generate a corresponding plane in the material to apply the texture.</p>
<blockquote>
<p><strong>The Z value isn't important; the MinimapPlanLocation will be updated based on the actor's current location. <br /></strong></p>
</blockquote>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/7_ChangeFloorMinimapSettingsMerged.png" alt="MinimapPictures" /></p>
<p>You can now hit the play button and see a minimap on the bottom right. You can display a bigger version by pressing
<code>Tab</code> which will display a full screen version of it.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Minimap/8_DeleteTestAndPressTab.png" alt="MinimapPictures" /></p>
<p>The minimap can handle displacement, rotation, and scaling (zoom). If the minimap doesn't have the correct orientation,
you can apply a static rotation to both the texture and the Fog sample to adjust it accordingly.</p>
<h2 id="-2"><a class="header" href="#-2"><img src="book/Tutorials/../../assets/Tutorial/Minimap/9_AddConstantRotation.png" alt="MinimapPictures" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-1"><a class="header" href="#networking-1">Networking</a></h1>
<ul>
<li><a href="book/Tutorials/Networking.html#default-replication-setup">Default Replication Setup</a>
<ul>
<li><a href="book/Tutorials/Networking.html#gamestate">GameState</a></li>
<li><a href="book/Tutorials/Networking.html#network-settings">Network Settings</a></li>
<li><a href="book/Tutorials/Networking.html#gamemode">GameMode</a></li>
</ul>
</li>
<li><a href="book/Tutorials/Networking.html#manage-player-team">Manage Player Team</a></li>
<li><a href="book/Tutorials/Networking.html#infinite-team">Infinite Team</a></li>
<li><a href="book/Tutorials/Networking.html#network-template">Network Template</a></li>
</ul>
<blockquote>
<p><strong>/!\ This tutorial is made to show how the FOW works with networks, replication knowledge won't be provided.
Networking <code>GameMode</code>, <code>GameState</code>, <code>Controller</code>, and <code>Character</code> are provided. You have absolutely the right to
read, copy, and use any code you find :) <br /></strong></p>
</blockquote>
<blockquote>
<p><strong>/!\ Please take a look at the <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/../architecture/Network.html">Netork Architecture</a> to understand correctly how the LFOW has been replicated<br /></strong></p>
</blockquote>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Networking</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="default-replication-setup"><a class="header" href="#default-replication-setup">Default Replication Setup</a></h1>
<p>The <code>TutorialMap_Networking</code> has been set up to show you how replication and teams work. To do so a
<code>BP_TutorialNetworking_GameMode</code> has been set up with a <code>BP_TutorialNetworking_PlayerController</code> to spawn a
<code>BP_TutorialNetworking_Character</code> at a <code>PlayerStart</code> location depending on the Client team. <br />
To visualize the replication, the server will clear the fog of another spawn point for each team before the
client connection. <br /></p>
<ul>
<li>The circle represents the spawn point</li>
<li>The square is the associated revealed spawn point</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/0_NetworkingMapSetup.png" alt="Networking" /></p>
<p>There is a little trouble with Unreal and singleton instance when they are stored in a static variable. If you
hit the play button with multiple players in the editor, multiple worlds will be created but inside the same
application, which means static variables are shared and overridden. To prevent this, the FOW is designed to look
for an implementation of <code>FOW_GetHandlerInstance_Interface</code> in the <code>GameState</code>. <br /></p>
<h1 id="gamestate"><a class="header" href="#gamestate">GameState</a></h1>
<p>Let's set up the game state. Create a new <code>My_FOWNetworking_GameState</code> derived from <code>GameStateBase</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/1_CreateNewGameState.png" alt="Networking" /></p>
<p>Open it and go into <code>ClassSettings</code> to add the <code>FOW_GetHandlerInstance_Interface</code> in the <code>ImplementedInterfaces</code> array.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/2_AddGetHandlerInterface.png" alt="Networking" /></p>
<p>Now you have to provide the code to the <code>Find_Level_FOWHandler</code>.</p>
<ul>
<li>Add a <code>FOW_Handler</code> variable</li>
<li>Get the variable and convert it to a <code>Validate</code> get, if valid return the variable.</li>
<li>Else find all actors of class <code>FOW_Handler</code></li>
<li>If at least one is returned, set your <code>FOW_Handler</code> variable to the first element of the array</li>
<li>Call the <code>TryInitilization</code> from the <code>FOW_Handler</code></li>
<li>Return the variable</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/3_AddCodeToTheInterfaceMethod.png" alt="Networking" /></p>
<p>Now open the <code>BP_TutoralNetworking_GameMode</code> and replace the <code>GameState</code> with yours</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/4_ChangeDefaultGameState.png" alt="Networking" /></p>
<blockquote>
<p><strong>Note that if you don't simulate the network in the editor, this whole setting isn't needed. As long as
every game instance is a separate process, you don't need to implement the interface.</strong></p>
</blockquote>
<h1 id="network-settings-1"><a class="header" href="#network-settings-1">Network Settings</a></h1>
<p>Now let's see how the FOW works with replication. First, create a new <code>BP_MyNetworkSettings</code> derived from <code>UFOW_NetworkSettings</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/5_MakeNetworkSettingClass.png" alt="Networking" /></p>
<p>Open it and change the <code>NetworkGameMaxTeamNbr</code> value from the <code>Server</code> to <code>4</code>. It means that the <code>FOW_Handler</code> will
be ready to handle 4 different teams drawing fog separately. (For a few reasons, 4 teams with two channels enabled
is the maximum). Also, if you pay attention, the client is set to only one team, which means that only the client
team fog will be updated.<br />
Under those settings, you will find checkboxes to allow or not replication and which channels are replicated. The
first channel isn't needed since it represents the fog of what drawers currently see.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/6_SetUpTheLayerSettings.png" alt="Networking" /></p>
<p>Select the <code>BP_FOW_Handler</code>, get into the details panel, and change the <code>NetworkSettingsClass</code> to your <code>BP_MyNetworkSettings</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/6.1_ChangeFOWHandlerNetworkSettings.png" alt="Networking" /></p>
<p>Before hitting the play button change the <code>PlaySettings</code>. Change the number of players to 4 and change <code>NetMode</code> to <code>PlayAsListenServer</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/7_ChangeTheEditorPlaySettings.png" alt="Networking" /></p>
<p>Now you can hit the play button and see the 4 windows open with your character connecting one by one. If you do not
understand what the fog replication changes, go back to your <code>BP_MyNetworkSettings</code> and uncheck <code>bIsFogStateReplicated</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/8_NetworkingResult.png" alt="Networking" /></p>
<h1 id="gamemode"><a class="header" href="#gamemode">GameMode</a></h1>
<p>The provided <code>GameMode</code> already contains some logic, which may be a bit complicated for a simple setup.
Here you will find a lighter version to manage the player character team. In your custom project, open the <code>GameMode</code>.</p>
<ul>
<li>In the <code>Event Graph</code>, implement the <code>OnPostLogin</code> event and bind a custom event to the <code>OnPossessedPawnChanged</code> event.</li>
<li>Check if the <code>ControlledPawn</code> from the <code>NewPlayer</code> is valid. If it is, call the function you've just bound with the <code>ControlledPawn</code> as the <code>New Pawn</code> parameter.</li>
<li>In the bound event, check if the <code>New Pawn</code> is valid.</li>
<li>If it's valid, get the <code>Controller</code> from it and cast it to <code>PlayerController</code>.</li>
<li>Call <code>GetPlayerControllerTeam</code>.</li>
<li>Plug the result into <code>SetDrawingEntityTeam</code>. You will also need to plug in the <code>Drawing Entity</code>, which will be the <code>NewPawn</code>.</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/8.1_SettupGameModePlayerLogin.png" alt="Networking" /></p>
<blockquote>
<p><strong>Note: You will find the exact same code in the <code>Content/TemplateProject/FOW_Network/BP_FOW_NetworkTemplate_GameMode</code></strong></p>
</blockquote>
<h1 id="manage-player-team"><a class="header" href="#manage-player-team">Manage Player Team</a></h1>
<p>The previous part was about setting up the network over the FOW. However, you couldn't do anything regarding which
client is associated with which team because of the default system distributing the players to each team.</p>
<p>Let's see how to do that. Create a <code>BP_MyFogStateReplication_Server</code> derived from <code>AFOW_FogStateReplication_Server</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/9_CreateNewFogStateReplication.png" alt="Networking" /></p>
<p>Open it and override the <code>GetClientTeamIndex</code> function.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/10_OpenAndOverrideGetClientTeamIndex.png" alt="Networking" /></p>
<p>Open it. This is where you can manage the client team association. the <code>PlayerController</code> is provided, You should
be able to fetch necessary data from your game with it. For the example let's just do this:</p>
<ul>
<li>Get the <code>NetworkMaxTeamNbr</code> and subtract 1 from it</li>
<li>Pin the result to a <code>Random Integer in Range</code></li>
<li>Pin the result to the return;</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/11_AddCustomCodeToGetClientTeamIndex.png" alt="Networking" /></p>
<p>Now that the server is set up, open your <code>BP_MyNetworkSettings</code> and replace the <code>FogStateReplicationClass</code> by your <code>BP_MyFogStateReplication_Server</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/12_ChangeFogStateReplicationClassServer.png" alt="Networking" /></p>
<p>Hit the Play button and see the players being associated with a random team!</p>
<h1 id="infinite-team"><a class="header" href="#infinite-team">Infinite Team</a></h1>
<p>In case you want more than 4 teams with two channels, you can just uncheck <code>bIsFogStateReplicated</code>, Set the
<code>NetworkGameMaxTeamNbr</code> for both client and server to 1 and provide any team index you want in the <code>GetClientTeamIndex</code> override.</p>
<blockquote>
<p><strong>This replicated team number issue will be taken care of; it might not allow an infinite number but more than 4 for sure</strong></p>
</blockquote>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/13_InfinitTeamForNonReplicatedFog.png" alt="Networking" /></p>
<h1 id="network-template"><a class="header" href="#network-template">Network Template</a></h1>
<p>To simplify the creation process of online games, I've created a lightweight template for you to migrate to your current project under UE5.4.
You will find the template folder in the content folder provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a> <br /></p>
<p>First, ensure that the Layered Fog of War plugin is correctly installed and enabled.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/14_PluginEnabled.png" alt="Networking" /></p>
<p>Get to the <code>TemplateProject</code> folder In the <code>Demo Project</code>, right click on the <code>FOW_Network</code> folder and select <code>Migrate</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/15_MigratTheTemplateProject.png" alt="Networking" /></p>
<p>A window will open and will let you select what you want to migrate. Be really cautious to select only what's under the <code>TemplateProject</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/16_SelectEveryFileInFolder.png" alt="Networking" /></p>
<p>Unreal will then ask you the content folder of your <code>New Project</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/17_SelectContentFolder.png" alt="Networking" /></p>
<p>Once done, you will be able to open the <code>FOW_NetworkTemplate</code> map in your <code>New Project</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/18_OpenFOW_NetworkTemplateMap.png" alt="Networking" /></p>
<p>Verify that your editor is correctly setup for network.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/19_TurnOneNetwork.png" alt="Networking" /></p>
<p>Hit the play button and enjoy :)</p>
<h2 id="-3"><a class="header" href="#-3"><img src="book/Tutorials/../../assets/Tutorial/Network/20_HitThePlayButton.png" alt="Networking" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outdoor-indoor"><a class="header" href="#outdoor-indoor">Outdoor Indoor</a></h1>
<ul>
<li><a href="book/Tutorials/Outdoor_Indoor.html#setup-indoor-area">Setup indoor area</a></li>
</ul>
<p>For this tutorial use the <code>Tutorial/Maps/TutorialMap_Collider</code> map provided in
the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h2 id="setup-indoor-area"><a class="header" href="#setup-indoor-area">Setup indoor area</a></h2>
<p>Depending on the game, you might need to dissociate the indoor from the outdoor, such as only the indoors are
undiscovered. From my experience, it's easier to clear the whole FOW and add fog to the indoor area. The next
picture represents the result we will have step by step:</p>
<ul>
<li>
<ol>
<li>FOW display without any setup</li>
</ol>
</li>
<li>
<ol start="2">
<li>FOW display when revealing the whole fog</li>
</ol>
</li>
<li>
<ol start="3">
<li>FOW display after adding the indoor fog</li>
</ol>
</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/0_Fog_Indoor_Outdoor_Example.png" alt="Outdoor Indoor" /></p>
<p>First, get the <code>BP_FOW_Handler</code> and go to the detail panel. Find the <code>ChannelToClearAtStart</code> and check the
<code>chan2</code> box. It will set the default value of the second channel of every floor to 1 to clear the black fog.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/1_ClearFogAtStart.png" alt="Outdoor Indoor" /></p>
<p>Now we're gonna draw back the fog in the 2 indoor areas. There are two types of drawing entities provided to do so:</p>
<ul>
<li><code>FOW_DrawingEntity_Box</code>, drawing fog in a box</li>
<li><code>FOW_DrawingEntity_Custom</code>, drawing fog in the provided custom geometry</li>
</ul>
<p>Drag and drop both of the drawing entities to your scene and let's set up the indoor fog.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/2_AddDrawingEntities.png" alt="Outdoor Indoor" /></p>
<p>First, move the <code>FOW_DrawingEntity_Box</code> to the tiny room and scale it to be as big as the room.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/3_SetUpBoxDrawing.png" alt="Outdoor Indoor" /></p>
<p>Second, move the <code>FOW_DrawingEntity_Custom</code> to the bigger room and add 8 vertices in the <code>CustomGeometryVertices</code>
in the details panel. Select the top view for the viewport and place the vertices around the room.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/4_SetUpCustomDrawing.png" alt="Outdoor Indoor" /></p>
<p>Finally, By default, Drawers will remove fog; however, this time we need to add fog and only when the game starts.
A specific <code>LayerSettings</code> is provided to do so. In both drawing entities, in the details panel, replace the static
and dynamic layer setting class by <code>FOW_FloorStartUpLayer</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/5_ChangeDrawersLayerSettings.png" alt="Outdoor Indoor" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pluginapi"><a class="header" href="#pluginapi">PluginAPI</a></h1>
<ul>
<li><a href="book/Tutorials/PluginAPI.html#get-fow-handler">Get FOW handler</a></li>
<li><a href="book/Tutorials/PluginAPI.html#get-fow-state">Get FOW state</a></li>
</ul>
<p>This tutorial demonstrates various useful functions from the plugin that you will need to use in your game.</p>
<h2 id="get-fow-handler"><a class="header" href="#get-fow-handler">Get FOW handler</a></h2>
<p>The <code>FOWHandler</code> is the core of the plugin, as it registers everything. You might need to query it to access different functionalities
such as Save/Load, floors, collision, and drawer queries. You can access it by calling <code>GetFOWHandler</code> in both C++ and Blueprints.
Be sure to implement the interface from the <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/Networking.html">Network tutorial</a> if you're making an online game.</p>
<p>BP</p>
<p><img src="book/Tutorials/../../assets/Tutorial/PluginAPI/0_1_GetFOWHandlerBP.png" alt="PluginAPIPictures" /></p>
<p>CPP</p>
<pre><code class="language-cpp">#include "FOW_Handler.h"

if (AFOW_Handler* FOWHandler = AFOW_Handler::GetFOWHandler(this))
{
	FOWHandler-&gt;...
}
</code></pre>
<h2 id="get-fow-state"><a class="header" href="#get-fow-state">Get FOW state</a></h2>
<p>You can query the FOW state anywhere by using the <code>GetFOWStateAt</code> function and its variations:</p>
<ul>
<li><code>GetFOWStateAt</code>: Retrieves the fog state at a specific location.</li>
<li><code>GetFOWStateForAABB</code>: Retrieves the fog state in an AABB. It returns visible if any part of the AABB is visible; no averaging is performed.</li>
<li><code>GetFOWStateFromBits</code>: Converts a <code>uint8</code> returned by the plugin into the corresponding fog state enum.</li>
</ul>
<p>BP</p>
<p><img src="book/Tutorials/../../assets/Tutorial/PluginAPI/1_GetFogStateBP.png" alt="PluginAPIPictures" /></p>
<p>CPP</p>
<pre><code class="language-cpp">#include "Tools/FunctionLibrairy/FOWFunctionLibrary.h"

//Get fog state at location
FVector Location;
EnumFOWState state = UFOWFunctionLibrary::GetFOWStateAt(GetWorld(), Location);

//Get fog state in AABB
FVector Location;
FVector Extend;
EnumFOWState state UFOWFunctionLibrary::GetFOWStateForAABB(GetWorld(), Location, Extend);

//Get fog state from bits
uint8 bitsValue;
EnumFOWState state = UFOWFunctionLibrary::GetFOWStateFromBits(bits);
</code></pre>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stealth-area"><a class="header" href="#stealth-area">Stealth Area</a></h1>
<ul>
<li><a href="book/Tutorials/StealthArea.html#add-stealth-area">Add Stealth Area</a></li>
<li><a href="book/Tutorials/StealthArea.html#fog-type">Fog type</a></li>
<li><a href="book/Tutorials/StealthArea.html#entities-settings">Entities settings</a>
<ul>
<li><a href="book/Tutorials/StealthArea.html#collision">Collision</a></li>
<li><a href="book/Tutorials/StealthArea.html#delegates">Delegates</a></li>
</ul>
</li>
<li><a href="book/Tutorials/StealthArea.html#going-deeper">Going deeper</a></li>
</ul>
<p>This tutorial is about adding Stealth Area. No prerequisites are needed; you can use any map that you want.</p>
<h2 id="add-stealth-area"><a class="header" href="#add-stealth-area">Add Stealth Area</a></h2>
<p>The <code>Stealth Area</code> feature simulates the bush system found in MOBA games. The system acts as a collider and projects shadows if the
area is near an <code>FOVEntity</code>. Once the entity gets too close or inside, the collider will be ignored, and the fog will be revealed.
The system is fully dynamic, just like the collision system, and it will automatically generate <code>Clusters</code> of <code>Stealth Areas</code>. All
areas in contact will be added to a cluster, allowing the <code>FOVEntity</code> to reveal the fog from the whole cluster.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/0_StealthAreaTutorial.png" alt="StealthAreaPictures" /></p>
<p>There are two different objects to generate a <code>Stealth Area</code>:</p>
<ul>
<li><code>UFOW_StealthAreaComponent</code>: You can attach it to any actor.</li>
<li><code>AFOW_PCG_StealthArea</code>: A predefined actor that generates a <code>Stealth Area</code> which can be filled procedurally with a <code>StaticMesh</code>.</li>
</ul>
<p>Both of these objects inherit from <code>IFOW_StealthArea_Interface</code>, allowing you to create your custom tool.<br /></p>
<p>Let's set it up by dropping an <code>AFOW_PCG_StealthArea</code> into your scene.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/1_AddStealthArea.png" alt="StealthAreaPictures" /></p>
<p>As with <code>CustomCollision</code>, mobility is important for optimization, and you will need to manually place the vertices of the geometry
defining the area.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/2_StealthAreaAreFOWCollisions.png" alt="StealthAreaPictures" /></p>
<p>Add vertices to the <code>Custom Geometry Vertices</code> and create the shape you want. All vertices need to have the same height; however, the
shape isn't limited.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/3_AddVertices.png" alt="StealthAreaPictures" /></p>
<p>For the <code>AFOW_PCG_StealthArea</code>, you can provide a <code>StaticMesh</code>, and the system will fill the area geometry with instances of the provided mesh.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/4_SelectPCGMesh.png" alt="StealthAreaPictures" /></p>
<p>You can tweak the generation with the following variables:</p>
<ul>
<li><code>Seed</code>: The seed used for randomness. -1 will use a different number for each generation.</li>
<li><code>Space Between</code>: The space separating each mesh.</li>
<li><code>Random Offset</code>: A random offset allowed for each instance to prevent alignment.</li>
<li><code>Rotation Min/Max</code>: The rotation range to apply to the mesh.</li>
<li><code>Scale Range</code>: The scale range to apply to the mesh.</li>
</ul>
<h1 id="fog-type"><a class="header" href="#fog-type">Fog Type</a></h1>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/11_0_StealthArea_FogType.png" alt="StealthAreaPictures" /></p>
<p>The stealth area, by default, acts like a collision, casting its collision shadow onto the fog. Depending on your game, you might want a
different behavior. For this purpose, you will find the <code>FogType</code> enum:</p>
<ul>
<li><code>FOG_SHADOW</code>: The fog will remain unrevealed inside and behind the stealth area.</li>
<li><code>FOG</code>: The fog will remain unrevealed only inside the stealth area.</li>
<li><code>NO_FOG</code>: No fog will be generated from this stealth area.</li>
</ul>
<blockquote>
<p><strong>/!\ <code>NO_FOG</code> means that the stealth area won't hide the visible entity inside it if an enemy has sight on the stealth area. A custom <code>VisibilityHandler</code> will be required to make it work correctly. <br /></strong></p>
</blockquote>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/12_StealthArea_FogType_Enum.png" alt="StealthAreaPictures" /></p>
<h2 id="entities-settings"><a class="header" href="#entities-settings">Entities Settings</a></h2>
<p>Aside from the <code>Stealth Area</code> itself, a few settings can be changed for the <code>Entities</code>.</p>
<h3 id="collision"><a class="header" href="#collision">Collision</a></h3>
<p>To discover the <code>Stealth Area</code> fog, the entities need to be in collision with them. This is computed with a <code>Circle-Geometry</code> intersection,
allowing users to define how large their units are and at what distance the units will be considered inside the <code>Stealth Area</code>. You will find
a <code>Collision Radius</code> variable in both <code>FOW_DrawingEntity_FOV_Component</code> and <code>FOW_VisibilityEntity_Component</code> to change the collision distance.<br />
For the <code>Visible Entities</code>, you will need to enable the <code>StealthAreaUpdate</code> by toggling on the variable. By design, it is set to false because
the collision chack can be expensive.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/6_ChangeEntityCollisionRadius.png" alt="StealthAreaPictures" /></p>
<h3 id="delegates"><a class="header" href="#delegates">Delegates</a></h3>
<p>To associate gameplay with the <code>Stealth Area</code>, you can bind the <code>Entity</code> owner to the <code>OnEntityStealthStateChanged</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/8_OverrideOnStealthAreaChanged.png" alt="StealthAreaPictures" /></p>
<p>The delegate is simple and provides a boolean indicating whether the <code>Entity</code> has entered or left the <code>Stealth Area</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/9_BindToDelegate.png" alt="StealthAreaPictures" /></p>
<h2 id="going-deeper"><a class="header" href="#going-deeper">Going Deeper</a></h2>
<p>You might want to create gameplay that requires accessing the area actor within the <code>Stealth Area</code>. You can access the colliding area by calling
<code>GetStealthArea</code>. You can also query the other areas in the cluster with a chain of nodes:</p>
<ul>
<li>From the visibility entity, get the <code>StealthArea</code> and the <code>ClusterIdx</code> from it.</li>
<li>Get the <code>FOWHandler</code> and find the <code>Floors</code> at the entity's location.</li>
<li>Iterate over the floors and get the <code>EntityVisibilityHandler</code>.</li>
<li>Get the <code>StealthAreaContainer</code>.</li>
<li>Finally, call <code>GetStealthAreaForClusterIdx</code>, which will return an array of stealth area interfaces that you can cast.</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/StealthArea/10_GoDeeperWithStealthArea.png" alt="StealthAreaPictures" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layered-fog-of-war-versions"><a class="header" href="#layered-fog-of-war-versions">Layered Fog of War versions</a></h1>
<p>Here is list of version pushed to the market place.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-6"><a class="header" href="#pages-6">Pages</a></h1>
<ul>
<li><a href="book/Versions//book/Versions/LFOW_V1.1.1.html">LFOW V1.1.1</a></li>
<li><a href="book/Versions//book/Versions/LFOW_V1.2.0.html">LFOW V1.2.0</a></li>
<li><a href="book/Versions//book/Versions/LFOW_V1.2.1.html">LFOW V1.2.1</a></li>
<li><a href="book/Versions//book/Versions/LFOW_V1.3.0.html">LFOW V1.3.0</a></li>
<li><a href="book/Versions//book/Versions/LFOW_V1.3.1.html">LFOW V1.3.1</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfow-v111"><a class="header" href="#lfow-v111">LFOW V1.1.1</a></h1>
<p>Quick fixes after the release of the plugin</p>
<p><strong>Fixes:</strong></p>
<ul>
<li><code>Replication</code>, The FOW wasn't easy to implement in new projects, and teams weren't correctly replicated in the drawer or entity.</li>
<li><code>Replication</code>, FogStateReplicationClient is now correctly deleted when a client disconnects.</li>
<li><code>Minimap</code>, Minimap had the Z value hardcoded to 0 in the material; it now uses the value provided by "MinimapPlanLocation."</li>
<li><code>TextureSample</code>, Frustum texture sample math wasn't correct for super thick floors. This issue resulted in offset fog in the render.</li>
<li><code>Material</code>, Fix the material "M_FOW_Visibility_Dithering" present in the feature showcase map, dithering shadow wasn't appearing correctly.</li>
</ul>
<p><strong>Documentation:</strong></p>
<ul>
<li><code>Networking</code> documentation has been updated.</li>
</ul>
<p><strong>LayeredFOW_Demo:</strong></p>
<ul>
<li>A template map for <code>Networking</code> is now provided in this project. You can migrate <code>TemplateProject</code> folder to your <code>UE5.4 project</code> to set up an online game.</li>
</ul>
<p><strong>LFOW compatibility</strong>:</p>
<ul>
<li>The plugin for Unreal versions <code>5.2</code> and <code>5.3</code> doesn't work due to a lack of knowledge on my part. A friend briefed me, and I will make the necessary corrections. As a result, the release of <code>LFOW V1.1.1</code> for these two versions will be delayed a bit.</li>
</ul>
<p>That's all for the quick fixes. Don't hesitate to ping me on my <code>Discord</code> if you find issues or if you'd like to submit a feature idea!</p>
<p><strong>Next features to come:</strong></p>
<ul>
<li><code>FogHeatTexture</code>: Will display a smoother fog transition.</li>
<li><code>Bush system</code>: Will be designed as MOBA games did.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfow-v120"><a class="header" href="#lfow-v120">LFOW V1.2.0</a></h1>
<p>Adding the new features <code>Stealth Area</code> and <code>Heat Texture</code> to the plugin. Adding MOBA template, documentation, and many fixes.</p>
<p><strong>Features</strong></p>
<ul>
<li><code>Stealth Area</code>: Allows bush mechanics to be added to the games.</li>
<li><code>Heat Texture</code>: Smooths the state transition of the fog.</li>
<li><code>Texture Sample SceneCapture</code>: Previously, only the camera texture sample was available.</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li><code>SetDrawingEntityTeam</code>: If the actor was an entity, the team wasn't set.</li>
<li><code>TextureSample</code>: Some texture samples were calling ShrinkSample, generating an incorrect AABB.</li>
<li><code>Listen Server</code>: During play in the editor, NetMode was being set too late for correct initialization of the FOW, so an alternative method is now used.</li>
<li><code>Loading</code>: A save could generate some blinking.</li>
<li><code>Tile Merging</code>: Has been revised to correctly fit with the heat texture.</li>
</ul>
<p><strong>Documentation</strong></p>
<ul>
<li><code>Network</code> architecture documentation has been added.</li>
<li><code>MOBA</code> template documentation has been added.</li>
<li><code>Heat Texture</code> tutorial documentation has been added.</li>
<li><code>Material</code> tutorial documentation has been added.</li>
<li><code>Stealth Area</code> tutorial documentation has been added.</li>
<li><code>Teams</code> tutorial documentation has been added.</li>
<li><code>Toggle Render</code> tutorial documentation has been added.</li>
</ul>
<p><strong>LayeredFOW_Demo</strong></p>
<ul>
<li>A template for a <code>MOBA</code> game is now provided in this project. You can migrate the <code>MOBATemplate</code> folder to your <code>UE5.4 project</code> to set up an online game.</li>
</ul>
<p>That's all for this update. Don't hesitate to ping me on my <code>Discord</code> if you find issues or if you'd like to submit a feature idea!</p>
<p><strong>Next Features to Come</strong></p>
<ul>
<li><code>Linux</code> compilation.</li>
<li><code>Rendering</code> feature should come next.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfow-v121"><a class="header" href="#lfow-v121">LFOW V1.2.1</a></h1>
<p>Adding Linux compatibility, bug fixes, documentation update.</p>
<p><strong>Features</strong></p>
<ul>
<li><code>Linux</code> is now supported.</li>
<li><code>Stealth Area</code> Enum is now available: Fog_Shadow / Fog / No_Fog.</li>
<li><code>Team Mask</code> Drawers with a team set to -1 were updating the fog of each team. A mask is now available to select which team is affected (limited to 32 teams).</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li><code>HeatTexture</code>: Fixed HeatTexture merging when the number of bits used is smaller than the TilePixelSize.</li>
<li><code>Entities</code>: Fixed crash with 1-floor fog setup when entities go out of bounds without being volatile.</li>
<li><code>Stealth Area</code>: Fixed crash when turning off and on the entity.</li>
<li><code>AABBTree Collision</code>: Fixed crash during regeneration.</li>
<li><code>Fog Rendering</code>: 1 channel tiles can now be selected without having to update the Post Process (Using 1 channel for MOBA games improves performance).</li>
<li><code>Fog Rendering</code>: Fixed 1 and 3 channel tiles update issues when having many teams.</li>
<li><code>Networking</code>: Fixed network initialization happening in the editor.</li>
<li><code>FOVDrawers</code>: Issue with the cone mask fixed.</li>
<li><code>Minimap</code>: The <code>MinimapPlanLocation</code> will now use the actor's Z position by default to prevent mistakes caused by the <code>TextureGenerator</code> position.</li>
</ul>
<p><strong>Documentation</strong></p>
<ul>
<li><code>First Setup</code>: Added an issues section.</li>
<li><code>Minimap</code>: Updated the documentation.</li>
<li><code>Drawing Entity</code>: Added the TeamMask explanation.</li>
<li><code>StealthArea</code>: Added the FogType explanation.</li>
</ul>
<p><strong>Next Features to Come</strong></p>
<ul>
<li><code>Rendering</code> feature should come next.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfow-v130"><a class="header" href="#lfow-v130">LFOW V1.3.0</a></h1>
<p>UE 5.5 compatibility, Rendering features, Fixes, documentation</p>
<blockquote>
<p><strong>/!\ Please check the retake and ensure you update your project with the provided instructions. <br /></strong></p>
</blockquote>
<p><strong>Features</strong></p>
<ul>
<li><code>Unreal Engine v5.5</code>: The plugin supports the upcoming version of Unreal.</li>
<li><code>Texture assets</code>: Fog game texture can now be assets, allowing any material to use it and create logic based on the fog state.</li>
<li><code>Custom depth buffer</code>: Assets can be rendered in a different stencil to ignore the fog.</li>
<li><code>Entity sight mask</code>: FOV entities can have a cone mask.</li>
<li><code>Floors area</code>: Floors now use a <code>Vector2D</code> to define their bounds, providing more precise fog delimitation.</li>
<li><code>Visibility fade</code>: Adds <code>UFOW_VisibilityE_FadeComponent</code> to fade in/out material rendering.</li>
<li><code>FOV Drawers event</code>: FOV drawers will now trigger an event when they enter or leave a floor: <code>OnDrawerEnterFloor</code> &amp; <code>OnDrawerLeaveFloor</code>.</li>
<li><code>Plugin ensure</code>: Ensures can now be disabled by setting <code>USE_FOW_ENSURE</code> to 0; be certain of your implementation before turning it off.</li>
</ul>
<p><strong>Retakes</strong></p>
<ul>
<li><code>Floors</code>: <code>FloorExtend</code> is now deprecated, use the FVector2D <code>FloorExtends</code> to set the floor size. The pink plane display is disabled by
default; an orange limit will show the actual fog position.</li>
<li><code>Minimap</code>: Numerous fixes have been applied to the minimap. A 90 degree rotation may appear on some minimaps. Please use <code>TextureRotationConst</code> to correct it.</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li><code>Linux compilation</code>: Fixes header include.</li>
<li><code>ARM64</code>: Implementation of NEON to replacce 128-bit SIMD instructions (requires testing, environment-dependent).</li>
<li><code>Drawers</code>: Adds functions to enable/disable drawers without querying <code>FOWHandler</code>: <code>AddDrawerToHandler</code> and <code>RemoveDrawerFromHandler</code>.</li>
<li><code>FOWHandler crash</code>: Plugin no longer crashes when <code>FOWHandler</code> is absent.</li>
<li><code>Network</code>: Removing the <code>NetworkSettings</code> for online games works correctly. Enabling game setup without replication dependency from the FOW.</li>
<li><code>Minimap</code>: Fixes fog pixel strips on some minimaps.</li>
<li><code>Minimap</code>: Fixes rotation, displacement and scale.</li>
<li><code>Stealth Area</code>: Area cluster reconstruction time optimized (previously 17 ms for 10 areas in contact).</li>
</ul>
<p><strong>LayeredFOW_Demo:</strong></p>
<ul>
<li>The project has been updated with new tutorials and my custom minimap implementation, which supports widgets. Feel free to use it; however,
support won't be provided. See the <code>MinimapWithIcon</code> folder and check the <code>TutorialMap_Minimap_Icon</code> map where everything is set up.</li>
</ul>
<p><strong>Documentation</strong></p>
<ul>
<li><code>Material Opacity</code>: New rendering tutorial.</li>
<li><code>Stencil</code>: New rendering tutorial.</li>
<li><code>First Setup</code>: Updated tutorial, explanation over the difference between <code>FOVEntities</code> and <code>FOVDrawers</code>.</li>
<li><code>Visibility Entity</code>: Updated tutorial to include the fade component.</li>
</ul>
<p><strong>Next Features to Come</strong></p>
<ul>
<li><code>Rendering</code> feature is upcoming.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lfow-v131"><a class="header" href="#lfow-v131">LFOW V1.3.1</a></h1>
<p>Material Opacity Fix for packaged project</p>
<blockquote>
<p><strong>/!\ Please check the retake and ensure you update your project with the provided instructions. <br /></strong></p>
</blockquote>
<p><strong>Retakes</strong></p>
<ul>
<li><code>Material Opacity</code>: Removing <code>MPC_FOW_VFXRenderSettings</code> and inserting parameters in the <code>MPC_FOWRenderSettings</code>. Materials can only have
up to 2 collections. With the MPC removed, materials created with the node from V1.3.0 might break and need an <code>MPC</code> replacement.</li>
</ul>
<p><strong>Fixes</strong></p>
<ul>
<li><code>Material Opacity</code>: Now working for the packaged project.</li>
<li><code>Feature showcase map</code>: Updated with new rooms showing material opacity and stencil.</li>
</ul>
<p><strong>Documentation</strong></p>
<ul>
<li><code>Material Opacity</code>: Updated documentation due to the retake.</li>
<li><code>Drawing Entity</code>: Added a new paragraph for the FOV cone mask.</li>
<li><code>PluginAPI</code>: New documentation providing knowledge on the useful functions within the plugin.</li>
</ul>
<p><strong>Next Features to Come</strong></p>
<ul>
<li><code>Rendering</code>: Volumetric fog material.</li>
<li><code>Rendering</code>: Blur quality.</li>
<li><code>Optimization</code>: Post-process compute time.</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//reference/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-afow_handler"><a class="header" href="#class-afow_handler"><strong>Class: <code>AFOW_Handler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API AFOW_Handler
    : public AActor;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The Fog Of War Handler is the base class of the plugin, it's a sigleton and you cannot have many instance of it even when doing networked game with replication<br />
The Fog Of War is highly parametrable and let the developers override almost everything. You might want to get ride of some functionality or maybe to write a more optimized code<br />
The handler hasn't any main logic, it's purpose is to:</p>
<ul>
<li>Have general settings</li>
<li>Initialise FOW Object</li>
<li>Run the update</li>
<li>Contain FOW element instancies</li>
</ul>
<p>You have the possibility to change the core module of the FOW by changing the default class used int the settings</p>
<blockquote>
<ul>
<li>If you want a custom FOWHandler be sure to override FindLevelFOWHandler, you can use <strong><code>AFOW_Handler_Default</code></strong> as example</li>
<li>Go to the FOWFloors settings and display the parametters to shape the floor to your needs</li>
</ul>
</blockquote>
<p>If you need to modify the initialization to fit your pipeline, override those function called by the BeginPlay</p>
<ul>
<li>void InitNetwork();</li>
<li>void InitFOWFloors();</li>
<li>void InitFOWFloorsTiles();</li>
<li>void InitGameShader();</li>
<li>void InitFOWUpdate();</li>
<li>void FinalizeInitialization();
Please be really carefull to not finalize the initialization if the floor or game shader init havn't be called</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_collisionentity_interface"><a class="header" href="#class-ifow_collisionentity_interface"><strong>Class: <code>IFOW_CollisionEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_CollisionEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Collision entities are the sight blocker to prevent fog discovering between rooms.<br />
By design any child implementing this class should also implement <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> to enable optimisation</p>
<blockquote>
<ul>
<li>Depending of the situation you can have issues because of collision drawing optimisation, Override ShouldDrawColliders and return false to disable it</li>
<li>You can disable the whole collision drawing optimisation by disabling DrawFOWCollider in <a href="reference/classes//reference/classes/UFOW_LayerHandler.html"><strong><code>UFOW_LayerHandler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_drawingentity_interface"><a class="header" href="#class-ifow_drawingentity_interface"><strong>Class: <code>IFOW_DrawingEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_DrawingEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Drawing entity used to modify the state of the fog depending of the given <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Override GetEntityLayerSetting to give the correct layer setting</li>
<li>Call SetEntityTeam to change the entity team in case of multiplayer game</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_entity_interface"><a class="header" href="#class-ifow_entity_interface"><strong>Class: <code>IFOW_Entity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Base class for every entity interface, <a href="reference/classes//reference/classes/IFOW_GeometryEntity_Interface.html"><strong><code>IFOW_GeometryEntity_Interface</code></strong></a> is an exception subject to a retake</p>
<blockquote>
<ul>
<li><a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_VisibilityEntity_Interface.html"><strong><code>IFOW_VisibilityEntity_Interface</code></strong></a></li>
</ul>
</blockquote>
<p>Entities are by default automatically updated by the system if (IsStatic == false &amp;&amp; FloorVolatile)</p>
<blockquote>
<ul>
<li>FloorVolatile express the posibility to move from a floor to another</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : every multiple inheritance have specifique overriding rule regarding methodes finishing by _M.<br />
You can use <strong><code>AFOW_CustomCollision</code></strong> as examble for your custom entity implementation</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_geometryentity_interface"><a class="header" href="#class-ifow_geometryentity_interface"><strong>Class: <code>IFOW_GeometryEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_GeometryEntity_Interface;
</code></pre>
<hr />
<p>Geometry entity is a data container used by entities to modify fog or create collision.</p>
<blockquote>
<ul>
<li>Geometries are by default automatically updated by the system if (static == false || modular)</li>
<li>Override UpdateEntityGeometry to make your modification</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : The geometry system should be retaken to make the geometry aligned in memory</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_visibilityentity_interface"><a class="header" href="#class-ifow_visibilityentity_interface"><strong>Class: <code>IFOW_VisibilityEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_VisibilityEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Visibility entity used to automatically update the ingame visibility of the UObject inherited from it</p>
<blockquote>
<ul>
<li>VisibilityEntity are by default automatically updated</li>
<li>Override OnVisibilityStateChanged to update the visibility state</li>
<li>You can find a default example by looking at <strong><code>UFOW_VisibilityComponent</code></strong>.</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_collisionhandler"><a class="header" href="#class-ufow_collisionhandler"><strong>Class: <code>UFOW_CollisionHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_CollisionHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Collision handler is used to accelerate the querying of collider to generate sight mask<br />
Every handler is associated to its <strong><code>UFOW_CollisionHandlerQuery</code></strong> class</p>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawercomponent"><a class="header" href="#class-ufow_drawercomponent"><strong>Class: <code>UFOW_DrawerComponent</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_DrawerComponent
    : public UActorComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The drawer component compute fog modification, however it doesn't apply it.<br />
They are small chunk of fog aligned to the world grid, they can be seen as canvas.<br />
Their update are the slowest because of the collision querying and the geometry rasterization.<br />
By default they are mean to be added to each actor modifying the fog however the memory allocation and merging can become very time consuming.<br />
If your game needs higher performance take a look at <a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a> which will request the creation of a <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a> to the system.<br /></p>
<p>It is possible to :</p>
<blockquote>
<ul>
<li>Create custom drawer by inheriting from this class and by overriding GenerateDrawerGeometry to inject your custom geometry</li>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
<li>Change the collision querying by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onlyregistervalideteam"><a class="header" href="#onlyregistervalideteam"><strong><code>OnlyRegisterValideTeam</code></strong></a></h1>
<pre><code class="language-cpp">protected:
bool OnlyRegisterValideTeam;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadWrite</strong></li>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Settings</em></li>
</ul>
<hr />
<p>If disabled, all drawer will be registered in the FOWHandler, it might slighly increase UpdateDrawerLayer parsing time
But it will remove every network synchronisation issues if the client team change</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawer_shared"><a class="header" href="#class-ufow_drawer_shared"><strong>Class: <code>UFOW_Drawer_Shared</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Drawer_Shared
    : public UFOW_DrawerComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
<li><strong>BlueprintType</strong></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Drawer designed to hold <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> and batch their update under one process</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entitycontainer"><a class="header" href="#class-ufow_entitycontainer"><strong>Class: <code>UFOW_EntityContainer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityContainer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>Dynamic entity and geometry container. Called by the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a> to update their status</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entityvisibilityhandler"><a class="header" href="#class-ufow_entityvisibilityhandler"><strong>Class: <code>UFOW_EntityVisibilityHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityVisibilityHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Update the visibility of every registered object implementing IFOW_VisibilityEntity_Interface.<br />
The class is instantied twice in every <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> for Static and dynamic entity.<br />
Each entity will query the FOW state at location or for an AABB on the owner FOW_Floor.<br /></p>
<blockquote>
<ul>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Override OnVisibilityStateChanged methode in IFOW_VisibilityEntity_Interface to apply custom modification</li>
<li>Bind your object to OnVisibilityChanged if you are using FOW_VisibilityComponent</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="visibleentities"><a class="header" href="#visibleentities"><strong><code>VisibleEntities</code></strong></a></h1>
<pre><code class="language-cpp">protected:
TArray&lt;TScriptInterface&lt;IFOW_VisibilityEntity_Interface&gt;&gt; VisibleEntities;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadOnly</strong></li>
<li><strong>Category</strong> = <em>Internal</em></li>
</ul>
<hr />
<p>Hold the visible entity</p>
</li>
</ul>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="prepareforworlddestruction"><a class="header" href="#prepareforworlddestruction"><strong><code>PrepareForWorldDestruction</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void PrepareForWorldDestruction();
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Call before the world destruction to prevent all Remove or Add operation</p>
  </details>
</li>
<li>
<h1 id="updatevisibilitystate"><a class="header" href="#updatevisibilitystate"><strong><code>UpdateVisibilityState</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void UpdateVisibilityState(
    const UFOW_Floor* Floor,
    uint8 FOWGlobalSettingFlags
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Update the visibility state of all registered entity</p>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="floor-1"><a class="header" href="#floor-1"><strong><code>Floor</code></strong></a></h2>
<pre><code class="language-cpp">const UFOW_Floor* Floor
</code></pre>
</li>
<li>
<h2 id="fowglobalsettingflags"><a class="header" href="#fowglobalsettingflags"><strong><code>FOWGlobalSettingFlags</code></strong></a></h2>
<pre><code class="language-cpp">uint8 FOWGlobalSettingFlags
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_floor"><a class="header" href="#class-ufow_floor"><strong>Class: <code>UFOW_Floor</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Floor
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>The floor is an area where a bit mask texture is generated to create fog.<br />
Each floor bit mask will be sliced and attributed to a <strong><code>TFOW_Tile_Base</code></strong>.<br />
It's responsible of the fog state update by querying the fog chunk of every drawer.<br />
Every levels can have many instances of floor to allow verticallity for your game.<br />
Each floor has a collision handler static and dynamic and is responsible for the collision update.<br /></p>
<blockquote>
<ul>
<li>Change the collision system by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<p>Warning : supperposed floor will work correctly only if you change the PP material in <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layerhandler"><a class="header" href="#class-ufow_layerhandler"><strong>Class: <code>UFOW_LayerHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The layer handler allow you to change the computation order of the different <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Layer will modify the fog state in the given order, which means that a modification can be overriden by an other layer</li>
<li>Enable or disable the collision drawing optimisation by changing DrawFOWCollider</li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layersetting"><a class="header" href="#class-ufow_layersetting"><strong>Class: <code>UFOW_LayerSetting</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerSetting
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Layer setting is made to configure how an entity or a drawing component will modify the fog</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_rasterizer"><a class="header" href="#class-ufow_rasterizer"><strong>Class: <code>UFOW_Rasterizer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Rasterizer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The rasterizer convert the geometries to a bit mask texture representing the state of the FOW.<br />
The reasterizer is never instantied, the default object is always used witch means that you cannot use variable in the class</p>
<blockquote>
<ul>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_texturesample"><a class="header" href="#class-ufow_texturesample"><strong>Class: <code>UFOW_TextureSample</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_TextureSample
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The texture sample collect sample of FOW from the <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> to write it inside a texture that will be bind to materials</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_tile_class"><a class="header" href="#class-ufow_tile_class"><strong>Class: <code>UFOW_Tile_Class</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Tile_Class
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
</ul>
<hr />
<p><strong><code>TFOW_Tile_Base</code></strong> aren't a UCLASS to prevent saturation of GC, thus they are all wrapped by a FOW_Tile_Class and allocated the old way.<br />
Tiles are used to compute fog result of the <a href="reference/classes//reference/classes/UFOW_DrawerComponent.html"><strong><code>UFOW_DrawerComponent</code></strong></a> and merge it depending of the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a> under a bit array that will feed the <a href="reference/classes//reference/classes/UFOW_TextureSample.html"><strong><code>UFOW_TextureSample</code></strong></a> sent to the GPU.<br />
You can simply create your own tile update by overriding this class and by using the templated class <strong><code>TFOW_Tile</code></strong>.
you will have to create 3 templated classes to finish your fully custom tiles :</p>
<ul>
<li>Update</li>
<li>Compute</li>
<li>Merge</li>
</ul>
<blockquote>
<ul>
<li>Override GetTileBitsFormat to correctly set the tile pixel number for the FOW</li>
<li>Override GetTileChannelNbr to correctly set the channels number per tiles</li>
<li>Override GetTilePackagingFormat to correctly set the packaging format use by the FOW</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_visibilitye_component"><a class="header" href="#class-ufow_visibilitye_component"><strong>Class: <code>UFOW_VisibilityE_Component</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_VisibilityE_Component
    : public UActorComponent
    , public IFOW_VisibilityEntity_Interface;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-15"><a class="header" href="#specifiers-15">Specifiers:</a></h3>
<ul>
<li><strong>ClassGroup</strong> = <em>Entity</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
<li><strong>DisplayName</strong> = <em>FOW_VisibilityEntityComponent</em></li>
</ul>
<hr />
<p>Can be added to any actor which need to be hidden when the player hasn't sight on it</p>
<blockquote>
<ul>
<li>Enable IsEntityFloorVolatile to use the default visibility update</li>
<li>Bind yourself to OnVisibilityChanged to customise the visibility update</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<hr />
<h1 id="properties-2"><a class="header" href="#properties-2"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onentitystealthstatechanged"><a class="header" href="#onentitystealthstatechanged"><strong><code>OnEntityStealthStateChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
FEvent_VisibleEntityStealthState OnEntityStealthStateChanged;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-16"><a class="header" href="#specifiers-16">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintAssignable</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>FOW</em></li>
</ul>
<hr />
<p>Called every time the the entity enter/leave stealth area</p>
</li>
<li>
<h1 id="onvisibilitychanged"><a class="header" href="#onvisibilitychanged"><strong><code>OnVisibilityChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
FOnVisibilityChangedd OnVisibilityChanged;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-17"><a class="header" href="#specifiers-17">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintAssignable</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>FOW</em></li>
</ul>
<hr />
<p>Called every time the Visibility state has changed</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
