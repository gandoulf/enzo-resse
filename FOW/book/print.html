<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Layered Fog Of War documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="documentation.html">Documentation</a></li><li class="chapter-item expanded "><a href="book/index.html">Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/getting_started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="book/architecture/index.html">Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/architecture/Handler.html">Handler</a></li><li class="chapter-item expanded "><a href="book/architecture/Floor.html">Floor</a></li><li class="chapter-item expanded "><a href="book/architecture/Layers.html">Layers</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/index.html">Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/First_set_up.html">First set up</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/index.html">Entities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="book/Tutorials/entities/Visibility_Entity.html">Visibility Entity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/Drawing_Entity.html">Drawing entity</a></li><li class="chapter-item expanded "><a href="book/Tutorials/entities/Collision_Entity.html">Collision entity</a></li></ol></li><li class="chapter-item expanded "><a href="book/Tutorials/Layers.html">Layers</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Outdoor_Indoor.html">Outdoor Indoor</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Networking.html">Networking</a></li><li class="chapter-item expanded "><a href="book/Tutorials/FogChannels.html">Fog Channels</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Floor_Verticality.html">Floor and Verticality</a></li><li class="chapter-item expanded "><a href="book/Tutorials/Minimap.html">Minimap</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference.html">C++ API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes.html">Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/classes/AFOW_Handler.html">AFOW_Handler</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_CollisionEntity_Interface.html">IFOW_CollisionEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_DrawingEntity_Interface.html">IFOW_DrawingEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_Entity_Interface.html">IFOW_Entity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_GeometryEntity_Interface.html">IFOW_GeometryEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/IFOW_VisibilityEntity_Interface.html">IFOW_VisibilityEntity_Interface</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_CollisionHandler.html">UFOW_CollisionHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_DrawerComponent.html">UFOW_DrawerComponent</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Drawer_Shared.html">UFOW_Drawer_Shared</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityContainer.html">UFOW_EntityContainer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_EntityVisibilityHandler.html">UFOW_EntityVisibilityHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Floor.html">UFOW_Floor</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerHandler.html">UFOW_LayerHandler</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_LayerSetting.html">UFOW_LayerSetting</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Rasterizer.html">UFOW_Rasterizer</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_TextureSample.html">UFOW_TextureSample</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_Tile_Class.html">UFOW_Tile_Class</a></li><li class="chapter-item expanded "><a href="reference/classes/UFOW_VisibilityE_Component.html">UFOW_VisibilityE_Component</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Layered Fog Of War documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="/book/index.html">Book</a></li>
<li><a href="/reference.html">C++ API Reference</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="book"><a class="header" href="#book">Book</a></h1>
<p>This book provides an in-depth explanation of the Layered Fog Of War architecture. It includes implementation
examples, code explanations, and guidance on maximizing the utility of the FOW. While this plugin is
straightforward to use, understanding it thoroughly may become challenging when striving for improved performance.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="book//book/getting_started.html">Getting Started</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="book/getting_started.html#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></li>
<li><a href="book/getting_started.html#features">Features</a>
<ul>
<li><a href="book/getting_started.html#high-definition-big-map">High Definition, Big Map</a></li>
<li><a href="book/getting_started.html#tons-of-ai">Tons of AI</a></li>
<li><a href="book/getting_started.html#vertical-games">Vertical Games</a></li>
<li><a href="book/getting_started.html#networking">Networking</a></li>
<li><a href="book/getting_started.html#developer-playground">Developer Playground</a></li>
<li><a href="book/getting_started.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>
<h2 id="the-fog-of-war-is-only-a-texture"><a class="header" href="#the-fog-of-war-is-only-a-texture">The Fog Of War is Only a Texture</a></h2>
<p>Understanding the technology requires seeing the Fog of War (FOW) as a texture:</p>
<blockquote>
<p><strong>By utilizing a texture, it should be possible to create games with a "flat" map. Gameplay areas cannot be superimposed,
or undesirable parts of it will be revealed. However, by employing multiple layers and applying transparency, this issue
can be addressed.</strong></p>
</blockquote>
<p>Quick definition:
The fog of war is a common game mechanic used in strategy and real-time strategy (RTS) games to simulate uncertainty and
limited visibility. It obscures parts of the game map that are not currently within the player's line of sight or knowledge,
typically represented by a shroud or darkness.</p>
<p>FOW is merely a set of data represented as a texture, allowing the computer to conceal some parts of the rendered frame from
the player during the post-process pass. It will project the position of the rendered pixel onto a plane delimiting the FOW.
The projection will then query the state of the fog texture to determine if the player has sight on this pixel. It's a simple
process of flattening all the assets onto a plane.</p>
<p>The texture generation is carried out by elements called "Drawers"; they compute a texture fragment of what they see. Drawers
can draw any shape to reveal an area, with two primary usages: drawing circles to reveal everything around the player and casting
the collision geometry shadow to simulate the player's sight.</p>
<p>Once every fragment is generated, they are merged under the fog texture to be rendered.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="high-definition-big-map"><a class="header" href="#high-definition-big-map">High Definition, Big Map</a></h3>
<h4 id="1-introduction"><a class="header" href="#1-introduction">1. Introduction</a></h4>
<p>The Fog of War algorithms are simple in theory but resource-intensive to update. To maintain a decent frame rate, texture
precision needs to be downgraded to reduce rasterization time of the drawers, texture update time on the GPU, or GPU texture
sampling time. The heavy fog update also posed obstacles for game development. Maps had to be small for high fog definition,
or the definition had to be low for huge maps. I've aimed to prevent this and allow everyone to choose any precision without
repercussions.</p>
<h4 id="2-handler-floor-tile-sample"><a class="header" href="#2-handler-floor-tile-sample">2. Handler, Floor, Tile, Sample</a></h4>
<p>The Fog Of War is divided into floors representing parts of your level. You can have as many as you want, and they can be
juxtaposed or even superposed to add verticality. Every floor shares the same settings provided by the handler and will have
the same precision. They are also divided into tiles and snapped to a grid to simplify the merge and update process. The FOW
can have up to 8 visibility channels to represent fog, but only 2 channels are used in the given version to represent 3 states
of fog:</p>
<ul>
<li>Seen: The player has visited the area and is aware of its layout.</li>
<li>Visible: The player directly sees the area.</li>
<li>Unseen: The player has never seen this area (meaning both channels are equal to 0).</li>
</ul>
<p>It's up to you to find more uses for the other 6 channels. You can also use only one channel to create MOBA-like games where
the map is fully visible.</p>
<h4 id="3-optimization-for-large-scale-projects"><a class="header" href="#3-optimization-for-large-scale-projects">3. Optimization for Large-Scale Projects</a></h4>
<p>To overcome update time, the FOW uses fog samples sent to the GPU and binary compression of everything related to a texture.
They are compressed such that 1 bit equals 1 pixel. This reduces memory usage and pixel processing time through bitwise operations.
Most of the update work involves merging two textures, applying an "OR" operator between them. Since all pixels are packed and
computers can use registers up to 512 bits, the FOW can compute up to 512 pixels in one operation.</p>
<h4 id="4-architecture-repercussions"><a class="header" href="#4-architecture-repercussions">4. Architecture Repercussions</a></h4>
<p>To allow the best usage of binary operations, channels had to be separated and can be seen as N different textures. Simplified
representation of the texture:</p>
<p>Normal texture:        -&gt;   FOW texture:<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br />
RGBA, RGBA, RGBA   -&gt;   RRR, GGG, BBB, AAA<br /></p>
<h3 id="tons-of-ai"><a class="header" href="#tons-of-ai">Tons of AI</a></h3>
<h4 id="1-introduction-1"><a class="header" href="#1-introduction-1">1. Introduction</a></h4>
<p>Projects utilizing FOW primarily involve games with extensive AI usage. One of the primary objectives was to simulate thousands
of units drawing fog. This plugin needed to be adaptable for games like "Among Us" as well as for RTS or MOBA games like "Age Of Empires"
or "League Of Legends." Once again, performance was a concern and needed to be addressed without compromising precision or map scaling.</p>
<h4 id="2-drawer-shareddrawer-entity-rasterizer"><a class="header" href="#2-drawer-shareddrawer-entity-rasterizer">2. Drawer, SharedDrawer, Entity, Rasterizer</a></h4>
<p>Each player controls a number of units within the game, aiding in navigation, exploration, and achieving game objectives. To explore
the game's layout, the FOW employs Drawers. These drawers are components registered within the FOW, generating fog fragments represented
as bit arrays. These fragments depict the sight of the owning actor, capable of drawing any shape and providing its fragment during
floor updates to generate the Fog Texture. However, merging thousands of fragments is inefficient, consuming excessive memory, lacking
alignment, demanding significant CPU cache, and failing to adhere to patterns that accelerate computation. To improve this process,
the FOW follows Data-Oriented Design (DOD) principles and enables developers to utilize Entities instead of drawers. Entities represent
objects in the game and supply data to a "SharedDrawer," which updates all registered entities during a single update.</p>
<p>To generate a fog fragment, each drawer has a reference to a rasterizer. Drawers serve as data containers designed to generate geometry
provided to them. They are simple code components that can be overridden for specific purposes. Currently, two rasterizers are available:</p>
<ul>
<li>UFOW_R_TriangledGeometryV1: Draws convex geometry from a set of vertices</li>
<li>UFOW_R_CircleV1: Draws a circle from a single vertex</li>
</ul>
<h4 id="3-optimization-for-large-scale-projects-1"><a class="header" href="#3-optimization-for-large-scale-projects-1">3. Optimization for Large-Scale Projects</a></h4>
<p>To expedite fragment generation, the FOW packs data and adheres to DOD architecture. It utilizes multithreaded processors through
asynchronous updates, allowing discrete updates that do not interfere with the game thread. In cases of heavy updates, the FOW can be
computed across multiple engine frames to prevent game freezing.</p>
<p>The DOD and task system serve as entry points to GPU computation. Every effort has been made to facilitate this and may be further
developed in the future.</p>
<h3 id="vertical-games"><a class="header" href="#vertical-games">Vertical Games</a></h3>
<h4 id="introduction"><a class="header" href="#introduction">Introduction</a></h4>
<p>Enabling the creation of vertical top-down games for everyone has been a challenge. I participated in the development of "Alien Dark Descent,"
where implementing ladders and stairs proved difficult. However, the Fog of War (FOW) couldn't distinguish between the bottom and the top,
making it impossible to allow players to explore the ground level and then the basement without a level transition. As mentioned earlier,
the Layered FOW comprises floors that can be placed anywhere in the game. They generate fog in the designated area, which drawers subsequently
remove. No additional user input is necessary to introduce verticality!</p>
<h4 id="gpu-data-transfer"><a class="header" href="#gpu-data-transfer">GPU Data Transfer</a></h4>
<p>Due to the GPU's limitations, it was challenging to send N textures representing the fog of floors. Additionally, the update process would
have been overly burdensome. It was necessary to devise a method to transmit data for each floor. This issue was addressed by packing floor
fog samples into one texture, with sample sizes determined by the intersection of the camera frustum and the floor fog plane. However, updating
every floor will require a larger texture.</p>
<p>To correctly render superposed floors, the material must project and identify the closest floors to query the fog state.</p>
<h3 id="networking"><a class="header" href="#networking">Networking</a></h3>
<h4 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h4>
<p>Most top-down games we play are competitive or cooperative, necessitating networking. In this regard, the FOW features minimal Replication
implementation. It operates on the premise that every player runs the same simulation, meaning every client actor shares the same position as
the server. If this condition holds true, there is no need to replicate the FOG state over the network; the only synchronization required is
determining which drawer represents which team.</p>
<h4 id="fogstatereplication-clientserver"><a class="header" href="#fogstatereplication-clientserver">FogStateReplication Client/Server</a></h4>
<p>FogStateReplication facilitates synchronization between the client and the server. It manages fog synchronization; the server can send the
FOW state to any client for game initialization and assigns a team ID to each client. This ID is utilized in each game instance to enable/disable
drawers associated with the same ID. Once the state and IDs are synchronized, no further FOW-related data is transmitted over the network.</p>
<h4 id="replication-and-team-limitation"><a class="header" href="#replication-and-team-limitation">Replication and Team Limitation</a></h4>
<p>To enable FOW state replication, the server must be aware of the state of each team. This means that a game using 2 channels to represent
"Seen" and "Visible" states can only accommodate up to 4 teams. As discussed earlier, the FOW can utilize a maximum of 8 channels. Replication
not only limits the number of teams a game can have but also imposes performance constraints. The server user must continuously compute
the fog for each team, even if only 1 team is displayed. Clients do not encounter this performance issue as they only update the attributed
team.</p>
<p>However, there is a workaround to mitigate this limitation. The server can be instructed to compute only for the user's team. While the
network will still function, FOW state synchronization will not be possible in case of a late connection. It's important to note that
synchronization is only necessary for a specific type of fog. Clients do not require synchronization if the game employs the Visible channel.
Once all drawers are synchronized with the correct team, they will remove fog at their location to replicate the server's state.</p>
<p>In summary, FOG state replication is possible but limited by the number of channels used per team. Alternatively, allowing the server to
compute the fog based on the player's ID removes this limitation, enabling as many teams as desired!</p>
<h3 id="developer-playground"><a class="header" href="#developer-playground">Developer Playground</a></h3>
<h4 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h4>
<p>This section is somewhat personal. I aimed for my plugin to be modular, with interchangeable parts. I've always believed that a better
version exists, leading me to segment my code and make it replaceable. This approach has become a pattern for me, creating small modules
and minimizing dependencies. Accordingly, the plugin includes numerous settings variables representing object classes to replace the
provided ones.</p>
<p>I call it a playground because it allows for simple modifications to test C++ functionality. There are numerous modules that serve as
containers for experimentation, enabling users to swap arrays for maps or add acceleration structures to aid in query functions. For
example, I've created a naive collision system that tests collisions with every registered collider, as well as another using an AABB
tree for querying colliders within bounds.</p>
<h4 id="this-is-where-the-fun-begins"><a class="header" href="#this-is-where-the-fun-begins">This is Where the Fun Begins!</a></h4>
<p>I aim to provide everything necessary for users to replace modules and experiment with the code in the source files. Here is a list
of the modules and their intended use:</p>
<ul>
<li>UFOW_Rasterizer: Experiment with the fastest way to draw a triangle or develop rasterizers specific to drawing geometry from formulas (e.g., Cone, torus, rectangle...)</li>
<li>UFOW_CollisionHandler: Crucial for drawer computation time when casting collision shadows. Accelerate collider querying with structures (e.g., AABB tree, Spatial hashing, octree...)</li>
<li>UFOW_OcclusionBuffer: Implements an occlusion system for the CollisionHandler to ignore colliders. Research and development around occlusion, with the default using a 1D depth buffer.</li>
<li>TFOW_Tile_Base: Merges drawer fog fragments. Experiment with SIMD instructions and find a faster way to merge everything.</li>
<li>UFOW_DrawerComponent: Implement custom drawers. Experiment with tasks and multithreading.</li>
<li>UFOW_SaveLoad: Generates a TArray<uint8> to be written in a file. Experiment with pointers and compression.</li>
<li>AFOW_FogStateReplication: Adapt the network to your pipeline.</li>
<li>AFOW_Handler: Adapt the loading or update pipeline.</li>
<li>UFOW_Floor: Adapt the update pipeline.</li>
</ul>
<h3 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h3>
<p>Everything functions correctly by default, but users may need to adjust some settings and have a good understanding of how entities
work for games with extensive AI usage. Vast games without vertical limits can be created, and a simple replication implementation
allows for the creation of online games. Curious users are encouraged to replace everything and experiment!</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section will explain in-depth how the Fog Of War has been thought out. It'll give you the keys to tweak
everything and set up the plugin to fit your game the best possible way.</p>
<p>Keep in mind that the Layered FOW doesn't need any modification to be used in game; only if performances are
an issue, modifications will be necessary.</p>
<h2 id="everything-is-tile-shaped"><a class="header" href="#everything-is-tile-shaped">Everything is Tile-shaped</a></h2>
<p>To allow high precision and large scale game, everything has been cut into pieces which can be seen as tiles.
This tiling system is really efficient for optimization and multithreading. The FOW is designed this way:</p>
<ul>
<li><code>FOWHandler</code>: the biggest piece holding every data. It's a singleton, and only one instance can exist in the level.</li>
<li><code>FOWFloors</code>: 3D boxes held by the Handler, where the fog will be applied. There is no number or position limitation. It will store a bits array of the fog state and everything necessary to generate fog fragment.</li>
<li><code>FOWTiles</code>: Defined by a power of 2 of fog pixels, it will create a grid for every element interacting with the fog. Used to merge fog fragment to the result texture in the Floors.</li>
<li><code>FOWTextureSample</code>: The bond between CPU and GPU, it will collect Floors bit array to send it to the GPU via a texture.</li>
</ul>
<h2 id="the-logic-is-managed-by-entities"><a class="header" href="#the-logic-is-managed-by-entities">The logic is managed by Entities</a></h2>
<p>The Entities are a suite of interfaces allowing data generation or querying. They are self-dependent and don't
need any update, no API is provided unless two methods to enable/disable the entity. The FOW will do all the
updates it needs to correctly generate the fog state of the frame. Entities exist in 3 different forms inheriting
from a base interface, plus one a bit different, designed for a late purpose:</p>
<ul>
<li><code>CollisionEntity</code>: Provide methods to gather collision from an object. Collisions are used by the drawers to cast shadow. The entity will be stored in CollisionHandler.</li>
<li><code>DrawingEntity</code>: Provide methods to collect drawing settings from an object. The entity will be registered to shared drawer to generate fog fragment.</li>
<li><code>VisibilityEntity</code>: Provide methods to collect object size and location to update its visible state depending on the fog.</li>
<li><code>GeometryEntity</code>: It doesn't derive from the Entity base class; its purpose is to hold geometry data to be used by entities (calling it GeometryEntity was a mistake).</li>
</ul>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-1"><a class="header" href="#pages-1">Pages</a></h1>
<ul>
<li><a href="book/architecture//book/architecture/Handler.html">Handler</a></li>
<li><a href="book/architecture//book/architecture/Floor.html">Floor</a></li>
<li><a href="book/architecture//book/architecture/Layers.html">Layers</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="book/architecture/Handler.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Handler.html#settings">Settings</a>
<ul>
<li><a href="book/architecture/Handler.html#editor-debug-setting">Editor debug setting</a></li>
<li><a href="book/architecture/Handler.html#fog-setting">Fog setting</a></li>
<li><a href="book/architecture/Handler.html#update-settings">Update settings</a></li>
<li><a href="book/architecture/Handler.html#module-settings">Module settings</a></li>
<li><a href="book/architecture/Handler.html#rendering-settings">Rendering settings</a></li>
</ul>
</li>
<li><a href="book/architecture/Handler.html#initialisation">Initialisation</a></li>
<li><a href="book/architecture/Handler.html#updates">Updates</a></li>
</ul>
</li>
</ul>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>The <code>AFOW_Handler</code> class is a singleton used to store <a href="book/architecture//book/architecture/Floor.html">Floors</a> and manage Fog settings such as Pixel size, Encoding,
and Collision system. It defines the initialization and update loop. All initialization happens during the begin play unless
for the floor generation that is instantiated straight into the editor.</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<h4 id="editor-debug-setting"><a class="header" href="#editor-debug-setting">Editor debug setting</a></h4>
<ul>
<li><code>ShowGrid</code>: display the grid delimited by the tile. Floors are snapped to this grid.</li>
<li><code>ShowFloors</code>: display the 3D box representing the floors. The pink square is the real position of the floor, it will
be aligned to the grid. The yellow square is the 3D Fog representation.</li>
</ul>
<h4 id="fog-setting"><a class="header" href="#fog-setting">Fog setting</a></h4>
<ul>
<li><code>PixelSize</code>: lets you adapt the fog precision, the value is expressed in centimeters.</li>
<li><code>FOWFloors</code>: lets you create new game areas with fog.</li>
<li><code>TilePixelNumber</code>: lets you change the tile dimension by modifying their pixel number. Changing tile size might become
interesting for high fog precision, it will reduce the number of tile merging and will allow the usage of bigger registers for the merging.</li>
<li><code>ChannelToClearAtStart</code>: lets you choose the default fog status at start. Useful if you have a map with hidden area
and the rest visible. Use <code>AFOW_DrawingE_Custom</code> with <code>UFOW_FloorStartUpLayer</code> to add fog where it's needed. Fog will
be cleared and redrawn during the initialization and the very first frame.</li>
<li><code>LayerHandler_Class</code>: lets the possibility to the user to organize the layer merging.</li>
<li><code>FOWFloorTiles_Class</code>: lets you choose the number of channels used by the game. It is also designed to select the computation method
of tile merging. Warning register used cannot be bigger than <code>TilePixelNumber</code>.</li>
</ul>
<h4 id="update-settings"><a class="header" href="#update-settings">Update settings</a></h4>
<ul>
<li><code>FOWComputeSetting</code>: Change the right of the FOW to use or not multithreading/Task/ComputeShader (compute shader not done yet).</li>
<li><code>FOWUpdateRate</code>: Change the update rate of the FOW. However I do not recommend to use it, render will be impacted and become less
smooth. I recommend to enable task and let the FOW do discrete updates.</li>
</ul>
<h4 id="module-settings"><a class="header" href="#module-settings">Module settings</a></h4>
<p>Modules that can be changed in the handler are stored under the <code>Settings|Class</code> section. There is a differentiation between static
and dynamic because some modules can be more or less optimized depending on those two parameters (The AABBCollisionHandler has an
update time super long for dynamic objects).</p>
<h4 id="rendering-settings"><a class="header" href="#rendering-settings">Rendering settings</a></h4>
<ul>
<li><code>FOWShader_Class</code>: change the render system of the FOW. 3 different materials are provided with the plugin:
<ul>
<li><code>MPP_FOW_Floors</code>: for flat game</li>
<li><code>MPP_FOW_FloorsTransparency</code>: for games with verticality</li>
<li><code>MUI_FOW_Minimap</code>: for the minimap</li>
</ul>
</li>
</ul>
<h3 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h3>
<p>The initialization of the FOW happens in the begin play and can be delayed if your pipeline needs it. Initialization is split into
many sections:</p>
<ul>
<li><code>InitNetwork</code> will create a <strong>Replicated</strong> environment only if the game isn't standalone and if the Network setting class is
correctly set. Set network setting has the right to override many values from the Handler to provide the accessibility to different
clients. Thus it has to be executed first.</li>
<li><code>InitTeams</code> isn't used and will be deleted.</li>
<li><code>InitFOWFloorsTiles</code>: Allocates the memory used by the floor. The FOW cannot do anything without it. The tiles must be
initialized before the game shader.</li>
<li><code>InitGameShader</code>: Generates <code>FOWTextureSample</code> that will be linked to the instantiated <code>FOWShader_Class</code>. You can override this to
generate more material if needed. However, you have the possibility to create and register texture sample at any time; don't force
yourself to do everything in this method.</li>
<li><code>InitFOWUpdate</code> is the most interesting method. If you have pipeline trouble, I recommend to let every other initialization call
and to delay only this one. Until this call is made, no update from the fog but even from this entity or the collision system will
happen. <strong>Please be very cautious to call <code>FinalizeInitialization</code> just after the call of this method.</strong></li>
</ul>
<h4 id="visual-representation-of-the-initialisation-pipeline"><a class="header" href="#visual-representation-of-the-initialisation-pipeline">Visual representation of the initialisation pipeline</a></h4>
<p><img src="book/architecture/../../assets/Architecture/Handler/FOWInitialisation.drawio.png" alt="FOWHandler initialisation pipeline" /></p>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>By default, the update happens during the actor tick. Every component of the FOW will be updated during this sequence unless for
the <code>FOWTextureSample</code>. The update will be done at once if no asynchronous tasks are requested and will be managed by two methods:</p>
<ul>
<li><code>FOWUpdate_Begin</code> manages every update that needs to happen to let drawers generate fog fragment. It'll update the dynamic Entities
first and then the collision. It will also be responsible for multithreading initialization.</li>
<li><code>FOWUpdate_End</code> is called after that the drawers have generated their fog fragment. Depending on the usage of task or compute shader,
it'll be called right after the begin update or later in the frame. Fog fragment will be sorted and distributed to floors to update the
fog state. Once updated transient drawer will be deleted and all "visibleEntity" will update their state to turn on/off their render.</li>
</ul>
<p>The <code>FOWTextureSample</code> has a special place to be updated because of the engine camera update time. To generate fog sample the sample
has to be aware of the position of the camera; however, Unreal updates their position at the end of the tick. To prevent sample from
sending wrong texture information, their updates happen at the very end of the world tick. There is a second reason of why their update
is separated and independent. In case of long update, the FOW can skip an update frame if using asynchronous update. It doesn't impact
the render to not change the fog state, however, fog data on the GPU has to be perfectly synchronized with game or artifacts might show up.</p>
<h4 id="visual-representation-of-the-updates-pipeline"><a class="header" href="#visual-representation-of-the-updates-pipeline">Visual representation of the Updates pipeline</a></h4>
<p><img src="book/architecture/../../assets/Architecture/Handler/FOWUpdate.drawio.png" alt="FOWHandler update pipeline" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor"><a class="header" href="#floor">Floor</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="book/architecture/Floor.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Floor.html#settings">Settings</a></li>
<li><a href="book/architecture/Floor.html#fog-update">Fog Update</a></li>
</ul>
</li>
</ul>
<h2 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h2>
<p>The <code>AFOW_Floor</code> class represents 3D boxes held by the <a href="book/architecture//book/architecture/Handler.html">Handler</a>, where the fog is applied. The fog is stored in a "bit array"
that is updated and sampled every frame. The update is facilitated by the <code>TFOW_Tile_Base</code> class, which shares the bit array pointer to
allow multithreading and prevent unnecessary updates if no Drawer fragment has updated the tile area. Floors contain all the entities
within them, registered in:</p>
<ul>
<li><code>UFOW_Drawer_Shared</code> for <code>UFOW_DrawingEntity_Interface</code>, with the base class defined in <code>FOW_LayerSetting</code></li>
<li><code>UFOW_CollisionHandler</code> (static/dynamic) for <code>UFOW_CollisionEntity_Interface</code>, with the base class defined in <code>AFOW_Handler</code></li>
<li><code>UFOW_EntityVisibilityHandler</code> (static/dynamic) for <code>UFOW_VisibilityEntity_Interface</code>, with the base class defined in <code>AFOW_Handler</code></li>
</ul>
<h3 id="settings-1"><a class="header" href="#settings-1">Settings</a></h3>
<p>You'll find a few settings to configure the floors in your environment:</p>
<ul>
<li><code>FloorLocation</code>: defines the center of the floor.</li>
<li><code>FloorExtend</code>: defines the 2D extent of the floor.</li>
<li><code>FloorZExtend</code>: Represents the height of the fog. X represents the fog under the floor center, and Y represents the fog above the floor center.</li>
<li><code>bOverrideChannelToClearAtStart</code>: Allows you to override the <code>FOW_Handler</code> setting of the fog state at start.</li>
<li><code>bSnapFloorExtendToGrid</code>: Snaps the floor extent to the tile grid.</li>
</ul>
<h3 id="fog-update"><a class="header" href="#fog-update">Fog Update</a></h3>
<p>Every update is called by the handler, with four main updates:</p>
<ul>
<li><code>UpdateCollision</code>: done during <code>FOWUpdate_Begin</code> by the <code>UFOW_CollisionHandler</code></li>
<li><code>UpdateFogState</code>: done during <code>FOWUpdate_End</code></li>
<li><code>UpdateVisibleEntityState</code>: done during <code>FOWUpdate_End</code> by the <code>UFOW_EntityVisibilityHandler</code></li>
<li><code>UpdateFogTextureSample</code> or <code>GetFogTextureSampleRegions</code>: done during <code>UpdateTexture</code>. This update is special and cannot be changed; it's
bound to <code>FWorldDelegates::OnWorldTickEnd</code> to ensure the position of every game camera.</li>
</ul>
<p>The fog state is a heavy update which merges fog fragments of every Drawer. To achieve this, both the fragment and the floor's bits
arrays are sliced into tiles. Tiles are instantiated and stored in floors, they all derive from <code>TFOW_Tile_Base</code>. It facilitates the
transformation of Drawer data into a readable texture from the GPU. Each tile receives arrays of pointers linked to Drawer fog fragments;
if the array is empty, the tile is skipped and reset if updated during the previous frame. The fog state generated depends on the
<code>UFOW_LayerSetting</code> bound to the Drawer and by the <code>UFOW_LayerHandler</code>, which provides the update order. The LayerSettings are non-instantiated
classes that convert all their Settings into a flag. They are read by the Tiles and interpreted as the code writer intends. Every modification
regarding channel behavior or computation will require another Tile class.</p>
<h4 id="visual-representation-of-the-updates-pipeline-1"><a class="header" href="#visual-representation-of-the-updates-pipeline-1">Visual Representation of the Updates Pipeline</a></h4>
<p><img src="book/architecture/../../assets/Architecture/Floor/FloorUpdate.drawio.png" alt="Floor update pipeline" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="book/architecture/Layers.html#explanation">Explanation</a>
<ul>
<li><a href="book/architecture/Layers.html#layer-settings">Layer Settings</a>
<ul>
<li><a href="book/architecture/Layers.html#rasterizer">Rasterizer</a></li>
<li><a href="book/architecture/Layers.html#shared-drawer">Shared drawer</a></li>
<li><a href="book/architecture/Layers.html#shared-drawer-max-entities">Shared drawer max entities</a></li>
<li><a href="book/architecture/Layers.html#inverse-bits">Inverse bits</a></li>
<li><a href="book/architecture/Layers.html#static-drawer">Static drawer</a></li>
<li><a href="book/architecture/Layers.html#transient">Transient</a></li>
</ul>
</li>
<li><a href="book/architecture/Layers.html#layer-handler">Layer Handler</a>
<ul>
<li><a href="book/architecture/Layers.html#collision-drawing">Collision drawing</a></li>
<li><a href="book/architecture/Layers.html#computation-order-layer-class">Computation order layer class</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h2>
<p>Layers are the representation of a rendering pipeline. they define how a fog fragment impact the fog state
and are applied in a given order. The <code>UFOW_LayerSetting</code> will be the class used by every drawer tp define
their behavior. The <code>UFOW_LayerHandler</code> is held by the <code>FOW_Handler</code> and will be the pipeline reference for
every fog state update.</p>
<h3 id="layer-settings"><a class="header" href="#layer-settings">Layer Settings</a></h3>
<p>There isn't any logic, except converting settings to a flag mask, in the <code>LayerSettings</code>. They have been
made to simplify the pipeline understanding, to help when custom configurations are needed and to enable
or disable optimization.</p>
<p>About the generated settings flags, you have to understand that they mean nothing without a <code>TFOW_Tile_Base</code>
able to read it. The flag mask is an <code>int32</code> with only 4 bits used. This means that you have the possibility
to create other settings to provide to the <code>Tiles</code> if you want to create new channels or if other conditions
are needed for your fog to be computed.</p>
<h4 id="rasterizer"><a class="header" href="#rasterizer">Rasterizer</a></h4>
<p>The <code>Rasterizer Class</code> lets you choose which rasterizer will be used by the <code>Drawer</code> for the fog fragment
generation. Depending on the situation, a specialized rasterizer can be a real gain and improve the performance.
As an example, two rasterizers are provided in the plugin:</p>
<ul>
<li><code>UFOW_R_TriangledGeometryV1</code>: used to rasterize convex geometry with the vertices correctly sorted.</li>
<li><code>UFOW_R_CircleV1</code>: used to rasterize circles only. It will read geometries one vertex by one and use them as a <code>2D position</code> and a <code>Radius</code>.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/12_RasterizerUsage.png" alt="Layers" /></p>
<p>Rasterizers define how geometry will need to be provided. You can create others to fit specific cases or to
optimize the rasterization process.</p>
<h4 id="shared-drawer"><a class="header" href="#shared-drawer">Shared drawer</a></h4>
<p>The <code>Shared Drawer Class</code> allows you to choose which drawer class will be used for the update of Entities.
The Drawer will then be instantiated and contained by a <code>Floor</code>. Every Entity contained in the floor will be
provided to this drawer, which will ensure the generation of the fog fragment. There are 3 kinds of shared drawers:</p>
<ul>
<li><code>UFOW_Drawer_Shared</code>: will query geometry from entities and rasterize it on the fog fragment. Use <code>UFOW_R_TriangledGeometryV1</code> as Rasterizer.</li>
<li><code>UFOW_SDrawer_Circle</code>: will query geometry from entities, however, it's designed to receive a single vertex per entity to draw a circle. Use <code>UFOW_R_CircleV1</code> as Rasterizer.</li>
<li><code>UFOW_SDrawer_FOV</code>: will query position from the entities to compute shadow geometries from the <code>CollisionHandler</code>. Then, every shadow is rasterized. Use <code>UFOW_R_TriangledGeometryV1</code> as Rasterizer.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/8_SharedDrawerPresentation.png" alt="Layers" /></p>
<p><code>Shared drawer</code> is responsible for querying data from geometries and to provide it to the rasterizer. They will
also be responsible for choosing how the fog fragment will be computed:</p>
<ul>
<li>Game thread</li>
<li>Game thread with parallel for</li>
<li>Task</li>
<li>Compute shader (Not provided yet)</li>
</ul>
<p>You are free to create others to improve or make them fit to your game pipeline.</p>
<h4 id="shared-drawer-max-entities"><a class="header" href="#shared-drawer-max-entities">Shared drawer max entities</a></h4>
<blockquote>
<p><strong>This setting only makes sense if multithreading or compute shader are enabled.</strong></p>
</blockquote>
<p>The <code>Shared drawer max entities</code> value is an optimization variable. It is used to limit the numbers of entity
per <code>Shared Drawers</code>. The meaning behind this isn't that your game will have a limited number of entities but
that another drawer will be instantiated if one is full. This will allow the system to create many tasks instead
of only one if you have lots of entities sharing the same <code>LayerSettings</code>.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/15_SharredDrawerMaxEntity.png" alt="Layers" /></p>
<p>If you let the variable be 0 or less, <code>Shared Drawers</code> won't have entities limit and will be updated like so:</p>
<ul>
<li>The red square represents 2400 drawers computed in 1 thread.</li>
<li>The green square represents the start of the fog fragments generation.</li>
<li>The blue square represents the end of the fog fragments generation.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/15_1_SharredDrawerMaxEntity_0.png" alt="Layers" /></p>
<p>If you increase the limits (500 was used for the example), multiple <code>Shared Drawers</code> will be instantiated
and your computer will take benefit of the other cores in the processor:</p>
<ul>
<li>The red square represents 2400 drawers computed in 5 threads.</li>
<li>The green square represents the start of the fog fragments generation.</li>
<li>The blue square represents the end of the fog fragments generation.</li>
</ul>
<p><img src="book/architecture/../../assets/Architecture/Layers/15_2_SharredDrawerMaxEntity_500.png" alt="Layers" /></p>
<blockquote>
<p><strong>Caution, update task might become too present to let the Engine start its own. It might be more interesting
to accept lots of entity per drawer which might reduce the fog state refresh rate instead of the whole game frame
rate.</strong></p>
</blockquote>
<h4 id="inverse-bits"><a class="header" href="#inverse-bits">Inverse bits</a></h4>
<p>The <code>Inverse bits</code> is a parameter for the rasterizer. This will tell the rasterizer to draw the geometry with 0
instead of 1. It is only used when geometry shadows need to be represented. Those drawers will entirely reveal
their fog fragment and hide parts with collision geometry. There's no need to understand what it really does,
just turn it on if the drawer will cast shadows.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/16_InverseBitsUsage.png" alt="Layers" /></p>
<h4 id="static-drawer"><a class="header" href="#static-drawer">Static drawer</a></h4>
<p>The <code>Static drawer</code> value is an optimization variable. By setting it to true, you tell the system that all entities
provided won't move. This means that the entities will generate their fog fragment only once until one of them moves
or if an Entity is added or removed. This parameter is mostly used by the collider to reduce the number of triangles
rasterized to represent their shadows.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/9_StaticDrawersUsage.png" alt="Layers" /></p>
<h4 id="transient"><a class="header" href="#transient">Transient</a></h4>
<p>It simplifies the implementation of one or a few frame drawing drawers. It's often heavy to write delegate and bind
to the system to ensure at least one update. With this enabled, the system will try to destroy the associated drawer
every frame.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/10_TransientDrawersUsage.png" alt="Layers" /></p>
<p>You might not want to draw for only one frame, in that case, you can override <code>RequestDestruction</code> in CPP and BP to
add a timer or verify a condition before calling <code>DestroyAndUnregister</code>.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/11_TransientDrawersDestructionOverride.png" alt="Layers" /></p>
<h3 id="layer-handler"><a class="header" href="#layer-handler">Layer Handler</a></h3>
<p>Layer Handler is a class made for global settings regarding the update pipeline of the fog state.</p>
<h4 id="collision-drawing"><a class="header" href="#collision-drawing">Collision drawing</a></h4>
<p>The <code>Collision drawing</code> is an optimization variable. It's disabled by default because of the issues it can bring to
the render. If enabled, all colliders will have the possibility to draw their collision geometry to a <code>Shared Drawer</code>,
only if <code>ShouldBeDrawn</code> is set to true in your <code>CollisionEntity</code>.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/13_LayerHandlerDrawCollider.png" alt="Layers" /></p>
<p>The problem behind this optimization is that the collider will always display their shadow even if you are over them.
It'll be mostly annoying for games with verticality.</p>
<p><img src="book/architecture/../../assets/Architecture/Layers/14_LayerHandlerDrawColliderIssue.png" alt="Layers" /></p>
<p>To resume, if your game doesn't use fog verticality, you're advised to enable it.</p>
<h4 id="computation-order-layer-class"><a class="header" href="#computation-order-layer-class">Computation order layer class</a></h4>
<p>The <code>Computation order layer class</code> array will define the update order of the fog fragment. All of them are bound to
a <code>LayerSettings</code> and need to be merged to update the fog state. This array lets you modify the merging order. All of
the <code>LayerSettings</code> used in your game have to appear in this list or you will trigger an ensure. Be careful when re-ordering
it, you might create unwanted results if you don't pay attention between layers removing fog and layers adding fog.</p>
<h2 id=""><a class="header" href="#"><img src="book/architecture/../../assets/Architecture/Layers/17_LayerHandlerComputationOderClass.png" alt="Layers" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>Here we will showcase the step-by-step process of basic usage of the Layered Fog Of War - both for C++ and Blueprint
implementation. If you want to be in the same condition as the pictures are, you can download my
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a> and use the map in the tutorial folder. <br />
If you need help installing the plugin, you can watch this <a href="https://www.youtube.com/watch?v=BVz-TQKzHNY">Video</a>.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-2"><a class="header" href="#pages-2">Pages</a></h1>
<ul>
<li><a href="book/Tutorials//book/Tutorials/First_set_up.html">First set up</a></li>
<li><a href="book/Tutorials//book/Tutorials/Layers.html">Layers</a></li>
<li><a href="book/Tutorials//book/Tutorials/Outdoor_Indoor.html">Outdoor Indoor</a></li>
<li><a href="book/Tutorials//book/Tutorials/Networking.html">Networking</a></li>
<li><a href="book/Tutorials//book/Tutorials/FogChannels.html">Fog Channels</a></li>
<li><a href="book/Tutorials//book/Tutorials/Floor_Verticality.html">Floor and Verticality</a></li>
<li><a href="book/Tutorials//book/Tutorials/Minimap.html">Minimap</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-set-up"><a class="header" href="#first-set-up">First set up</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="book/Tutorials/First_set_up.html#installation">Installation</a></li>
<li><a href="book/Tutorials/First_set_up.html#set-up-the-fog">Set up the fog</a></li>
<li><a href="book/Tutorials/First_set_up.html#going-further">Going further</a></li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Minimaps</code> map providen in the demo project.
If not done yet, download the Demo project <a href="https://github.com/gandoulf/LayeredFOW_Demo">Here</a> <br />
Install the plugin in the project, helping video <a href="https://www.youtube.com/watch?v=BVz-TQKzHNY">Here</a> <br /></p>
<h2 id="set-up-the-fog"><a class="header" href="#set-up-the-fog">Set up the fog</a></h2>
<p>This part will explain how to use the Fog Of War in the easiest and fastest possible way!</p>
<p>Drag and drop a <code>BP_FOWHandler</code> from the quickly add button, keyboard is enabled to allow you fast search</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/1_DragAndDropFOWHandler.png" alt="FOWHandler update pipeline" /></p>
<p>Once in your scene you will see two boxes:</p>
<ul>
<li>Yellow one, representing the Fog in 3D</li>
<li>Pink one, representing the fog aligned to the tile grid</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/2_DragAndDropFOWHandler_Result.png" alt="FOWHandler update pipeline" /></p>
<p>Add a <code>FOW_Drawer_FOV</code> to the BP_TutorialCharacter</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/3_AddDrawerToTheCharacter.png" alt="FOWHandler update pipeline" /></p>
<p>Hit the play button for the first preview of the FOW !!</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/4_PlayGameWithFog.png" alt="FOWHandler update pipeline" /></p>
<p>Now that the FOW is running we're gonna add collision to limit the sight of character.
Add <code>FOW_CollisionEntity_BoxComponent</code> to the four walls in the map</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/5_AddCollisionToWall.png" alt="FOWHandler update pipeline" /></p>
<p>You will have to reset the scale of the box collision to 1 to make them fit to the asset</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/6_ResetCollisionScaleTo1.png" alt="FOWHandler update pipeline" /></p>
<p>Boxes are cool but might be a bit limited, let's see how to do otherwise
Add <code>FOW_CollisionEntity_CustomComponent</code> to the cylinder in the map.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/7_AddCustomCollisionToWall.png" alt="FOWHandler update pipeline" /></p>
<p>In the details panel, select the component and Add 8 vertices to the <code>CustomGeometryVertices</code> array.
Position the vertices in top view such as they fit to the object, grid snapping might be annoying.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/8_AddVerticesToYourCustomCollider.png" alt="FOWHandler update pipeline" /></p>
<p>You can hit the play button again and see that the cylinder collision is projected!</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/8.1_CollistionAreCasted.png" alt="FOWHandler update pipeline" /></p>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>If you are setting up the FOW for a custom map you can change the size and position of the floor
in BP_FOWHandler in the details panel. You can also add other floors to extend your game however
you want. check the <a href="book/Tutorials//book/Tutorials/"></a><a href="book/Tutorials/Floor_Verticality.html">Floor page</a> for more information to set up the fog in your level.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/9_AdapteTheFOWToYourGame.png" alt="FOWHandler update pipeline" /></p>
<p>The base radius of the <code>FOW_Drawer_FOV</code> component might be too small, don't hesitate to change it
in the actor holding the component. Modify the <code>DrawerRadius</code> value to provide a larger sight to your units.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/10_ChangeRadiusSize.png" alt="FOWHandler update pipeline" /></p>
<p>You can change the fog precision of the FOW in the <code>BP_FOW_Handler</code> by going in the details panel
and by changing the <code>PixelSize</code> value. By default, the fog pixel is set to 25 centimeters</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FirstSetUp/11_Chance_the_fog_precision.png" alt="FOWHandler update pipeline" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-of-war-entities"><a class="header" href="#fog-of-war-entities">Fog of War Entities</a></h1>
<p>The entities system is used by default as a solution to memory fragmentation causing heavy updates. It has
been designed with this fact in mind but also to allow anything to be part of the FOW. Entities are collected
and stored under containers to keep required data for the system update. They inherit from <code>UFOW_Entity_Interface</code>,
which is a <code>UInterface</code>. I'm using the Unreal interface implementation to allow callable functions for Blueprint-only
users. The downside of it is that entities have to be at least a <code>UObject</code>.</p>
<p>The Entities can be implemented only on the C++ side. However, many predefined <code>Actor</code> and <code>ActorComponent</code>
are provided with already implemented interfaces. You will find in those derived classes two functions allowing
you to <code>EnableEntity()</code> or <code>DisableEntity()</code> anywhere at any time. There is no other API; they are self-sufficient,
and their updates are managed by the containers.</p>
<blockquote>
<p><strong>/!\ The links under apparently don't work, I'm trying to figure it out, please use the links on the left <br /></strong></p>
</blockquote>
<h1 id="pages-3"><a class="header" href="#pages-3">Pages</a></h1>
<ul>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Visibility_Entity.html">Visibility Entity</a></li>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Drawing_Entity.html">Drawing entity</a></li>
<li><a href="book/Tutorials/entities//book/Tutorials/entities/Collision_Entity.html">Collision entity</a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-entity"><a class="header" href="#visibility-entity">Visibility Entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#drawing-entity-components">Visibility Entity Components</a></li>
<li><a href="book/Tutorials/entities/Visibility_Entity.html#visibility-entity-cpp-implementation">Visibility Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Entities</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<h2 id="visibility-entity-components"><a class="header" href="#visibility-entity-components">Visibility Entity Components</a></h2>
<p>This component implements <code>IFOW_VisibilityEntity_Interface</code> and allows your game to change the visibility
of your actors depending on the fog state.</p>
<p><img src="book/Tutorials/entities/../../../Assets/Tutorial/Entities/Visibility/0_MergePictureVisibilityComponent2.png" alt="VisibilityEntityComponent" /></p>
<p>To use it, add a <code>FOW_VisibilityEntity_Component</code> to an instanced actor or to your existing Blueprint.
The component will by default hide the actor if it is not in sight.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/1_AddVisibleEntityToActor.png" alt="VisibilityEntityComponent" /></p>
<p>To go a bit further, if you want to apply custom code when the visibility state changes, you can implement
the <code>OnVisibilityChanged</code> event from the component in your Blueprint.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/2_CustomVisibilityUpdate.png" alt="VisibilityEntityComponent" /></p>
<p>By default, the FOW state is returned as a uint8, which doesn't mean much for you, but it is a mask
representing the 8 channels. You can transform it to a more readable enum by calling <code>GetFOWStateFromBits</code>.
Now just switch on the returned enum to apply your custom code. For example, I'm just drawing a debug sphere.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/3_DrawDebugSphereOnVisibilityChanged.png" alt="VisibilityEntityComponent" /></p>
<p>And here you go, a green sphere appears when the actor is revealed, and a red one appears when the player
loses sight of it.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/4_DrawDebugSphereForVisibility.png" alt="VisibilityEntityComponent" /></p>
<p>If the popping render displeases you, you can turn it off by unchecking <code>DisableRenderOutSight</code>. If you
do so, nothing will happen anymore, and you will have to do the magic by yourself, perhaps a material
translucency transition or an explosion?</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Visibility/5_DisablePremadeVisibilityEffect.png" alt="VisibilityEntityComponent" /></p>
<h2 id="visibility-entity-cpp-implementation"><a class="header" href="#visibility-entity-cpp-implementation">Visibility Entity cpp implementation</a></h2>
<p>You can make your own visibility component or directly turn your <code>UObject</code> into entities and give them
the possibility to react to the Fog state. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-entity"><a class="header" href="#drawing-entity">Drawing entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#drawing-entity-components">Drawing Entity Components</a></li>
<li><a href="book/Tutorials/entities/Drawing_Entity.html#drawing-entity-cpp-implementation">Drawing Entity Cpp implementation</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Entities</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<h2 id="drawing-entity-components"><a class="header" href="#drawing-entity-components">Drawing Entity Components</a></h2>
<p>There are multiple <code>DrawingEntity</code> components implementing the <code>IFOW_DrawingEntity_Interface</code>. Three different kinds of them exist for now:</p>
<ul>
<li><code>Geometry drawers</code>: They will pierce fog by rasterizing a given geometry. Used by <code>FOW_DrawingEntity_BoxComponent</code>.</li>
<li><code>Circle drawers</code>: They will pierce fog with a specific rasterizer only able to trace circles. Used by <code>FOW_DrawingEntity_CircleComponent</code>.</li>
<li><code>FOV drawers</code>: They will pierce fog by collecting the colliders to create shadow geometries. Used by <code>FOW_DrawingEntity_FOVComponent</code>.</li>
</ul>
<p>All <code>DrawingEntity</code> work the same; they hold data and the given <code>UFOW_LayerSetting</code> will define how this data will be used to pierce the Fog.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/0_DefaultDrawingSetupMerged.png" alt="DrawingEntityPicture" /></p>
<p>To use them, add a <code>FOW_DrawingEntity_CircleComponent</code> / <code>FOW_DrawingEntity_BoxComponent</code> / <code>FOW_DrawingEntity_FOVComponent</code> to an instanced
actor or to your existing <code>Blueprint</code>. The default settings of those components are made to pierce the fog.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/1_AddingDrawingCircleToActor.png" alt="DrawingEntityPicture" /></p>
<p>All drawers will have barely the same settings:</p>
<ul>
<li><code>IsEnableAtStart</code>: Define if the entity starts drawing from the BeginPlay or if it will be enabled later by calling <code>EnableEntity()</code>.</li>
<li><code>TeamIndexAtStart</code>: Define for which team the entity will be drawing. The team can be changed at runtime by calling <code>SetEntityTeam()</code>.</li>
<li><code>Static/DynamicLayerSettingClass</code>: Define how the drawer will bring modification to the fog. Those can't be changed at runtime.</li>
<li>The advanced section is only necessary for multiple <code>FOW_Floor</code> games. Their behavior will be explained later.</li>
</ul>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Drawing/2_DrawingEnitySettingsOverView.png" alt="DrawingEntityPicture" /></p>
<h2 id="drawing-entity-cpp-implementation"><a class="header" href="#drawing-entity-cpp-implementation">Drawing Entity cpp implementation</a></h2>
<p>You can make your own drawing component or directly turn your <code>UObject</code> to entities and give them the possibility to alter the state of the fog. To be done...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collision-entity"><a class="header" href="#collision-entity">Collision entity</a></h1>
<ul>
<li><a href="book/Tutorials/entities/Collision_Entity.html#collision-entity-component">Collision Entity Component</a></li>
<li><a href="book/Tutorials/entities/Collision_Entity.html#collision-entity-cpp-implementation">Collision Entity cpp implementation</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Entities</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<h2 id="collision-entity-component"><a class="header" href="#collision-entity-component">Collision Entity Component</a></h2>
<p>There are multiple <code>CollisionEntity</code> components implementing the <code>IFOW_CollisionEntity_Interface</code>. All collisions
work the same; they store geometry that will be given to a <code>UFOW_CollisionHandler</code>. The handler will then provide
query class to collect collider information. The geometry can be convex and concave; it's only required to correctly
sort the vertices.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/0_SetupCollisionComponentMerged.png" alt="CollisionEntityPicture" /></p>
<p>To use them, add a <code>FOW_CollisionEntity_BoxComponent</code> or <code>FOW_CollisionEntity_CustomComponent</code> to an instanced actor
or to your existing blueprint. I use for the example the box component; if you want to use the custom component to
generate custom collision, you will have to provide vertices.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/2_AddBoxCollisionComponent.png" alt="CollisionEntityPicture" /></p>
<p>Select the <code>FOW_CollisionEntity_BoxComponent</code> and reset the scale to 1.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/3_ResetCollisionBoxScaleToOne.png" alt="CollisionEntityPicture" /></p>
<p>If you take a look at the collision entity settings, you will see that <code>Static/DynamicLayerSettingClass</code> are required.
It's the case because colliders are also <code>DrawingEntities</code>; their geometry can be drawn on a fog fragment by a drawer
as an optimization if <code>ShouldBeDrawn</code> is checked. See the <a href="book/Tutorials/entities//book/Tutorials/entities/../Layers.html">Layer tutorial</a> for more information.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/4_CollisionEntityGeneralParameters.png" alt="CollisionEntityPicture" /></p>
<p>Collisions are subject to heavy update time in every game. It is the same for the FOW; collision takes time to query.
To optimize those queries, we're using acceleration structures that are super fast; however, their update or construction
time might be heavy. To overcome this issue, we split static colliders from dynamic. It's really important for your game
to have actors set correctly to <code>static</code> or <code>movable</code> depending on your needs. Static collision is significantly faster
than dynamic.</p>
<p><img src="book/Tutorials/entities/../../../assets/Tutorial/Entities/Collision/5_SetCollidersMobilityToStatic.png" alt="CollisionEntityPicture" /></p>
<h2 id="collision-entity-cpp-implementation"><a class="header" href="#collision-entity-cpp-implementation">Collision Entity cpp implementation</a></h2>
<p>You can make your own collision component or directly turn your <code>UObject</code> to entities and give them the possibility to
block the sight of drawers. To be done...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers-1"><a class="header" href="#layers-1">Layers</a></h1>
<ul>
<li><a href="book/Tutorials/Layers.html#create-and-add-layers">Create and Add Layers</a></li>
<li><a href="book/Tutorials/Layers.html#static-layers-and-optimization">Static Layers and Optimization</a></li>
</ul>
<p>For this tutorial use <code>Tutorial/Maps/TutorialMap</code> or <code>Tutorial/Maps/TutorialMap_Collider</code> map provided in
the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h2 id="create-and-add-layers"><a class="header" href="#create-and-add-layers">Create and Add Layers</a></h2>
<p>This part will explain how <code>LayerSettings</code> work and how you can create new ones for your games. First, you have
to know that they are dissociated to provide different information to the FOW but also to provide a computation
order during the fog fragment merging. It can be compared to a rendering pipeline. To register a new layer, you
will have to create a <code>LayerHandler</code>.</p>
<p>Let's try to change the behavior of the drawer on your character. We want him to reveal only the black fog but
not to give him sight.</p>
<p>Create a new BP_MyLayerHandler derived from <code>FOW_LayerHandler</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/1_CreateLayerHandler_BP.png" alt="Create Layer Handler BP" /></p>
<p>Create a new BP_MyFOVLayer derived from <code>FOW_LayerSettings</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/2_CreateLayerSetting_BP.png" alt="Create Layer Setting BP" /></p>
<p>Open your layer handler and add the new layer you've just created. Add it just under the <code>FOW_FOVLayer</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/3_OpenAndAddNewLayerSetting.png" alt="Open And Add New Layer Setting" /></p>
<p>Now we need to tell the <code>FOW_Handler</code> that we are using a new layer pipeline. Select the <code>BP_FOW_Handler</code> and
change in the details panel, in the class section, the value of the <code>LayerHandlerClass</code> to the one you've created</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/4_ChangeTheLayerHandler.png" alt="Change The Layer Handler" /></p>
<p>Open the blueprint holding the <code>FOVDrawer</code>, select it and go to the detail panel. Scroll to the <code>LayerSettingClass</code>
and replace it with the one you've created</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/5_ReplaceTheLayerSettingClass.png" alt="Replace The Layer Setting Class" /></p>
<p>Now that everything is correctly set, we can change the behavior of the <code>LayerSetting</code>. Open the blueprint, turn
the <code>InverseBits</code> to true (I'm going to ask you to trust me on that, every FOV Layers will need this to be true)
and set the <code>RevealSight</code> to false and <code>RevealFog</code> to true. Doing so will prevent the player from having sight
on <code>VisibilityEntity</code> however the layout will be revealed</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/6_ChangeLayerSettings.png" alt="Change Layer Settings" /></p>
<p>Enjoy your new layer setting! Check out the <a href="book/Tutorials//book/Tutorials/Visibility_entity.html">Visibility Entity page</a> to really understand
the difference between <code>RevealSight</code> and <code>RevealFog</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/7_PiercingOnlySightFog.png" alt="Piercing Only Sight Fog" /></p>
<h2 id="static-layers-and-optimization"><a class="header" href="#static-layers-and-optimization">Static Layers and Optimization</a></h2>
<p>The FOW is a heavy piece of code to update and optimization is present almost everywhere. Sadly optimization can
have counterparts. Static layers can be really interesting to reduce the computation time; it will prevent the
re-generation of a fog fragment (heaviest update) if the drawer and the entities bound to it haven't moved.</p>
<p>The plugin uses static layers only for collision; geometry will be collected and drawn into a fog fragment and be
merged with other fragments during every update. Doing so prevents the sight drawing from using the whole collider
vertices to cast shadow.</p>
<p>To enable this optimization first open your <code>LayerHandler</code> and check the <code>DrawFOWCollider</code> box.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/8_LayerHandlerDrawCollider.png" alt="Layer Handler Draw Collider" /></p>
<blockquote>
<p><strong>Caution, this optimization is really effective for colliders if the owning actor is static.</strong></p>
</blockquote>
<p>This setting provides the possibility for every collider to send its geometry to a <code>SharedDrawer</code>. By default,
every collider is set to do so. You can disable this feature by unchecking <code>ShouldBeDrawn</code> from the <code>CollisionEntity</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/9_DisableColliderEntityDrawing.png" alt="Disable Collider Entity Drawing" /></p>
<p>If the colliders are drawn, the collision shadow will remain even if the collider isn't in sight. <code>ShouldBeDrawn</code>
is enabled on the left and disabled on the right.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Layers/10_CollisionDrawing.png" alt="Collision Drawing" /></p>
<p>It might sound weak as an optimization since there are only 4 vertices in a rectangle. But if you multiply the few
triangles by the number of colliders and by the number of AI, we're talking about milliseconds saved by the update.
It's even more effective for custom collision with a lot of vertices.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outdoor-indoor"><a class="header" href="#outdoor-indoor">Outdoor Indoor</a></h1>
<ul>
<li><a href="book/Tutorials/Outdoor_Indoor.html#setup-indoor-area">Setup indoor area</a></li>
</ul>
<p>For this tutorial use the <code>Tutorial/Maps/TutorialMap_Collider</code> map provided in
the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h2 id="setup-indoor-area"><a class="header" href="#setup-indoor-area">Setup indoor area</a></h2>
<p>Depending on the game, you might need to dissociate the indoor from the outdoor, such as only the indoors are
undiscovered. From my experience, it's easier to clear the whole FOW and add fog to the indoor area. The next
picture represents the result we will have step by step:</p>
<ul>
<li>
<ol>
<li>FOW display without any setup</li>
</ol>
</li>
<li>
<ol start="2">
<li>FOW display when revealing the whole fog</li>
</ol>
</li>
<li>
<ol start="3">
<li>FOW display after adding the indoor fog</li>
</ol>
</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/0_Fog_Indoor_Outdoor_Example.png" alt="Outdoor Indoor" /></p>
<p>First, get the <code>BP_FOW_Handler</code> and go to the detail panel. Find the <code>ChannelToClearAtStart</code> and check the
<code>chan2</code> box. It will set the default value of the second channel of every floor to 1 to clear the black fog.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/1_ClearFogAtStart.png" alt="Outdoor Indoor" /></p>
<p>Now we're gonna draw back the fog in the 2 indoor areas. There are two types of drawing entities provided to do so:</p>
<ul>
<li><code>FOW_DrawingEntity_Box</code>, drawing fog in a box</li>
<li><code>FOW_DrawingEntity_Custom</code>, drawing fog in the provided custom geometry</li>
</ul>
<p>Drag and drop both of the drawing entities to your scene and let's set up the indoor fog.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/2_AddDrawingEntities.png" alt="Outdoor Indoor" /></p>
<p>First, move the <code>FOW_DrawingEntity_Box</code> to the tiny room and scale it to be as big as the room.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/3_SetUpBoxDrawing.png" alt="Outdoor Indoor" /></p>
<p>Second, move the <code>FOW_DrawingEntity_Custom</code> to the bigger room and add 8 vertices in the <code>CustomGeometryVertices</code>
in the details panel. Select the top view for the viewport and place the vertices around the room.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/4_SetUpCustomDrawing.png" alt="Outdoor Indoor" /></p>
<p>Finally, By default, Drawers will remove fog; however, this time we need to add fog and only when the game starts.
A specific <code>LayerSettings</code> is provided to do so. In both drawing entities, in the details panel, replace the static
and dynamic layer setting class by <code>FOW_FloorStartUpLayer</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/IndoorOutdoor/5_ChangeDrawersLayerSettings.png" alt="Outdoor Indoor" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-1"><a class="header" href="#networking-1">Networking</a></h1>
<ul>
<li><a href="book/Tutorials/Networking.html#default-replication-setup">Default Replication Setup</a></li>
<li><a href="book/Tutorials/Networking.html#manage-player-team">Manage Player Team</a></li>
<li><a href="book/Tutorials/Networking.html#infinite-team">Infinite Team</a></li>
</ul>
<blockquote>
<p><strong>/!\ This tutorial is made to show how the FOW works with networks, replication knowledge won't be provided.
Networking <code>GameMode</code>, <code>GameState</code>, <code>Controller</code>, and <code>Character</code> are provided. You have absolutely the right to
read, copy, and use any code you find :) <br /></strong></p>
</blockquote>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Networking</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="default-replication-setup"><a class="header" href="#default-replication-setup">Default Replication Setup</a></h1>
<p>The <code>TutorialMap_Networking</code> has been set up to show you how replication and teams work. To do so a
<code>BP_TutorialNetworking_GameMode</code> has been set up with a <code>BP_TutorialNetworking_PlayerController</code> to spawn a
<code>BP_TutorialNetworking_Character</code> at a <code>PlayerStart</code> location depending on the Client team. <br />
To visualize the replication, the server will clear the fog of another spawn point for each team before the
client connection. <br /></p>
<ul>
<li>The circle represents the spawn point</li>
<li>The square is the associated revealed spawn point</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/0_NetworkingMapSetup.png" alt="Networking" /></p>
<p>There is a little trouble with Unreal and singleton instance when they are stored in a static variable. If you
hit the play button with multiple players in the editor, multiple worlds will be created but inside the same
application, which means static variables are shared and overridden. To prevent this, the FOW is designed to look
for an implementation of <code>FOW_GetHandlerInstance_Interface</code> in the <code>GameState</code>. <br /></p>
<p>Let's set up the game state. Create a new <code>My_FOWNetworking_GameState</code> derived from <code>GameStateBase</code></p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/1_CreateNewGameState.png" alt="Networking" /></p>
<p>Open it and go into <code>ClassSettings</code> to add the <code>FOW_GetHandlerInstance_Interface</code> in the <code>ImplementedInterfaces</code> array.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/2_AddGetHandlerInterface.png" alt="Networking" /></p>
<p>Now you have to provide the code to the <code>Find_Level_FOWHandler</code>.</p>
<ul>
<li>Add a <code>FOW_Handler</code> variable</li>
<li>Get the variable and convert it to a <code>Validate</code> get, if valid return the variable.</li>
<li>Else find all actors of class <code>FOW_Handler</code></li>
<li>If at least one is returned, set your <code>FOW_Handler</code> variable to the first element of the array</li>
<li>Return the variable</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/3_AddCodeToTheInterfaceMethod.png" alt="Networking" /></p>
<p>Now open the <code>BP_TutoralNetworking_GameMode</code> and replace the <code>GameState</code> with yours</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/4_ChangeDefaultGameState.png" alt="Networking" /></p>
<p>All set up!</p>
<blockquote>
<p><strong>Note that if you don't simulate the network in the editor, this whole setting isn't needed. As long as
every game instance is a separate process, you don't need to implement the interface.</strong></p>
</blockquote>
<p>Now let's see how the FOW works with replication. First, create a new <code>BP_MyNetworkSettings</code> derived from <code>UFOW_NetworkSettings</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/5_MakeNetworkSettingClass.png" alt="Networking" /></p>
<p>Open it and change the <code>NetworkGameMaxTeamNbr</code> value from the <code>Server</code> to 4. It means that the <code>FOW_Handler</code> will
be ready to handle 4 different teams drawing fog separately. (For a few reasons, 4 teams with two channels enabled
is the maximum). Also, if you pay attention, the client is set to only one team, which means that only the client
team fog will be updated.<br />
Under those settings, you will find checkboxes to allow or not replication and which channels are replicated. The
first channel isn't needed since it represents the fog of what drawers currently see.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/6_SetUpTheLayerSettings.png" alt="Networking" /></p>
<p>Select the <code>BP_FOW_Handler</code>, get into the details panel, and change the <code>NetworkSettingsClass</code> to your <code>BP_MyNetworkSettings</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/6.1_ChangeFOWHandlerNetworkSettings.png" alt="Networking" /></p>
<p>Before hitting the play button change the <code>PlaySettings</code>. Change the number of players to 4 and change <code>NetMode</code> to <code>PlayAsListenServer</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/7_ChangeTheEditorPlaySettings.png" alt="Networking" /></p>
<p>Now you can hit the play button and see the 4 windows open with your character connecting one by one. If you do not
understand what the fog replication changes, go back to your <code>BP_MyNetworkSettings</code> and uncheck <code>bIsFogStateReplicated</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/8_NetworkingResult.png" alt="Networking" /></p>
<h1 id="manage-player-team"><a class="header" href="#manage-player-team">Manage Player Team</a></h1>
<p>The previous part was about setting up the network over the FOW. However, you couldn't do anything regarding which
client is associated with which team because of the default system distributing the players to each team.</p>
<p>Let's see how to do that. Create a <code>BP_MyFogStateReplication_Server</code> derived from <code>AFOW_FogStateReplication_Server</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/9_CreateNewFogStateReplication.png" alt="Networking" /></p>
<p>Open it and override the <code>GetClientTeamIndex</code> function.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/10_OpenAndOverrideGetClientTeamIndex.png" alt="Networking" /></p>
<p>Open it. This is where you can manage the client team association. the <code>PlayerController</code> is provided, You should
be able to fetch necessary data from your game with it. For the example let's just do this:</p>
<ul>
<li>Get the <code>NetworkMaxTeamNbr</code> and subtract 1 from it</li>
<li>Pin the result to a <code>Random Integer in Range</code></li>
<li>Pin the result to the return;</li>
</ul>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/11_AddCustomCodeToGetClientTeamIndex.png" alt="Networking" /></p>
<p>Now that the server is set up, open your <code>BP_MyNetworkSettings</code> and replace the <code>FogStateReplicationClass</code> by your <code>BP_MyFogStateReplication_Server</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/12_ChangeFogStateReplicationClassServer.png" alt="Networking" /></p>
<p>Hit the Play button and see the players being associated with a random team!</p>
<h1 id="infinite-team"><a class="header" href="#infinite-team">Infinite Team</a></h1>
<p>In case you want more than 4 teams with two channels, you can just uncheck <code>bIsFogStateReplicated</code>, Set the
<code>NetworkGameMaxTeamNbr</code> for both client and server to 1 and provide any team index you want in the <code>GetClientTeamIndex</code> override.</p>
<blockquote>
<p><strong>This replicated team number issue will be taken care of; it might not allow an infinite number but more than 4 for sure</strong></p>
</blockquote>
<p><img src="book/Tutorials/../../assets/Tutorial/Network/13_InfinitTeamForNonReplicatedFog.png" alt="Networking" /></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog-channels"><a class="header" href="#fog-channels">Fog Channels</a></h1>
<ul>
<li><a href="book/Tutorials/FogChannels.html#basic">Basic</a></li>
<li><a href="book/Tutorials/FogChannels.html#advanced">Advanced</a></li>
</ul>
<p>This tutorial is based on solo games; everything related to channels needs to be taken with caution when applied to
teams. However, everything works the same; teams will only limit the number of available channels.</p>
<p>For this tutorial use the <code>Tutorial/Maps/TutorialMap_Collider</code> map provided in
the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h2 id="basic"><a class="header" href="#basic">Basic</a></h2>
<p>The FOW has up to 8 configurable channels that you can use. (Be careful with games having teams) The channels may
or may not all be used. For the default setup of the FOW, only two channels are used:</p>
<ul>
<li>The first channel defines what the player currently sees.</li>
<li>The second channel defines what the player has seen.</li>
</ul>
<p>This setup is mostly used for narrative games or RTS with procedural maps, but you might want to make a game more
MOBA-oriented with everything revealed to the players, which means that you only need the first channel to represent
the sight of the player.</p>
<p>Let's change the FOW to have only one channel. First, select the <code>BP_FOW_Handler</code>, go to the details panel and click
on the <code>FOWFloorTilesClass</code> input field, and select <code>TFOW_T128b_1Chan_Pck_Class</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/1_ChangeTileFormat.png" alt="Change Tile Format" /></p>
<p>Still in the <code>BP_FOW_Handler</code> details panel, find the <code>FOWShaderClass</code> variable and open the provided material; it
should be <code>MPP_FOW_Floors</code>.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/2_OpenTheFOWMaterial.png" alt="Open The FOW Material" /></p>
<p>Find the material function with 8 channel output pin and unlink the <code>chan2</code> from the linked <code>lerp</code> node. The <code>Alpha</code>
value should be set to 1.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/3_UnpinBlackChannelSetAlphaTo1.png" alt="Unpin Black Channel Set Alpha To 1" /></p>
<p>You should be done; press play and check that the FOW correctly displays only one channel.</p>
<p><img src="book/Tutorials/../../assets/Tutorial/FogChannel/4_GameWithOnlyOneChannelComputed.png" alt="Game With Only One Channel Computed" /></p>
<p>You might have figured out that only doing the material part would have done the trick, and yes it would have. But you
would have let the FOW do all the computation in CPU and GPU of the <code>Chan2</code>.</p>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<p>In the advanced part, I'll show you how to implement and use more than 2 channels by creating new <code>FOW_Tile_Class</code> and
<code>FOW_LayerSetting</code>. To be done ...</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floor-and-verticality"><a class="header" href="#floor-and-verticality">Floor and Verticality</a></h1>
<ul>
<li><a href="book/Tutorials/Floor_Verticality.html#add-floors">Add Floors</a></li>
<li><a href="book/Tutorials/Floor_Verticality.html#enable-verticality">Enable Verticality</a></li>
</ul>
<p>This tutorial has been realized in the <code>Tutorial/Maps/TutorialMap_Floors</code> map provided in the <a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a>.</p>
<blockquote>
<p><strong>The multi-floor feature is in progress and can create undesirable rendering artifacts. Most of them are known and
will be dealt with in the next version. However, you can still prototype your game with it; the system will remain the
same.</strong></p>
</blockquote>
<h1 id="add-floors"><a class="header" href="#add-floors">Add Floors</a></h1>
<p>Floors are the area representation of the fog in the editor. You can add as many as you want, and they are represented
by a yellow rectangle and a pink plane.</p>
<ul>
<li>The rectangle represents the fog area; everything inside will be impacted by fog.</li>
<li>The plane represents the fog extent clamped to tiles. Fog is not constrained to the rectangle for now, but it might
become the case soon. It also dissociates the top from the bottom of the fog when modifying the ZExtend.</li>
</ul>
<p>To add a new floor, select the <code>FOW Handler</code>. In the details panel, find the <code>FOWFloors</code> array and add an element.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/1_AddFloorToMap.png" alt="AddFloorToMap" /></p>
<p>Find the new element, which should be set to <code>None</code>, and change its value to <code>FOW_Floor</code>.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/2_SelectFloorClass.png" alt="SelectFloorClass" /></p>
<p>In the added element, you will find a <code>FloorLocation</code> variable in the settings section, allowing you to change the
position of the floor. Move it so that the other part of the plane is included in the new floor.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/3_MoveTheFloorInY.png" alt="MoveTheFloorInY" /></p>
<p>As I mentioned, there are currently a few artifacts between floors around the junctions. You can see sharp fog lines
not affected by blur.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/4_UndersirableArtifactsAtIntersection.png" alt="UndesirableArtifactsAtIntersection" /></p>
<h1 id="enable-verticality"><a class="header" href="#enable-verticality">Enable Verticality</a></h1>
<p>The fog of war is an algorithm used for 2D gameplay and mostly competitive games like MOBA/RTS. It has been a challenge
to open the door to a new kind of game which could take benefits from verticality.</p>
<p>To use verticality in your game, you have to first change the <code>PostProcess</code> used to render the fog. Select the <code>FOW_Handler</code>,
in the details panel find the <code>FOWShaderClass</code> and change the <code>MPP_FOW_Floors</code> to <code>MPP_FOW_FloorsTransparency</code>.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/5_ChangePostProcess.png" alt="ChangePostProcess" /></p>
<p>Still in the <code>FOW_Handler</code>, add 2 new floors and I advise you to change the editor view to <code>Front</code>; it'll simplify the
positioning of the floors. As with the previous floor, you will have to change the <code>FloorLocation</code>. Try to center the
fog plane to the gameplay area in Y and Z.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/6_AddThreeFloorAndMoveYZ.png" alt="AddThreeFloorsandMoveYZ" /></p>
<p>With the default settings, you should have a gap between your floors, and it's better to not have them. Reach the settings
of each floor and change the <code>Y</code> value of the <code>ZExtend</code>. It'll enlarge the bottom part of the yellow square.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/7_RemoveTheBetweenFloor.png" alt="RemovetheGapBetweenFloors" /></p>
<p>One last thing, many settings are provided to the material and one can generate conflict with verticality. To disable it,
select the <code>FOW_Handler</code>, in the details panel find the <code>MPC_FOWRenderSettings</code> and open it.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/8_OpenMPC_FOWRenderSettings.png" alt="OpenMPC_FOWRenderSettings" /></p>
<p>Find the <code>bEnableHeightGrading</code> scalar value and set it to 0.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Floors_Verticality/9_RemoveHeightGrading.png" alt="RemoveHeightGrading" /></p>
<p>As explained at the beginning of this tutorial, the multi-floor rendering is still in progress and the vertical transition
hasn't been properly cleaned.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimap"><a class="header" href="#minimap">Minimap</a></h1>
<ul>
<li><a href="book/Tutorials/Minimap.html#minimap-setup">Minimap setup</a></li>
</ul>
<p>This tutorial has been realised in the <code>Tutorial/Maps/TutorialMap_Minimaps</code> map providen in the
<a href="https://github.com/gandoulf/LayeredFOW_Demo">Demo Project</a></p>
<h1 id="minimap-setups"><a class="header" href="#minimap-setups">Minimap setups</a></h1>
<p>The plugin has a minimaliste integration of a minimap. the tutorial will show you how to set it up and the
providen blueprint will give all the necessary knowledge to generate fog sample and link it to a custom material
if you wanna make your own system. <br />
Go into the <code>Plugins/LayeredFogOfWarContent/Minimap</code> folder in the content browser. You will find 4 files:</p>
<ul>
<li><code>BP_FOW_Floor_Minimap</code>, In-game blueprint catching input, instancing and updating Fog sample, Material, Widget.</li>
<li><code>BP_FOW_MapTextureGenerator</code>, An actor with a 2D scene camera to generate map texture of your level.</li>
<li><code>RT_FOW_MapTexture_Output</code>, Render target used by the camera of Map texture generator.</li>
<li><code>WBP_FOW_Minimap</code>, Widget added to the viewport displaying the minimap.</li>
</ul>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/1_OpenMinimapFolderFromPlugin.png" alt="MinimapPicture" /></p>
<p>Add the <code>BP_FOW_Floor_Minimap</code> to your scene inside a <code>FOW_Floor</code>. The position of the actor is important because
it will collect the data of the floor it overlappe to send it to the material.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/2_AddFloorMinimap.png" alt="MinimapPicture" /></p>
<p>Add the <code>BP_FOW_MapTextureGenerator</code> to your scene.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/3_AddMapTextureGenerator.png" alt="MinimapPicture" /></p>
<p>Open the <code>RT_FOW_MapTexture_Output</code> which is already linked to the camera of the Map texture generator, it will
display the result of the map.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/4_OpenRenderTargetAndDisableAlpha.png" alt="MinimapPicture" /></p>
<p>Now change the <code>Location</code> and the <code>Camera Width</code> of the <code>BP_FOW_MapTextureGenerator</code> to generate an acccurate picture
of the level.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/5_SetUpPositionAndCameraWith.png" alt="MinimapPicture" /></p>
<p>When the setting are done, find the <code>RT_FOW_MapTexture_Output</code> in your content browser, right click on it and generate
a <code>StaticTexture</code>. Move it to another folder out of the plugin.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/6_CreateStaticTexture.png" alt="MinimapPicture" /></p>
<p>Now you have to copy the settings used to generate the texture to the <code>BP_FOW_Floor_Minimap</code>. They are requiered to
generate a corresponding plane in the material to apply the texture.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/7_ChangeFloorMinimapSettingsMerged.png" alt="MinimapPicture" /></p>
<p>You can now hit the play button and see a minimap on the bottom right. You can display a bigger version by pressing
<code>Tab</code> which will display a full screen version of it.</p>
<p><img src="book/Tutorials/../../Assets/Tutorial/Minimap/8_DeleteTestAndPressTab.png" alt="MinimapPicture" /></p>
<p>The minimap can handler displacement, rotation and scale (zoom). if the minimap havn't the correct orientation you
can apply static rotation to the texture and the Fog sample</p>
<h2 id="-1"><a class="header" href="#-1"><img src="book/Tutorials/../../Assets/Tutorial/Minimap/9_AddConstantRotation.png" alt="MinimapPicture" /></a></h2>
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//reference/reference/classes/AFOW_Handler.html"><code>AFOW_Handler</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_CollisionEntity_Interface.html"><code>IFOW_CollisionEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_DrawingEntity_Interface.html"><code>IFOW_DrawingEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_Entity_Interface.html"><code>IFOW_Entity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_GeometryEntity_Interface.html"><code>IFOW_GeometryEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/IFOW_VisibilityEntity_Interface.html"><code>IFOW_VisibilityEntity_Interface</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_CollisionHandler.html"><code>UFOW_CollisionHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_DrawerComponent.html"><code>UFOW_DrawerComponent</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Drawer_Shared.html"><code>UFOW_Drawer_Shared</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityContainer.html"><code>UFOW_EntityContainer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_EntityVisibilityHandler.html"><code>UFOW_EntityVisibilityHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Floor.html"><code>UFOW_Floor</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerHandler.html"><code>UFOW_LayerHandler</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_LayerSetting.html"><code>UFOW_LayerSetting</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Rasterizer.html"><code>UFOW_Rasterizer</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_TextureSample.html"><code>UFOW_TextureSample</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_Tile_Class.html"><code>UFOW_Tile_Class</code></a></li>
<li><a href="reference//reference/reference/classes/UFOW_VisibilityE_Component.html"><code>UFOW_VisibilityE_Component</code></a></li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-afow_handler"><a class="header" href="#class-afow_handler"><strong>Class: <code>AFOW_Handler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API AFOW_Handler
    : public AActor;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The Fog Of War Handler is the base class of the plugin, it's a sigleton and you cannot have many instance of it even when doing networked game with replication<br />
The Fog Of War is highly parametrable and let the developers override almost everything. You might want to get ride of some functionality or maybe to write a more optimized code<br />
The handler hasn't any main logic, it's purpose is to:</p>
<ul>
<li>Have general settings</li>
<li>Initialise FOW Object</li>
<li>Run the update</li>
<li>Contain FOW element instancies</li>
</ul>
<p>You have the possibility to change the core module of the FOW by changing the default class used int the settings</p>
<blockquote>
<ul>
<li>If you want a custom FOWHandler be sure to override FindLevelFOWHandler, you can use <strong><code>AFOW_Handler_Default</code></strong> as example</li>
<li>Go to the FOWFloors settings and display the parametters to shape the floor to your needs</li>
</ul>
</blockquote>
<p>If you need to modify the initialization to fit your pipeline, override those function called by the BeginPlay</p>
<ul>
<li>void InitNetwork();</li>
<li>void InitTeams();</li>
<li>void InitFOWFloors();</li>
<li>void InitFOWFloorsTiles();</li>
<li>void InitGameShader();</li>
<li>void InitFOWUpdate();</li>
<li>void FinalizeInitialization();
Please be really carefull to not finalize the initialization if the floor or game shader init havn't be called</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_collisionentity_interface"><a class="header" href="#class-ifow_collisionentity_interface"><strong>Class: <code>IFOW_CollisionEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_CollisionEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Collision entities are the sight blocker to prevent fog discovering between rooms.<br />
By design any child implementing this class should also implement <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> to enable optimisation</p>
<blockquote>
<ul>
<li>Depending of the situation you can have issues because of collision drawing optimisation, Override ShouldDrawColliders and return false to disable it</li>
<li>You can disable the whole collision drawing optimisation by disabling DrawFOWCollider in <a href="reference/classes//reference/classes/UFOW_LayerHandler.html"><strong><code>UFOW_LayerHandler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_drawingentity_interface"><a class="header" href="#class-ifow_drawingentity_interface"><strong>Class: <code>IFOW_DrawingEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_DrawingEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Drawing entity used to modify the state of the fog depending of the given <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Override GetEntityLayerSetting to give the correct layer setting</li>
<li>Call SetEntityTeam to change the entity team in case of multiplayer game</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_entity_interface"><a class="header" href="#class-ifow_entity_interface"><strong>Class: <code>IFOW_Entity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Base class for every entity interface, <a href="reference/classes//reference/classes/IFOW_GeometryEntity_Interface.html"><strong><code>IFOW_GeometryEntity_Interface</code></strong></a> is an exception subject to a retake</p>
<blockquote>
<ul>
<li><a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a></li>
<li><a href="reference/classes//reference/classes/IFOW_VisibilityEntity_Interface.html"><strong><code>IFOW_VisibilityEntity_Interface</code></strong></a></li>
</ul>
</blockquote>
<p>Entities are by default automatically updated by the system if (IsStatic == false &amp;&amp; FloorVolatile)</p>
<blockquote>
<ul>
<li>FloorVolatile express the posibility to move from a floor to another</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : every multiple inheritance have specifique overriding rule regarding methodes finishing by _M.<br />
You can use <strong><code>AFOW_CustomCollision</code></strong> as examble for your custom entity implementation</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_geometryentity_interface"><a class="header" href="#class-ifow_geometryentity_interface"><strong>Class: <code>IFOW_GeometryEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_GeometryEntity_Interface;
</code></pre>
<hr />
<p>Geometry entity is a data container used by entities to modify fog or create collision.</p>
<blockquote>
<ul>
<li>Geometries are by default automatically updated by the system if (static == false || modular)</li>
<li>Override UpdateEntityGeometry to make your modification</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityContainer.html"><strong><code>UFOW_EntityContainer</code></strong></a></p>
<p>Warning : The geometry system should be retaken to make the geometry aligned in memory</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ifow_visibilityentity_interface"><a class="header" href="#class-ifow_visibilityentity_interface"><strong>Class: <code>IFOW_VisibilityEntity_Interface</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API IFOW_VisibilityEntity_Interface
    : public IFOW_Entity_Interface;
</code></pre>
<hr />
<p>Visibility entity used to automatically update the ingame visibility of the UObject inherited from it</p>
<blockquote>
<ul>
<li>VisibilityEntity are by default automatically updated</li>
<li>Override OnVisibilityStateChanged to update the visibility state</li>
<li>You can find a default example by looking at <strong><code>UFOW_VisibilityComponent</code></strong>.</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<p>For more information of the entity virtual fonction please see <a href="reference/classes//reference/classes/IFOW_Entity_Interface.html"><strong><code>IFOW_Entity_Interface</code></strong></a>.</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_collisionhandler"><a class="header" href="#class-ufow_collisionhandler"><strong>Class: <code>UFOW_CollisionHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_CollisionHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Collision handler is used to accelerate the querying of collider to generate sight mask<br />
Every handler is associated to its <strong><code>UFOW_CollisionHandlerQuery</code></strong> class</p>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawercomponent"><a class="header" href="#class-ufow_drawercomponent"><strong>Class: <code>UFOW_DrawerComponent</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_DrawerComponent
    : public UActorComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The drawer component compute fog modification, however it doesn't apply it.<br />
They are small chunk of fog aligned to the world grid, they can be seen as canvas.<br />
Their update are the slowest because of the collision querying and the geometry rasterization.<br />
By default they are mean to be added to each actor modifying the fog however the memory allocation and merging can become very time consuming.<br />
If your game needs higher performance take a look at <a href="reference/classes//reference/classes/IFOW_CollisionEntity_Interface.html"><strong><code>IFOW_CollisionEntity_Interface</code></strong></a> which will request the creation of a <a href="reference/classes//reference/classes/UFOW_Drawer_Shared.html"><strong><code>UFOW_Drawer_Shared</code></strong></a> to the system.<br /></p>
<p>It is possible to :</p>
<blockquote>
<ul>
<li>Create custom drawer by inheriting from this class and by overriding GenerateDrawerGeometry to inject your custom geometry</li>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
<li>Change the collision querying by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onlyregistervalideteam"><a class="header" href="#onlyregistervalideteam"><strong><code>OnlyRegisterValideTeam</code></strong></a></h1>
<pre><code class="language-cpp">protected:
bool OnlyRegisterValideTeam;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadWrite</strong></li>
<li><strong>EditAnywhere</strong></li>
<li><strong>Category</strong> = <em>Settings</em></li>
</ul>
<hr />
<p>To allow flexibility allow every drawer to be registered in the FOWHandler, it might slighly increase UpdateDrawerLayer parsing time
But it will remove every network synchronisation issues if the client team change</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_drawer_shared"><a class="header" href="#class-ufow_drawer_shared"><strong>Class: <code>UFOW_Drawer_Shared</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Drawer_Shared
    : public UFOW_DrawerComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
<li><strong>BlueprintType</strong></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>Drawer designed to hold <a href="reference/classes//reference/classes/IFOW_DrawingEntity_Interface.html"><strong><code>IFOW_DrawingEntity_Interface</code></strong></a> and batch their update under one process</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entitycontainer"><a class="header" href="#class-ufow_entitycontainer"><strong>Class: <code>UFOW_EntityContainer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityContainer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>Dynamic entity and geometry container. Called by the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a> to update their status</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_entityvisibilityhandler"><a class="header" href="#class-ufow_entityvisibilityhandler"><strong>Class: <code>UFOW_EntityVisibilityHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_EntityVisibilityHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Update the visibility of every registered object implementing IFOW_VisibilityEntity_Interface.<br />
The class is instantied twice in every <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> for Static and dynamic entity.<br />
Each entity will query the FOW state at location or for an AABB on the owner FOW_Floor.<br /></p>
<blockquote>
<ul>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Override OnVisibilityStateChanged methode in IFOW_VisibilityEntity_Interface to apply custom modification</li>
<li>Bind your object to OnVisibilityChanged if you are using FOW_VisibilityComponent</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="visibleentities"><a class="header" href="#visibleentities"><strong><code>VisibleEntities</code></strong></a></h1>
<pre><code class="language-cpp">protected:
TArray&lt;TScriptInterface&lt;IFOW_VisibilityEntity_Interface&gt;&gt; VisibleEntities;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadOnly</strong></li>
<li><strong>Category</strong> = <em>Internal</em></li>
</ul>
<hr />
<p>Hold the visible entity</p>
</li>
</ul>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="prepareforworlddestruction"><a class="header" href="#prepareforworlddestruction"><strong><code>PrepareForWorldDestruction</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void PrepareForWorldDestruction();
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Call before the world destruction to prevent all Remove or Add operation</p>
  </details>
</li>
<li>
<h1 id="updatevisibilitystate"><a class="header" href="#updatevisibilitystate"><strong><code>UpdateVisibilityState</code></strong></a></h1>
<pre><code class="language-cpp">public:
virtual void UpdateVisibilityState(
    const UFOW_Floor* Floor,
    uint8 FOWGlobalSettingFlags
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>Core</em></li>
</ul>
<hr />
<p>Update the visibility state of all registered entity</p>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="floor-1"><a class="header" href="#floor-1"><strong><code>Floor</code></strong></a></h2>
<pre><code class="language-cpp">const UFOW_Floor* Floor
</code></pre>
</li>
<li>
<h2 id="fowglobalsettingflags"><a class="header" href="#fowglobalsettingflags"><strong><code>FOWGlobalSettingFlags</code></strong></a></h2>
<pre><code class="language-cpp">uint8 FOWGlobalSettingFlags
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_floor"><a class="header" href="#class-ufow_floor"><strong>Class: <code>UFOW_Floor</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Floor
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>EditInlineNew</strong></li>
</ul>
<hr />
<p>The floor is an area where a bit mask texture is generated to create fog.<br />
Each floor bit mask will be sliced and attributed to a <strong><code>TFOW_Tile_Base</code></strong>.<br />
It's responsible of the fog state update by querying the fog chunk of every drawer.<br />
Every levels can have many instances of floor to allow verticallity for your game.<br />
Each floor has a collision handler static and dynamic and is responsible for the collision update.<br /></p>
<blockquote>
<ul>
<li>Change the collision system by creating a new <a href="reference/classes//reference/classes/UFOW_CollisionHandler.html"><strong><code>UFOW_CollisionHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
<li>Change the visibility system by creating a new <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<p>Warning : supperposed floor will work correctly only if you change the PP material in <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layerhandler"><a class="header" href="#class-ufow_layerhandler"><strong>Class: <code>UFOW_LayerHandler</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerHandler
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The layer handler allow you to change the computation order of the different <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></p>
<blockquote>
<ul>
<li>Layer will modify the fog state in the given order, which means that a modification can be overriden by an other layer</li>
<li>Enable or disable the collision drawing optimisation by changing DrawFOWCollider</li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_layersetting"><a class="header" href="#class-ufow_layersetting"><strong>Class: <code>UFOW_LayerSetting</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_LayerSetting
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>Layer setting is made to configure how an entity or a drawing component will modify the fog</p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_rasterizer"><a class="header" href="#class-ufow_rasterizer"><strong>Class: <code>UFOW_Rasterizer</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Rasterizer
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
</ul>
<hr />
<p>The rasterizer convert the geometries to a bit mask texture representing the state of the FOW.<br />
The reasterizer is never instantied, the default object is always used witch means that you cannot use variable in the class</p>
<blockquote>
<ul>
<li>Change the rasterization process by creating a new <a href="reference/classes//reference/classes/UFOW_Rasterizer.html"><strong><code>UFOW_Rasterizer</code></strong></a> and by changing the default class used in the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a></li>
</ul>
</blockquote>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_texturesample"><a class="header" href="#class-ufow_texturesample"><strong>Class: <code>UFOW_TextureSample</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_TextureSample
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>abstract</strong></li>
<li><strong>Blueprintable</strong></li>
</ul>
<hr />
<p>The texture sample collect sample of FOW from the <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a> to write it inside a texture that will be bind to materials</p>
<p>Contained by : <a href="reference/classes//reference/classes/AFOW_Handler.html"><strong><code>AFOW_Handler</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_tile_class"><a class="header" href="#class-ufow_tile_class"><strong>Class: <code>UFOW_Tile_Class</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_Tile_Class
    : public UObject;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>Abstract</strong></li>
</ul>
<hr />
<p><strong><code>TFOW_Tile_Base</code></strong> aren't a UCLASS to prevent saturation of GC, thus they are all wrapped by a FOW_Tile_Class and allocated the old way.<br />
Tiles are used to compute fog result of the <a href="reference/classes//reference/classes/UFOW_DrawerComponent.html"><strong><code>UFOW_DrawerComponent</code></strong></a> and merge it depending of the <a href="reference/classes//reference/classes/UFOW_LayerSetting.html"><strong><code>UFOW_LayerSetting</code></strong></a> under a bit array that will feed the <a href="reference/classes//reference/classes/UFOW_TextureSample.html"><strong><code>UFOW_TextureSample</code></strong></a> sent to the GPU.<br />
You can simply create your own tile update by overriding this class and by using the templated class <strong><code>TFOW_Tile</code></strong>.
you will have to create 3 templated classes to finish your fully custom tiles :</p>
<ul>
<li>Update</li>
<li>Compute</li>
<li>Merge</li>
</ul>
<blockquote>
<ul>
<li>Override GetTileBitsFormat to correctly set the tile pixel number for the FOW</li>
<li>Override GetTileChannelNbr to correctly set the channels number per tiles</li>
<li>Override GetTilePackagingFormat to correctly set the packaging format use by the FOW</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_Floor.html"><strong><code>UFOW_Floor</code></strong></a></p>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-ufow_visibilitye_component"><a class="header" href="#class-ufow_visibilitye_component"><strong>Class: <code>UFOW_VisibilityE_Component</code></strong></a></h1>
<pre><code class="language-cpp">class FOGOFWAR_API UFOW_VisibilityE_Component
    : public UActorComponent
    , public IFOW_VisibilityEntity_Interface;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>ClassGroup</strong> = <em>Entity</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
<li><strong>DisplayName</strong> = <em>FOW_VisibilityEntityComponent</em></li>
</ul>
<hr />
<p>Can be added to any actor which need to be hidden when the player hasn't sight on it</p>
<blockquote>
<ul>
<li>Enable IsEntityFloorVolatile to use the default visibility update</li>
<li>Bind yourself to OnVisibilityChanged to customise the visibility update</li>
</ul>
</blockquote>
<p>Contained by : <a href="reference/classes//reference/classes/UFOW_EntityVisibilityHandler.html"><strong><code>UFOW_EntityVisibilityHandler</code></strong></a></p>
<hr />
<h1 id="properties-2"><a class="header" href="#properties-2"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="onvisibilitychanged"><a class="header" href="#onvisibilitychanged"><strong><code>OnVisibilityChanged</code></strong></a></h1>
<pre><code class="language-cpp">public:
FOnVisibilityChangedd OnVisibilityChanged;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-15"><a class="header" href="#specifiers-15">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintAssignable</strong></li>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>FOW</em></li>
</ul>
<hr />
<p>Called every time the Visibility state has changed</p>
</li>
</ul>
<hr />
<p><em>Documentation built with <a href="https://github.com/PsichiX/unreal-doc"><strong><code>Unreal-Doc</code> v1.0.9</strong></a> tool by <a href="https://github.com/PsichiX"><strong><code>PsichiX</code></strong></a></em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
